<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Singleton Design Pattern â€” Complete Wiki</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“˜</text></svg>">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true,theme:'base',themeVariables:{primaryColor:'#1e3a5f',primaryTextColor:'#f1f5f9',primaryBorderColor:'#3b82f6',lineColor:'#60a5fa',secondaryColor:'#2d1b4e',secondaryTextColor:'#f1f5f9',secondaryBorderColor:'#8b5cf6',tertiaryColor:'#1a3a2a',tertiaryTextColor:'#f1f5f9',tertiaryBorderColor:'#10b981',mainBkg:'#1e3a5f',nodeBorder:'#3b82f6',clusterBkg:'#0f172a',clusterBorder:'#334155',titleColor:'#f1f5f9',edgeLabelBackground:'#1e293b',nodeTextColor:'#f1f5f9',actorBkg:'#1e3a5f',actorBorder:'#3b82f6',actorTextColor:'#f1f5f9',actorLineColor:'#60a5fa',signalColor:'#60a5fa',signalTextColor:'#f1f5f9',labelBoxBkgColor:'#1e293b',labelBoxBorderColor:'#3b82f6',labelTextColor:'#f1f5f9',loopTextColor:'#f1f5f9',activationBorderColor:'#3b82f6',activationBkgColor:'#1e3a5f',sequenceNumberColor:'#f1f5f9',noteBkgColor:'#2d1b4e',noteTextColor:'#e2e8f0',noteBorderColor:'#8b5cf6',classText:'#f1f5f9',relationColor:'#60a5fa',relationLabelColor:'#94a3b8',fontFamily:'Inter',fontSize:'14px',background:'#0f172a'}});</script>
<style>
:root{--bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-tertiary:#334155;--accent-blue:#3b82f6;--accent-purple:#8b5cf6;--accent-green:#10b981;--accent-red:#ef4444;--accent-yellow:#f59e0b;--accent-cyan:#06b6d4;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--border-color:#334155;--glass-bg:rgba(30,41,59,0.7);--glass-border:rgba(148,163,184,0.1);}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}
html{scroll-behavior:smooth;}
body{font-family:'Inter',sans-serif;background:var(--bg-primary);color:var(--text-primary);line-height:1.6;font-size:1rem;padding-top:52px;}
::-webkit-scrollbar{width:8px;}::-webkit-scrollbar-track{background:var(--bg-secondary);}::-webkit-scrollbar-thumb{background:var(--bg-tertiary);border-radius:4px;}::-webkit-scrollbar-thumb:hover{background:var(--accent-blue);}
.wiki-container{max-width:100%;margin:0 auto;padding:0 2rem 4rem;}
.hero{background:linear-gradient(135deg,#0f172a 0%,#1e1b4b 50%,#0f172a 100%);border-bottom:1px solid var(--border-color);padding:3rem 2rem 3rem;text-align:center;position:relative;overflow:hidden;}
.hero::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at 50% 0%,rgba(59,130,246,0.15) 0%,transparent 70%);}
.hero-badge{display:inline-flex;align-items:center;gap:0.5rem;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);color:var(--accent-blue);padding:0.375rem 1rem;border-radius:999px;font-size:0.875rem;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;margin-bottom:1.5rem;}
.hero h1{font-size:clamp(2.5rem,5vw,4rem);font-weight:900;background:linear-gradient(135deg,#f1f5f9,#93c5fd,#a78bfa);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin-bottom:1rem;position:relative;}
.hero-subtitle{font-size:1.25rem;color:var(--text-secondary);max-width:700px;margin:0 auto 2rem;}
.hero-meta{display:flex;justify-content:center;gap:2rem;flex-wrap:wrap;font-size:0.9rem;color:var(--text-muted);}
.hero-meta span{display:flex;align-items:center;gap:0.4rem;}
.hero-meta i{color:var(--accent-blue);}
/* Top toolbar â€” horizontal bar above all content */
.top-toolbar{position:fixed;top:0;left:0;right:0;z-index:1000;display:flex;align-items:center;justify-content:space-between;padding:0.5rem 1.25rem;background:rgba(15,23,42,0.95);backdrop-filter:blur(12px);border-bottom:1px solid rgba(59,130,246,0.15);box-shadow:0 2px 12px rgba(0,0,0,0.3);overflow:hidden;}
.toolbar-left,.toolbar-right{display:flex;align-items:center;gap:0.5rem;}
.fab-btn{width:38px;height:38px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(30,41,59,0.8);color:#93c5fd;font-size:0.9rem;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.25);transition:background-color 0.2s,border-color 0.2s,color 0.2s,transform 0.2s;display:flex;align-items:center;justify-content:center;text-decoration:none;padding:0;-webkit-tap-highlight-color:transparent;outline:none;}
.fab-btn.active{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-color:transparent;color:#fff;}
.fab-back{border-color:rgba(239,68,68,0.35);color:#fca5a5;width:36px;height:36px;font-size:0.8rem;margin-left:0.75rem;}
.fab-back:hover{border-color:var(--accent-red);background:rgba(239,68,68,0.15);color:#fca5a5;}
.scroll-percent{font-family:'JetBrains Mono',monospace;font-size:0.6875rem;font-weight:700;color:var(--text-muted);user-select:none;min-width:2rem;text-align:center;}
/* Nav panel â€” anchored below toolbar */
.nav-panel{position:fixed;top:3.5rem;left:1rem;background:rgba(15,23,42,0.97);backdrop-filter:blur(16px);border:1px solid rgba(59,130,246,0.3);border-radius:1rem;padding:1rem;z-index:1001;max-height:70vh;overflow-y:auto;width:220px;max-width:calc(100vw - 2rem);box-shadow:0 12px 40px rgba(0,0,0,0.5);opacity:0;visibility:hidden;transform:translateY(-10px) scale(0.95);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0.25s;}
.nav-panel.open{opacity:1;visibility:visible;transform:translateY(0) scale(1);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0s;}
.nav-panel-title{font-size:0.6875rem;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.08em;margin-bottom:0.5rem;padding:0 0.25rem;}
.nav-panel a{display:flex;align-items:center;gap:0.5rem;padding:0.5rem 0.625rem;border-radius:0.5rem;font-size:0.8125rem;font-weight:500;text-decoration:none;color:#93c5fd;transition:background-color 0.15s,color 0.15s;min-height:44px;}
.nav-panel a i{width:16px;text-align:center;font-size:0.75rem;color:var(--accent-blue);}
.nav-panel::-webkit-scrollbar{width:4px;}
.nav-panel::-webkit-scrollbar-thumb{background:#475569;border-radius:2px;}
.section{margin:3rem 0;scroll-margin-top:5rem;overflow:hidden;}
.section-header{display:flex;align-items:center;gap:1rem;margin-bottom:2rem;padding-bottom:1rem;border-bottom:2px solid var(--border-color);flex-wrap:wrap;}
.section-icon{width:3rem;height:3rem;border-radius:0.75rem;display:flex;align-items:center;justify-content:center;font-size:1.25rem;flex-shrink:0;}
.section-icon.blue{background:rgba(59,130,246,0.15);color:var(--accent-blue);}
.section-icon.purple{background:rgba(139,92,246,0.15);color:var(--accent-purple);}
.section-icon.green{background:rgba(16,185,129,0.15);color:var(--accent-green);}
.section-icon.red{background:rgba(239,68,68,0.15);color:var(--accent-red);}
.section-icon.yellow{background:rgba(245,158,11,0.15);color:var(--accent-yellow);}
.section-icon.cyan{background:rgba(6,182,212,0.15);color:var(--accent-cyan);}
.section-title{font-size:1.875rem;font-weight:800;}
.section-num{font-size:0.875rem;color:var(--text-muted);font-weight:600;}
.card{background:var(--glass-bg);backdrop-filter:blur(10px);border:1px solid var(--glass-border);border-radius:1rem;padding:0;transition:border-color 0.3s;margin-bottom:0.75rem;overflow:hidden;}
.card.open{overflow:visible;}
.card:hover{border-color:rgba(59,130,246,0.3);}
.card-title{font-size:1.125rem;font-weight:700;margin:0;padding:1rem 1.25rem;display:flex;align-items:center;gap:0.5rem;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;position:relative;}
.card-title::after{content:'\f078';font-family:'Font Awesome 6 Free';font-weight:900;font-size:0.75rem;color:var(--text-muted);margin-left:auto;transition:transform 0.3s;}
.card.open .card-title::after{transform:rotate(180deg);}
.card-body{max-height:0;overflow:hidden;transition:max-height 0.4s cubic-bezier(0.4,0,0.2,1),padding 0.3s;padding:0 1.25rem;}
.card.open .card-body{max-height:none;padding:0 1.25rem 1.25rem;overflow:visible;}
/* Jr â†’ Sr toggle system */
.jr-sr-list{display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;}
@media(max-width:768px){.jr-sr-list{grid-template-columns:1fr;}}
.jr-sr-item{position:relative;display:flex;flex-direction:column;}
.jr-sr-item>.callout{flex:1;display:flex;flex-direction:column;}
.sr-toggle{display:flex;width:fit-content;align-items:center;gap:0.4rem;margin-top:auto;padding:0.5rem 0.9rem 0.4rem;border-radius:999px;border:1px solid rgba(16,185,129,0.4);background:rgba(16,185,129,0.1);color:#6ee7b7;font-size:0.8rem;font-weight:600;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent;position:relative;z-index:11;}
.sr-toggle:hover{background:rgba(16,185,129,0.2);border-color:var(--accent-green);color:#a7f3d0;}
.sr-solution-wrap{position:absolute;left:0;right:0;top:0;z-index:10;pointer-events:none;opacity:0;transition:opacity 0.25s ease;}
.sr-solution-wrap.show{pointer-events:auto;opacity:1;}
@media(max-width:768px){
.sr-solution-wrap{position:static;opacity:0;max-height:0;overflow:hidden;transition:opacity 0.25s ease,max-height 0.4s cubic-bezier(0.4,0,0.2,1);}
.sr-solution-wrap.show{opacity:1;max-height:3000px;pointer-events:auto;}
}
.sr-solution-wrap>.sr-solution{margin:0;padding:1.25rem 1.5rem;border-left:3px solid var(--accent-green);border-radius:0.75rem;background:#0a1f14;border:1px solid rgba(16,185,129,0.3);box-shadow:0 12px 48px rgba(0,0,0,0.7),0 0 0 1px rgba(16,185,129,0.15);min-height:100%;}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;align-items:start;}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:1.5rem;align-items:start;}
.grid-4{display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;align-items:start;}
.grid-9{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;}
.grid-2>*,.grid-3>*,.grid-4>*,.grid-9>*{min-width:0;}
.span-full{grid-column:1 / -1;}
@media(max-width:768px){.grid-2,.grid-3,.grid-4,.grid-9{grid-template-columns:1fr;}}
.diagram-zoom-btn{width:30px;height:30px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(15,23,42,0.9);color:#93c5fd;font-size:0.75rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:background-color 0.2s,border-color 0.2s,color 0.2s;-webkit-tap-highlight-color:transparent;}
/* Tablet & mobile responsive */
@media(max-width:1024px){
body{font-size:0.9375rem;padding-top:48px;}
.wiki-container{padding:0 1rem 2rem;}
.hero{padding:2.5rem 1rem 2rem;}
.hero h1{font-size:clamp(1.75rem,4vw,2.5rem);}
.hero-subtitle{font-size:1rem;}
.hero-meta{gap:1rem;font-size:0.8rem;}
.section{margin:2rem 0;scroll-margin-top:4.5rem;}
.section-title{font-size:1.375rem;}
.section-header{gap:0.75rem;margin-bottom:1.25rem;}
.section-icon{width:2.25rem;height:2.25rem;font-size:1rem;}
.card{margin-bottom:1rem;border-radius:0.75rem;}
.card-title{font-size:1rem;}
.callout{padding:1rem;margin:0.75rem 0;}
.macos-body{padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.8rem;line-height:1.5;}
.grid-2{gap:1rem;}
.grid-3{grid-template-columns:repeat(2,1fr);gap:0.75rem;}
table{font-size:0.8125rem;}
td,th{padding:0.5rem 0.75rem;}
.top-toolbar{padding:0.375rem 0.75rem;}
.fab-btn{width:36px;height:36px;font-size:0.8rem;}
.diagram-zoom-btn{width:44px;height:44px;}
.sr-toggle{padding:0.75rem 1rem;min-height:44px;display:inline-flex;align-items:center;}
.nav-panel{top:3rem;left:0.5rem;width:180px;}
.mermaid-container{padding:1rem;max-height:50vh;}
.diagram-hint{display:block;}
}
@media(max-width:480px){
body{font-size:1rem;padding-top:44px;}
.wiki-container{padding:0 0.625rem 1.5rem;}
.hero{padding:2rem 0.75rem 1.5rem;}
.hero h1{font-size:1.5rem;}
.hero-subtitle{font-size:0.875rem;}
.section-title{font-size:1.2rem;}
.card-title{font-size:0.9375rem;padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.75rem;}
.top-toolbar{padding:0.25rem 0.5rem;}
.fab-btn{width:36px;height:36px;font-size:0.75rem;}
.diagram-zoom-btn{width:44px;height:44px;}
.nav-panel{top:2.75rem;left:0.5rem;width:min(170px,calc(100vw - 1rem));}
.section{scroll-margin-top:3.5rem;}
th{white-space:normal;word-break:break-word;}
.footer{padding:2rem 1rem;}
}
.macos-window{background:#1a1a2e;border-radius:0.75rem;border:1px solid rgba(255,255,255,0.08);overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.5);margin-bottom:1.5rem;max-width:100%;margin-left:auto;margin-right:auto;}
@media(min-width:1025px){.macos-window{max-width:85%;}}
.macos-titlebar{background:#2d2d3f;padding:0.75rem 1rem;display:flex;align-items:center;gap:0.5rem;border-bottom:1px solid rgba(255,255,255,0.05);}
.dot{width:12px;height:12px;border-radius:50%;}
.dot-red{background:#ff5f57;}.dot-yellow{background:#ffbd2e;}.dot-green{background:#28c840;}
.macos-filename{margin-left:0.75rem;font-size:0.8rem;color:#6b7280;font-family:'JetBrains Mono',monospace;}
.macos-body{padding:1.25rem 1.5rem;max-height:400px;overflow-y:auto;overflow-x:auto;overscroll-behavior:contain;}
.macos-body::-webkit-scrollbar{width:6px;}
.macos-body::-webkit-scrollbar-track{background:rgba(30,41,59,0.5);border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb{background:#475569;border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb:hover{background:#64748b;}
.macos-body pre{margin:0;padding:0;background:transparent;overflow-x:auto;}
.macos-body pre code{display:block!important;font-family:'JetBrains Mono',monospace;font-size:0.9rem;line-height:1.6;background:transparent!important;}
.callout{border-radius:0.75rem;padding:1.25rem 1.5rem;border-left:4px solid;margin:1rem 0;}
.callout-danger{background:rgba(239,68,68,0.08);border-color:var(--accent-red);}
.callout-success{background:rgba(16,185,129,0.08);border-color:var(--accent-green);}
.callout-info{background:rgba(59,130,246,0.08);border-color:var(--accent-blue);}
.callout-warning{background:rgba(245,158,11,0.08);border-color:var(--accent-yellow);}
.callout-title{font-weight:700;font-size:0.9rem;text-transform:uppercase;letter-spacing:0.05em;margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;}
.callout-danger .callout-title{color:var(--accent-red);}
.callout-success .callout-title{color:var(--accent-green);}
.callout-info .callout-title{color:var(--accent-blue);}
.callout-warning .callout-title{color:var(--accent-yellow);}
.table-wrapper{overflow-x:auto;border-radius:0.75rem;border:1px solid var(--border-color);margin-bottom:1.5rem;}
table{width:100%;border-collapse:collapse;}
thead{background:rgba(59,130,246,0.1);}
th{padding:0.875rem 1.25rem;text-align:left;font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);white-space:nowrap;}
td{padding:0.875rem 1.25rem;border-top:1px solid var(--border-color);font-size:0.9rem;vertical-align:top;}
tr:hover td{background:rgba(255,255,255,0.02);}
:not(pre)>code{font-family:'JetBrains Mono',monospace;font-size:max(0.75rem,0.85em);background:rgba(255,255,255,0.08)!important;padding:0.125rem 0.375rem!important;border-radius:0.3rem;color:#93c5fd!important;display:inline!important;overflow-wrap:break-word;word-break:break-word;}
.badge{display:inline-flex;align-items:center;padding:0.2rem 0.6rem;border-radius:0.375rem;font-size:0.75rem;font-weight:700;}
.badge-blue{background:rgba(59,130,246,0.15);color:#93c5fd;}
.badge-green{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.badge-red{background:rgba(239,68,68,0.15);color:#fca5a5;}
.badge-yellow{background:rgba(245,158,11,0.15);color:#fcd34d;}
.badge-purple{background:rgba(139,92,246,0.15);color:#c4b5fd;}
.comparison-grid{display:grid;grid-template-columns:1fr auto 1fr;gap:1rem;align-items:start;}
.comparison-panel{border-radius:0.75rem;overflow:hidden;border:1px solid;padding-bottom:1rem;}
.comparison-panel>.macos-body,.comparison-panel>div:not(.comparison-header){padding-left:1.25rem;padding-right:1.25rem;}
.comparison-panel.bad{border-color:rgba(239,68,68,0.3);}
.comparison-panel.good{border-color:rgba(16,185,129,0.3);}
.comparison-header{padding:1rem 1.5rem;font-weight:700;display:flex;align-items:center;gap:0.5rem;}
.comparison-panel.bad .comparison-header{background:rgba(239,68,68,0.15);color:#fca5a5;}
.comparison-panel.good .comparison-header{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.vs-badge{width:3rem;height:3rem;border-radius:50%;background:linear-gradient(135deg,#ef4444,#3b82f6);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:0.875rem;align-self:center;justify-self:center;box-shadow:0 0 20px rgba(59,130,246,0.4);flex-shrink:0;margin-top:3rem;}
@media(max-width:900px){.comparison-grid{grid-template-columns:1fr;}}
.qa-item{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.qa-header{padding:1.25rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:flex-start;gap:1rem;transition:background 0.2s;}
.qa-header:hover{background:rgba(255,255,255,0.03);}
.qa-question{font-weight:700;font-size:1rem;color:var(--text-primary);}
.qa-meta{font-size:0.8rem;color:var(--text-muted);margin-top:0.25rem;}
.qa-chevron{color:var(--text-muted);transition:transform 0.3s;flex-shrink:0;margin-top:0.25rem;}
.qa-item.active .qa-chevron{transform:rotate(180deg);}
.qa-body{max-height:0;overflow:hidden;transition:max-height 0.5s ease;}
.qa-item.active .qa-body{max-height:6000px;}
.qa-content{padding:0 1.5rem 1.5rem;}
.qa-think{background:rgba(139,92,246,0.08);border-left:3px solid var(--accent-purple);border-radius:0.5rem;padding:1rem 1.25rem;margin-bottom:1rem;font-style:italic;font-size:0.95rem;color:#c4b5fd;}
.qa-think strong{color:var(--accent-purple);font-style:normal;}
.qa-great{background:rgba(16,185,129,0.08);border-left:3px solid var(--accent-green);border-radius:0.5rem;padding:1rem 1.25rem;margin-top:1rem;font-size:0.95rem;color:#6ee7b7;}
.qa-great strong{color:var(--accent-green);}
.collapsible{border:1px solid var(--border-color);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.collapsible-header{padding:1rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,0.02);transition:background 0.2s;}
.collapsible-header:hover{background:rgba(255,255,255,0.05);}
.collapsible-chevron{color:var(--text-muted);transition:transform 0.3s;}
.collapsible.active .collapsible-chevron{transform:rotate(180deg);}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height 0.4s ease;}
.collapsible.active .collapsible-content{max-height:10000px;}
.collapsible-body{padding:1.5rem;border-top:1px solid var(--border-color);}
ul.styled{list-style:none;padding:0;}
ul.styled li{padding:0.5rem 0 0.5rem 1.5rem;position:relative;color:var(--text-secondary);font-size:0.95rem;border-bottom:1px solid rgba(255,255,255,0.04);}
ul.styled li:last-child{border-bottom:none;}
ul.styled li::before{content:'â–¸';position:absolute;left:0;color:var(--accent-blue);font-size:0.8rem;top:0.6rem;}
ul.styled.green li::before{color:var(--accent-green);}
ul.styled.red li::before{color:var(--accent-red);content:'âœ—';}
.tab-container{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;overflow:hidden;margin-bottom:1.5rem;}
.tab-header{display:flex;background:rgba(0,0,0,0.2);border-bottom:1px solid var(--border-color);overflow-x:auto;}
.tab-btn{padding:0.75rem 1.25rem;cursor:pointer;font-size:0.85rem;font-weight:600;color:var(--text-muted);border-bottom:2px solid transparent;white-space:nowrap;transition:color 0.2s,border-color 0.2s;background:none;border-top:none;border-left:none;border-right:none;}
.tab-btn.active{color:var(--accent-blue);border-bottom-color:var(--accent-blue);}
.tab-btn:hover{color:var(--text-primary);}
.tab-panel{display:none;padding:1.5rem;}
.tab-panel.active{display:block;}
.cheat-card{background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:0.75rem;padding:1.25rem;transition:border-color 0.2s,transform 0.2s;min-width:0;overflow:hidden;}
.cheat-card pre{overflow-x:auto;}
.cheat-card-title{font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-muted);margin-bottom:0.75rem;}
.cheat-card-body{font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:#a5f3fc;line-height:1.5;}
.footer{text-align:center;padding:3rem 2rem;color:var(--text-muted);border-top:1px solid var(--border-color);margin-top:4rem;font-size:0.875rem;}
.mermaid-container{background:rgba(15,23,42,0.95);border:1px solid rgba(59,130,246,0.3);border-radius:12px;padding:2rem 1.5rem;margin:1rem 0;overflow:auto;overscroll-behavior:contain;-webkit-overflow-scrolling:touch;box-shadow:0 0 20px rgba(59,130,246,0.08);max-height:60vh;touch-action:pan-x pan-y;position:relative;max-width:100%;}
.diagram-zoom-controls{position:absolute;top:0.5rem;right:0.5rem;display:flex;gap:0.25rem;z-index:5;}
.diagram-zoom-btn:hover{background:rgba(59,130,246,0.2);color:#fff;}
.mermaid-container .mermaid{display:flex;justify-content:center;min-width:fit-content;}
.mermaid-container .mermaid svg{height:auto;}
.diagram-hint{display:none;position:absolute;bottom:0.5rem;right:0.75rem;font-size:0.6875rem;color:var(--text-muted);background:rgba(15,23,42,0.85);padding:0.2rem 0.5rem;border-radius:4px;pointer-events:none;}
/* Collapsible diagram toggle */
.diagram-toggle{display:flex;align-items:center;gap:0.5rem;padding:0.6rem 1rem;margin:0.75rem 0;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:0.5rem;cursor:pointer;color:#93c5fd;font-size:0.875rem;font-weight:600;user-select:none;-webkit-tap-highlight-color:transparent;transition:background-color 0.2s,border-color 0.2s;min-height:44px;}
.diagram-toggle:hover{background:rgba(59,130,246,0.15);border-color:var(--accent-blue);}
.diagram-toggle .chevron{font-size:0.7rem;transition:transform 0.3s;margin-left:auto;color:var(--text-muted);}
.diagram-toggle.open .chevron{transform:rotate(180deg);}
.mermaid-container.collapsed{max-height:0;overflow:hidden;padding:0;margin:0;border:none;box-shadow:none;}
/* Class diagram colors */
.mermaid .classGroup rect{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid .classGroup .label{fill:#f1f5f9!important;font-weight:600!important;}
.mermaid .classLabel .label{fill:#93c5fd!important;}
.mermaid .classTitle{font-weight:700!important;fill:#60a5fa!important;font-size:16px!important;}
.mermaid .classTitleText{fill:#60a5fa!important;font-size:16px!important;font-weight:700!important;}
.mermaid .relation{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .cardinality{fill:#94a3b8!important;}
.mermaid defs marker path{fill:#60a5fa!important;stroke:#60a5fa!important;}
/* Sequence diagram colors */
.mermaid .actor-line{stroke:#3b82f6!important;stroke-width:2px!important;stroke-dasharray:4;}
.mermaid .actor{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid text.actor>tspan{fill:#e2e8f0!important;font-weight:600!important;}
.mermaid .messageLine0,.mermaid .messageLine1{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .messageText{fill:#f1f5f9!important;font-weight:500!important;}
.mermaid .note{fill:#2d1b4e!important;stroke:#8b5cf6!important;stroke-width:1.5px!important;}
.mermaid .noteText>tspan{fill:#e2e8f0!important;}
.mermaid .activation0,.mermaid .activation1,.mermaid .activation2{fill:#1e3a5f!important;stroke:#3b82f6!important;}
.mermaid .loopText>tspan{fill:#94a3b8!important;}
.mermaid .loopLine{stroke:#334155!important;}
/* Flowchart node text */
.mermaid .nodeLabel{color:#f1f5f9!important;font-weight:500!important;}
.mermaid .edgeLabel{background:#1e293b!important;color:#94a3b8!important;}
.mermaid .label{color:#f1f5f9!important;}
h3.sub{font-size:1.1rem;font-weight:700;margin:1.5rem 0 0.75rem;color:var(--text-primary);}
p.body-text{color:var(--text-secondary);font-size:0.95rem;margin-bottom:0.75rem;}
@media(max-width:900px){.vs-badge{margin-top:0.5rem;margin-bottom:0.5rem;}}
@media(max-width:768px){.collapsible-body{padding:1rem;}.tab-btn{padding:0.875rem 1rem;min-height:44px;}.tab-panel{padding:1rem;}}
@media(max-width:480px){.collapsible-body{padding:0.75rem;}.hero-meta{gap:0.5rem;}.qa-content{padding:0 1rem 1rem;}}
@media(max-width:375px){.wiki-container{padding:0 0.5rem 1.5rem;}.qa-content{padding:0 0.75rem 0.75rem;}}
@media(max-width:360px){
  .top-toolbar{padding:0.25rem 0.25rem;}
  .toolbar-left,.toolbar-right{gap:0.25rem;}
  .fab-btn{width:32px;height:32px;font-size:0.7rem;}
  .fab-back{width:32px;height:32px;margin-left:0.25rem;}
  .scroll-percent{min-width:1.75rem;font-size:0.6rem;}
}
@media(hover:hover){
  .fab-btn:hover{background:rgba(59,130,246,0.2);border-color:var(--accent-blue);color:#fff;transform:scale(1.08);}
  .cheat-card:hover{border-color:var(--accent-blue);transform:translateY(-2px);}
  .nav-panel a:hover{background:rgba(59,130,246,0.15);color:#fff;}
}
@media(prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:0.01ms!important;transition-duration:0.01ms!important;}html{scroll-behavior:auto;}}
</style>
</head>
<body>

<div class="hero">
  <div style="position:relative;z-index:1;">
    <div class="hero-badge"><i class="fa-solid fa-gem"></i> GoF Creational Pattern</div>
    <h1>Singleton Design Pattern</h1>
    <p class="hero-subtitle">One instance. One access point. Thread-safe by design.</p>
    <div class="hero-meta">
      <span><i class="fa-solid fa-layer-group"></i> Creational Pattern</span>
      <span><i class="fa-brands fa-microsoft"></i> C# / .NET</span>
      <span><i class="fa-solid fa-list-check"></i> 25 Interview Q&amp;As</span>
      <span><i class="fa-solid fa-bug"></i> 3 Bug Case Studies</span>
      <span><i class="fa-solid fa-shield-halved"></i> 7 Pitfalls</span>
    </div>
  </div>
</div>

<div class="wiki-container">


<!-- Top toolbar â€” all controls in one horizontal bar -->
<div class="top-toolbar">
  <div class="toolbar-left">
    <button class="fab-btn" id="navFab" title="Navigate sections"><i class="fa-solid fa-compass"></i></button>
    <button class="fab-btn" id="expandAllBtn" title="Expand all cards"><i class="fa-solid fa-angles-down"></i></button>
    <button class="fab-btn" id="fullscreenBtn" title="Toggle fullscreen"><i class="fa-solid fa-expand"></i></button>
  </div>
  <div class="toolbar-right">
    <button class="fab-btn" id="scrollUp" title="Scroll up"><i class="fa-solid fa-chevron-up"></i></button>
    <span class="scroll-percent" id="percentText">0%</span>
    <button class="fab-btn" id="scrollDown" title="Scroll down"><i class="fa-solid fa-chevron-down"></i></button>
    <a href="../index.html" class="fab-btn fab-back" title="Back to Pattern Playbook"><i class="fa-solid fa-arrow-left"></i></a>
  </div>
</div>
<div class="nav-panel" id="navPanel">
  <div class="nav-panel-title">Jump to Section</div>
  <a href="#s3"><i class="fa-solid fa-lightbulb"></i> Analogies</a>
  <a href="#s4"><i class="fa-solid fa-diagram-project"></i> Core Pattern</a>
  <a href="#s5"><i class="fa-solid fa-graduation-cap"></i> Jr vs Sr</a>
  <a href="#s6"><i class="fa-solid fa-code"></i> Implementations</a>
  <a href="#s10"><i class="fa-solid fa-bug"></i> Bug Studies</a>
  <a href="#s12"><i class="fa-solid fa-cubes"></i> SOLID</a>
  <a href="#s13"><i class="fa-solid fa-scale-balanced"></i> Comparisons</a>
  <a href="#s14"><i class="fa-solid fa-comments"></i> Interview Q&amp;As</a>
  <a href="#s15"><i class="fa-solid fa-compass-drafting"></i> When To Use</a>
  <a href="#s16"><i class="fa-solid fa-triangle-exclamation"></i> Pitfalls</a>
  <a href="#s18"><i class="fa-solid fa-bolt"></i> Cheat Sheet</a>
</div>

<!-- ============================================================ SECTION 3 -->
<section id="s3" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-lightbulb"></i></div>
    <div><div class="section-num">Section 3</div><h2 class="section-title">Real-World Analogies</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-mobile-screen" style="color:var(--accent-blue)"></i> Your Phone's Settings App â€” Deep Mapping</div>
    <p class="body-text">Think about the Settings app on your phone. There's only ONE Settings app â€” you can't install a second copy. No matter where you open it from (home screen, notification bar, or another app), you always get the SAME Settings app with the SAME data. If you change the Wi-Fi password in Settings, every app on your phone sees that new password immediately. You don't need to open separate Settings for each app â€” there's one shared instance that everyone uses.</p>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Phone Settings World</th><th>What It Means in Code</th></tr></thead>
        <tbody>
          <tr><td><strong>There's only ONE Settings app on your phone</strong> â€” you can't create a second one</td><td><strong>Single instance</strong> â€” the constructor is private, so nobody can call <code>new Singleton()</code></td></tr>
          <tr><td><strong>You open Settings the same way every time</strong> â€” tap the icon, always the same app</td><td><strong>Global access point</strong> â€” everyone calls <code>Singleton.Instance</code> to get the one shared object</td></tr>
          <tr><td><strong>Change Wi-Fi here, every app sees it</strong> â€” because they all read from the same place</td><td><strong>Shared state</strong> â€” all parts of the code read/write the same instance, so data is always consistent</td></tr>
          <tr><td><strong>Settings app loads only when you first open it</strong> â€” not when you boot the phone</td><td><strong>Lazy initialization</strong> â€” the instance is created only when someone first asks for it, saving memory</td></tr>
          <tr><td><strong>Two apps can't change Settings at the exact same time</strong> â€” the OS prevents conflicts</td><td><strong>Thread safety</strong> â€” a lock ensures only one thread creates or modifies the instance at a time</td></tr>
        </tbody>
      </table>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-circle-check"></i> Why This Analogy Works</div>
      <ul class="styled green">
        <li>You never "create" a new Settings app â€” your code never calls <code>new</code> on a Singleton</li>
        <li>Everyone on the phone shares the same Settings â€” every service in your app shares the same instance</li>
        <li>Changes in one place are visible everywhere â€” that's the whole point of having one shared object</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-quote-left" style="color:var(--accent-purple)"></i> Six Quick Analogies</div>
    <div class="grid-2">
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-sun"></i> The Sun</div>There's only one Sun. Every planet shares it. You don't create a new sun when you need light â€” you just look up. That's a Singleton.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-user-tie"></i> School Principal</div>A school has one principal. Every teacher and student goes to the same person for big decisions. You don't hire a new principal for each classroom.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-wifi"></i> Wi-Fi Router at Home</div>Your house has one router. Every device â€” phone, laptop, TV â€” connects to the same one. If you change the password, everyone needs the new one.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-trophy"></i> The Scoreboard at a Game</div>There's one scoreboard at a stadium. Every player, coach, and fan looks at the same board. You don't build a separate scoreboard for each person watching.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-landmark"></i> Country's President</div>A country has one president at a time. Everyone refers to the same person. You can't just "create" a second president whenever you want.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-clipboard"></i> Clipboard (Copy-Paste)</div>Your computer has one clipboard. When you copy something, it replaces whatever was there before. Every app reads from the same clipboard â€” that's shared state in a Singleton.</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-server" style="color:var(--accent-green)"></i> Six Real-World Use Cases</div>
    <div class="grid-2">
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-blue);margin-bottom:0.4rem;"><i class="fa-solid fa-database"></i> 1. Database Connection Pool</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Your app shares a fixed set of database connections instead of opening a new one for every request. One Singleton manages the pool â€” lending out connections and taking them back.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-cyan);margin-bottom:0.4rem;"><i class="fa-solid fa-gear"></i> 2. App Configuration</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Your app reads the config file once at startup and keeps it in memory. Every part of the app gets settings from the same place â€” no repeated file reads.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-purple);margin-bottom:0.4rem;"><i class="fa-solid fa-scroll"></i> 3. Logging</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">All parts of your app write logs through one shared logger. This ensures logs go to the same file in the right order, not scattered across 50 different writers.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.4rem;"><i class="fa-solid fa-memory"></i> 4. Cache</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Your app stores frequently used data in one shared cache. If every service had its own cache, the same data would be loaded from the database multiple times â€” wasteful.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-yellow);margin-bottom:0.4rem;"><i class="fa-solid fa-flag"></i> 5. Feature Flags</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Your app checks one central place to decide if a feature is ON or OFF. If each request checked independently, you'd get inconsistent behavior â€” some users see the feature, some don't.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.4rem;"><i class="fa-solid fa-shield-halved"></i> 6. Rate Limiter</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Your app uses one counter to track how many API calls a user has made. If each server thread had its own counter, users could bypass the limit by hitting different threads.</p>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 4 -->
<section id="s4" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-diagram-project"></i></div>
    <div><div class="section-num">Section 4</div><h2 class="section-title">Core Pattern &amp; UML</h2></div>
  </div>

  <div class="callout callout-info">
    <div class="callout-title"><i class="fa-solid fa-book"></i> GoF Formal Definition</div>
    <p style="font-style:italic;font-size:1.05rem;">"Ensure a class has only one instance, and provide a global point of access to it."</p>
    <p style="margin-top:0.75rem;color:var(--text-secondary);">The pattern solves two distinct problems: (1) it guarantees a class has just a single instance â€” useful when exactly one object is needed to coordinate actions across the system; and (2) it provides a global access point to that instance â€” avoiding the need to thread the instance through every call stack manually.</p>
  </div>

  <!-- UML Class Diagrams (Mermaid) -->
  <div class="grid-2">
    <div>
      <h3 class="sub">UML Diagram A â€” Generic Singleton</h3>
      <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
        <div class="mermaid">
classDiagram
    class Singleton {
        &lt;&lt;Singleton&gt;&gt;
        -Singleton? _instance$
        -object _lock$
        -Singleton()
        +Singleton Instance$
        +DoSomething() void
        +GetData() string
    }
    note for Singleton "Private constructor prevents new Singleton()\nStatic Instance is the only access point\nThread safety via lock or Lazy~T~\n{exactly one instance}"
        </div>
      </div>
    </div>
    <div>
      <h3 class="sub">UML Diagram B â€” ConnectionPoolManager</h3>
      <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
        <div class="mermaid">
classDiagram
    class ConnectionPoolManager {
        &lt;&lt;Singleton&gt;&gt;
        -Lazy~ConnectionPoolManager~ _lazy$
        -ConcurrentQueue~DbConnection~ _pool
        -int _maxSize
        -ConnectionPoolManager()
        +ConnectionPoolManager Instance$
        +Rent() DbConnection
        +Return(conn) void
        +PoolSize int
    }
    class OrderService {
        +PlaceOrderAsync(order) Task
    }
    class InventoryService {
        +GetStockAsync(sku) Task~int~
    }
    OrderService --> ConnectionPoolManager : uses Instance
    InventoryService --> ConnectionPoolManager : uses Instance
    note for ConnectionPoolManager "Both services share the SAME pool\nTwo pools = 2x connections = DB overload"
        </div>
      </div>
    </div>
  </div>

  <!-- Sequence Diagram: Thread Safety -->
  <h3 class="sub" style="margin-top:2rem;">Sequence Diagram â€” Lazy Initialization + Thread Safety</h3>
  <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
    <div class="mermaid">
sequenceDiagram
    participant T1 as Thread 1 (OrderService)
    participant T2 as Thread 2 (InventoryService)
    participant S as Singleton.Instance
    participant L as _lock object

    T1->>S: Access .Instance (first call)
    Note over S: _instance == null? YES
    T1->>L: Enter lock
    Note over L: T1 holds lock
    T2->>S: Access .Instance (concurrent)
    Note over S: _instance == null? YES
    T2->>L: Try enter lock â€” BLOCKED
    Note over L: T2 waits...
    T1->>S: Check again: _instance == null? YES
    T1->>S: _instance = new Singleton()
    T1->>L: Exit lock
    Note over L: T2 unblocked
    T2->>L: Enter lock
    T2->>S: Check again: _instance == null? NO
    T2->>L: Exit lock (skips creation)
    T2->>S: Returns existing _instance
    Note over T1,T2: Both threads now share the SAME instance âœ“
    </div>
  </div>

  <h3 class="sub">ConnectionPoolManager â€” Full Implementation</h3>
  <div class="macos-window">
    <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ConnectionPoolManager.cs</span></div>
    <div class="macos-body"><pre><code class="language-csharp">public sealed class ConnectionPoolManager
{
    // Lazy&lt;T&gt; with ExecutionAndPublication guarantees thread-safe single init
    private static readonly Lazy&lt;ConnectionPoolManager&gt; _lazy =
        new(() =&gt; new ConnectionPoolManager(), LazyThreadSafetyMode.ExecutionAndPublication);

    private readonly ConcurrentQueue&lt;DbConnection&gt; _pool = new();
    private readonly int _maxSize;
    private readonly string _connectionString;
    private volatile int _currentSize = 0;

    // Private constructor â€” no external instantiation
    private ConnectionPoolManager()
    {
        _connectionString = Environment.GetEnvironmentVariable("DB_CONN")
            ?? throw new InvalidOperationException("DB_CONN env var not set");
        _maxSize = 20;

        // Pre-warm with 5 connections
        for (int i = 0; i &lt; 5; i++)
            _pool.Enqueue(CreateConnection());
        _currentSize = 5;
    }

    public static ConnectionPoolManager Instance =&gt; _lazy.Value;
    public int PoolSize =&gt; _pool.Count;

    public DbConnection Rent()
    {
        if (_pool.TryDequeue(out var connection))
            return connection;

        if (_currentSize &lt; _maxSize)
        {
            Interlocked.Increment(ref _currentSize);
            return CreateConnection();
        }

        throw new InvalidOperationException("Connection pool exhausted.");
    }

    public void Return(DbConnection connection)
    {
        ArgumentNullException.ThrowIfNull(connection);
        if (connection.State != ConnectionState.Open)
        {
            Interlocked.Decrement(ref _currentSize);
            return;
        }
        _pool.Enqueue(connection);
    }

    private DbConnection CreateConnection()
    {
        var conn = new SqlConnection(_connectionString);
        conn.Open();
        return conn;
    }
}

// Services using the Singleton pool
public class OrderService
{
    public async Task PlaceOrderAsync(Order order)
    {
        var conn = ConnectionPoolManager.Instance.Rent();
        try
        {
            using var cmd = conn.CreateCommand();
            cmd.CommandText = "INSERT INTO Orders ...";
            await cmd.ExecuteNonQueryAsync();
        }
        finally
        {
            ConnectionPoolManager.Instance.Return(conn);
        }
    }
}

public class InventoryService
{
    public async Task&lt;int&gt; GetStockAsync(string sku)
    {
        var conn = ConnectionPoolManager.Instance.Rent(); // Same pool!
        try
        {
            using var cmd = conn.CreateCommand();
            cmd.CommandText = "SELECT Stock FROM Inventory WHERE SKU = @sku";
            cmd.Parameters.AddWithValue("@sku", sku);
            return (int)(await cmd.ExecuteScalarAsync())!;
        }
        finally
        {
            ConnectionPoolManager.Instance.Return(conn);
        }
    }
}</code></pre></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-arrows-spin" style="color:var(--accent-yellow)"></i> Double-Checked Locking â€” Sequence Walkthrough</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Step</th><th>Thread A</th><th>Thread B</th><th>_instance</th><th>What happens</th></tr></thead>
        <tbody>
          <tr><td>1</td><td>Checks <code>_instance == null</code></td><td>â€”</td><td><code>null</code></td><td>First check passes, proceeds to lock</td></tr>
          <tr><td>2</td><td>Acquires <code>lock(_lock)</code></td><td>Checks <code>_instance == null</code></td><td><code>null</code></td><td>Thread B also passes first check, waits for lock</td></tr>
          <tr><td>3</td><td>Checks <code>_instance == null</code> again (inside lock)</td><td>Blocked on lock</td><td><code>null</code></td><td>Second check passes â€” Thread A constructs</td></tr>
          <tr><td>4</td><td>Constructs &amp; assigns <code>_instance</code></td><td>Blocked</td><td>âœ… ready</td><td>Thread A releases lock</td></tr>
          <tr><td>5</td><td>Returns instance</td><td>Acquires lock, checks <code>_instance == null</code></td><td>âœ… ready</td><td>Second check FAILS â€” Thread B returns existing</td></tr>
          <tr><td>6</td><td>â€”</td><td>Returns existing instance</td><td>âœ… ready</td><td>Both threads share the same instance â€” correct!</td></tr>
        </tbody>
      </table>
    </div>
    <div class="callout callout-warning">
      <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> Why <code>volatile</code> is Critical</div>
      Without <code>volatile</code>, the CPU or JIT compiler may reorder instructions. Thread B could observe a non-null <code>_instance</code> pointer before the constructor body has finished executing. <code>volatile</code> inserts a memory barrier preventing this read reordering â€” ensuring Thread B sees a fully-initialized object.
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 5 -->
<section id="s5" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-graduation-cap"></i></div>
    <div><div class="section-num">Section 5</div><h2 class="section-title">Junior vs Senior Thinking</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-gear" style="color:var(--accent-blue)"></i> Scenario 1 â€” Configuration Manager</div>
    <p class="body-text">Both junior and senior developers need to load application configuration. The way they approach this reveals fundamentally different mental models about <strong>resource management</strong> (how carefully code uses memory, files, and connections), <strong>testability</strong> (how easy it is to write automated tests), and <strong>separation of concerns</strong> (keeping each class responsible for only one job).</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> Junior Approach</div>
        <div class="macos-body"><pre><code class="language-csharp">public class ConfigService
{
    public Dictionary&lt;string, string&gt; Settings { get; }

    public ConfigService()
    {
        // File I/O on every instantiation!
        var json = File.ReadAllText("appsettings.json");
        Settings = JsonSerializer
            .Deserialize&lt;Dictionary&lt;string, string&gt;&gt;(json)!;
    }

    public string Get(string key) =&gt; Settings[key];
}

public class OrderService
{
    public void ProcessOrder()
    {
        var config = new ConfigService(); // new instance every call!
        var connectionString =
            config.Get("Database:ConnectionString");
    }
}

public class InventoryService
{
    public void CheckStock()
    {
        var config = new ConfigService(); // another file read!
        var apiUrl = config.Get("Inventory:ApiUrl");
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> Senior Approach</div>
        <div class="macos-body"><pre><code class="language-csharp">public interface IConfigService
{
    string Get(string key);
    T GetSection&lt;T&gt;(string sectionName) where T : class, new();
}

public class ConfigService : IConfigService
{
    private readonly IConfiguration _configuration;
    public ConfigService(IConfiguration configuration)
        =&gt; _configuration = configuration;
    public string Get(string key)
        =&gt; _configuration[key]
            ?? throw new KeyNotFoundException(
                $"Config key '{key}' not found.");
    public T GetSection&lt;T&gt;(string sectionName) where T : class, new()
    {
        var section = new T();
        _configuration.GetSection(sectionName).Bind(section);
        return section;
    }
}

// DI Registration (once at startup)
builder.Services.AddSingleton&lt;IConfigService, ConfigService&gt;();

// Usage: injected, not constructed
public class OrderService
{
    private readonly IConfigService _config;
    public OrderService(IConfigService config) =&gt; _config = config;
    public void ProcessOrder()
    {
        var connStr = _config.Get("Database:ConnectionString");
    }
}</code></pre></div>
      </div>
    </div>
    <h3 class="sub">Why Junior Is Wrong â€” 5 Problems</h3>
    <div class="jr-sr-list">
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-1"></i> Performance Waste</div>Every time any part of the app needs a config value (like a database URL), the junior's code opens the file, reads the entire JSON, parses it, builds a dictionary â€” then throws it all away. Imagine a busy app handling 1,000 requests per second: that's 1,000 unnecessary disk reads per second for data that hasn't changed. It's like re-reading an entire book every time you need to recall one sentence.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Read Once, Reuse Forever</div>The senior's code reads the config file exactly <strong>once</strong> when the app starts. That parsed data lives in memory for the entire app lifetime. Every subsequent call just looks up a value from memory â€” which takes nanoseconds instead of milliseconds. It's like memorizing the answer on day one and never opening the book again.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-2"></i> Inconsistent State</div>Picture this: your app is running, and someone updates the config file during a deployment. Request A reads the old file, and Request B (arriving 1ms later) reads the new file. Now two requests in the same moment are using different database URLs or feature flags. This <strong>split-brain</strong> (where two parts of the same app disagree on which data is current) situation causes bugs that are nearly impossible to reproduce or debug.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> One Truth, Zero Conflicts</div>Since the config is loaded once into a single shared instance, every request sees the <strong>exact same data</strong>. No <strong>race conditions</strong> (two threads try to read/write the same data at the same time, producing unpredictable results), no split-brain. If you need to pick up config changes at runtime, the senior uses <strong><code>IOptionsMonitor&lt;T&gt;</code></strong> (a built-in ASP.NET feature that watches the config file for changes) which handles reloads <strong>atomically</strong> (happens as one uninterruptible operation â€” all of it completes, or none of it does) â€” all requests switch to the new config at the same time.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-3"></i> Memory Bloat</div>Each <code>new ConfigService()</code> creates a brand-new Dictionary object on <strong>the heap</strong> (the region of memory where objects live while your app runs). Under load, thousands of these short-lived objects pile up and the Garbage Collector (GC) has to work overtime to clean them. <strong>GC pauses</strong> (brief moments where the app freezes while the Garbage Collector cleans up unused objects) slow down your app â€” users experience random <strong>latency spikes</strong> (sudden delays between the user's click and the app's response). It's like buying a new notebook every time you need to jot one thing down, then immediately throwing it away.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> One Object, Zero GC Pressure</div>The <strong>DI container</strong> (the framework's built-in system that automatically creates and connects objects for you) creates <strong>one</strong> ConfigService instance and reuses it for every request. One dictionary lives in memory for the app's entire lifetime â€” no repeated <strong>allocations</strong> (reserving chunks of memory for new objects), no <strong>GC pressure</strong> (extra cleanup work for the Garbage Collector), no latency spikes. It's like having one notebook on your desk that you refer to every time.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-4"></i> Untestable</div>The junior's constructor does <code>File.ReadAllText("appsettings.json")</code> directly. In a unit test, that file probably doesn't exist â€” the test crashes. Even if you copy the file, you can't control what's in it per-test. You're stuck testing with real files instead of fake data. This makes tests slow, <strong>brittle</strong> (tests that break for reasons unrelated to your code), and dependent on the environment.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Mock It, Test Anything</div>The senior <strong>codes against an interface</strong> (writes code that depends on a contract like IConfigService, not a specific class) â€” not the <strong>concrete class</strong> (the actual implementation, not an interface). In tests, you <strong>inject</strong> (pass in through the constructor) a <strong><code>Mock&lt;IConfigService&gt;</code></strong> (a fake version of a dependency that you control in tests) that returns whatever values you want â€” no files needed. Each test can set different config values, <strong>run in isolation</strong> (each test is self-contained and doesn't affect others), and execute in milliseconds. This is the power of <strong>Dependency Injection</strong> (letting a framework supply your objects instead of creating them yourself) + interfaces.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-5"></i> Violates <strong>DRY</strong> (Don't Repeat Yourself) + <strong>SRP</strong> (Single Responsibility Principle â€” one class, one job)</div>Every service that needs config has to:<ul style="margin:0.5rem 0 0 1.25rem;"><li>Know the <strong>concrete class</strong> (the actual implementation, not an interface) name <code>ConfigService</code>.</li><li>Call <code>new ConfigService()</code> itself.</li><li>Handle missing keys on its own.</li></ul><p style="margin-top:0.5rem;">Config-loading logic is copy-pasted everywhere. Worse, <code>OrderService</code> now has two jobs â€” processing orders AND loading configuration. Rename the config class? Every file that uses it breaks.</p><button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> One Registration, Clean Separation</div><ul style="margin:0.5rem 0 0 1.25rem;"><li><strong>Register</strong> (tell the framework: when someone asks for X, give them Y) once in <code>Program.cs</code>:<br><code>builder.Services.AddSingleton&lt;IConfigService, ConfigService&gt;()</code></li><li>Every service just asks for <code>IConfigService</code> in its constructor â€” never creates anything.</li><li>Switch to <strong>Azure App Configuration</strong> (a cloud service for storing config centrally)? Change one line. Zero other files touched.</li></ul></div></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-scroll" style="color:var(--accent-purple)"></i> Scenario 2 â€” Application Logging</div>
    <p class="body-text">Logging is everywhere in production. How logging is implemented reveals enormous differences in maturity, <strong>operability</strong> (how easy it is to run and maintain in a live system), and <strong>observability</strong> (your ability to understand what's happening inside the app by reading its outputs) mindset.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> Junior Approach</div>
        <div class="macos-body"><pre><code class="language-csharp">public static class LogHelper
{
    public static void Log(string message)
    {
        Console.WriteLine(
            $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }
    public static void LogError(string message, Exception ex)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine(
            $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] " +
            $"ERROR: {message} | {ex.Message}");
        Console.ResetColor();
    }
}

public class PaymentService
{
    public void ChargeCustomer(string customerId, decimal amount)
    {
        LogHelper.Log($"Charging {customerId} for {amount}");
        try { /* payment logic */ }
        catch (Exception ex)
        {
            LogHelper.LogError("Payment failed", ex);
            throw;
        }
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> Senior Approach</div>
        <div class="macos-body"><pre><code class="language-csharp">// Step 1: Configure Serilog Singleton at startup
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .Enrich.WithProperty("Application", "PaymentAPI")
    .Enrich.WithCorrelationId()
    .WriteTo.Console(new JsonFormatter())
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();
builder.Host.UseSerilog();

// Step 2: Services use ILogger&lt;T&gt; via DI
public class PaymentService
{
    private readonly ILogger&lt;PaymentService&gt; _logger;
    public PaymentService(ILogger&lt;PaymentService&gt; logger)
        =&gt; _logger = logger;
    public async Task ChargeCustomerAsync(
        string customerId, decimal amount)
    {
        _logger.LogInformation(
            "Charging customer {CustomerId} amount {Amount:C}",
            customerId, amount);
        try { /* payment logic */ }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "Payment failed for {CustomerId} amount {Amount:C}",
                customerId, amount);
            throw;
        }
    }
}</code></pre></div>
      </div>
    </div>
    <h3 class="sub">Why Junior Logging Fails â€” 6 Problems</h3>
    <div class="jr-sr-list">
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-1"></i> Completely Untestable</div><code>static LogHelper</code> cannot be <strong>mocked</strong> (replaced with a fake version in tests) â€” it's a <strong>concrete static class</strong> (a class with no interface that you call directly â€” can't swap it out) baked into your code. In unit tests, every log call actually writes to <code>Console</code>, producing noise in test output. Worse, you can't verify "did my code log the right error message?" because there's no way to <strong>intercept</strong> (observe or redirect) static calls. It's like trying to test a phone call when the phone is bolted to the wall.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Inject ILogger&lt;T&gt; via DI</div>The senior uses <code>ILogger&lt;PaymentService&gt;</code> <strong>injected through constructor</strong> (passed in automatically by the framework). In tests, you pass a <code>Mock&lt;ILogger&lt;PaymentService&gt;&gt;</code> and verify exact log calls â€” zero console noise, full control. The <strong>DI container</strong> (the framework's built-in system that automatically creates and connects objects for you) <strong>wires up</strong> (automatically creates and connects) the real <strong>Serilog</strong> (a popular third-party logging library for .NET) logger in production automatically.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-2"></i> No Structured Logging</div>String interpolation like <code>$"Charging {customerId} for {amount}"</code> produces <strong>flat text blobs</strong> (plain unstructured text with no searchable fields). In a <strong>log aggregator</strong> (a tool that collects all your logs in one place so you can search them) like Seq, Datadog, or Elastic, you can't query "show me all payments over $1,000 that failed" â€” you'd have to write <strong>regex</strong> (complex pattern-matching expressions for searching text) through raw text. It's like writing receipts in paragraphs instead of a spreadsheet â€” good luck searching later.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Message Templates with Named Properties</div><strong>Serilog</strong> (a popular third-party logging library for .NET) uses <strong>message templates</strong>: <code>"Charging customer {CustomerId} amount {Amount:C}"</code>. Each <code>{placeholder}</code> becomes a searchable, <strong>indexed field</strong> (pre-processed for fast lookup, like a database column). In <strong>Seq</strong> (a log viewer/search tool) you can query <code>Amount > 1000 AND CustomerId = "C123"</code> instantly. <strong>Structured logging</strong> (each log entry is a record with named fields instead of a plain line of text) turns logs from text files into queryable databases.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-3"></i> No Log Levels</div>Every message hits <code>Console.WriteLine</code> â€” there's no way to show only errors in production but debug info in <strong>staging</strong> (a test environment that mirrors production). Under concurrent load, <code>Console.WriteLine</code> is <strong>synchronized</strong> (only one thread can write at a time â€” all others wait), creating a <strong>bottleneck</strong> (the one slow point that limits the whole system's speed). Your logging literally slows down your app when you need it most.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> MinimumLevel + Async Sinks</div><strong>Serilog</strong> (a popular third-party logging library for .NET) uses <strong>log levels</strong> (categories like Debug, Info, Warning, Error that let you filter by importance) â€” <code>.MinimumLevel.Information()</code> filters at the source so debug logs don't even get formatted in production. You can change levels at runtime via <code>appsettings.json</code> without redeploying. <strong>Sinks</strong> (destinations where logs get written â€” console, file, Seq, etc.) like Seq use <strong>async batching</strong> (entries written on a background thread in groups, so your code never waits), so logging never blocks your <strong>request pipeline</strong> (the chain of code that processes a user's HTTP request).</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-4"></i> Thread-Unsafe Console Colors</div><code>Console.ForegroundColor</code> is <strong>global mutable state</strong> (a value stored in one shared place that any thread can change at any moment). Thread A sets it to Red, Thread B sets it to Blue, Thread A resets â€” you get garbled rainbow output. Under <strong>high concurrency</strong> (many threads running at the same time), error messages might appear in green and info messages in red. The colors become meaningless noise.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> JSON + External Viewers</div>The senior outputs logs as <strong>JSON</strong> via <code>new JsonFormatter()</code>. No console colors needed â€” log viewers like <strong>Seq</strong> (a log viewer/search tool) and <strong>Kibana</strong> (a log visualization tool) display colors based on log level automatically. Each log entry is a self-contained JSON object, so there's zero shared mutable state and zero <strong>thread-safety</strong> (no risk of threads corrupting each other's data) issues.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-5"></i> Tight Coupling</div><strong>Tight Coupling</strong> (code so deeply linked to a specific class that swapping it out requires changing many files) â€” every class calls <code>LogHelper.Log()</code> directly, forming a <strong>concrete static dependency</strong> (hardwired to one specific class with no way to swap it). Want to switch from Console to <strong>Serilog</strong> (a popular third-party logging library for .NET), or add <strong>Application Insights</strong> (Microsoft's cloud monitoring service)? You'd have to find-and-replace across <strong>every file</strong> in the codebase. It's like hardcoding a phone number instead of using a contact list â€” change the number, update everywhere.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> One Registration, Swap Anytime</div>Services depend on <code>ILogger&lt;T&gt;</code> â€” an <strong>abstraction</strong> (a general contract like an interface, not tied to a specific implementation). The <strong>logging provider</strong> (the system that decides where logs actually go) is configured <strong>once</strong> at startup: <code>builder.Host.UseSerilog()</code>. Switch to <strong>NLog</strong> (another popular logging library)? Change one line. Add <strong>Application Insights</strong> (Microsoft's cloud monitoring service) alongside Serilog? Add one more sink. Zero service code changes.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-6"></i> No Correlation / Enrichment</div>When a failing request generates 20 log lines across 5 services, which lines belong together? The junior's logs have no <strong>correlation ID</strong> (a unique tag attached to every log line from one request, so you can filter by it), no <strong>request context</strong> (metadata like who made the request, what URL they hit), and no user identity. Debugging production issues means scrolling through thousands of <strong>interleaved</strong> (randomly mixed together in time order, not grouped by request) log lines hoping timestamps line up.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Automatic Enrichment Pipeline</div><strong>Enrichment</strong> (automatically adding extra fields like correlation ID, machine name to every log entry) is set up once: <code>.Enrich.WithCorrelationId()</code> automatically tags every log entry with the HTTP request's <strong>correlation ID</strong> (a unique tag attached to every log line from one request, so you can filter by it). Add <code>.Enrich.WithProperty("Application", "PaymentAPI")</code> for service name. In <strong>Seq</strong> (a log viewer/search tool), filter by <code>CorrelationId = "abc-123"</code> to see the entire request journey across all services instantly.</div></div>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 6 -->
<section id="s6" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-code"></i></div>
    <div><div class="section-num">Section 6</div><h2 class="section-title">Core Implementations</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-triangle-exclamation" style="color:var(--accent-red)"></i> Implementation 1 â€” Naive Singleton (BROKEN â€” Race Condition)</div>
    <p class="body-text">The naive implementation is the first thing most developers reach for. It fails catastrophically under concurrent access.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">NaiveSingleton.cs â€” DO NOT USE IN PRODUCTION</span></div>
      <div class="macos-body"><pre><code class="language-csharp">public class NaiveSingleton
{
    private static NaiveSingleton? _instance;

    // Simulates expensive initialization (DB connection, ML model, etc.)
    private NaiveSingleton() { Thread.Sleep(100); }

    public static NaiveSingleton Instance
    {
        get
        {
            // RACE CONDITION:
            // Thread A and Thread B can BOTH see _instance == null
            // simultaneously, before either has assigned it.
            // Result: TWO instances created. Pattern violated.
            if (_instance == null)
                _instance = new NaiveSingleton();

            return _instance;
        }
    }
}

// Demonstration of the race condition:
var tasks = Enumerable.Range(0, 10)
    .Select(_ =&gt; Task.Run(() =&gt; NaiveSingleton.Instance));
var instances = await Task.WhenAll(tasks);
var uniqueCount = instances.Distinct().Count();
// uniqueCount could be 2, 3, or more â€” NOT 1!</code></pre></div>
    </div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-bug"></i> The Race Condition Explained</div>
      Thread A reads <code>_instance == null</code> as true. Before Thread A executes <code>new NaiveSingleton()</code>, Thread B also reads <code>_instance == null</code> as still true (Thread A hasn't written yet). Both threads proceed to construct. Both assign to <code>_instance</code>. In the end, one assignment wins â€” but two constructors ran, two objects were created, and any initialization side effects (opening a DB connection, loading a model, starting a timer) happened twice.
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-shield-halved" style="color:var(--accent-blue)"></i> Implementation 2 â€” Double-Checked Locking (Thread-Safe)</div>
    <p class="body-text">The classic thread-safe approach. Use when you need lazy initialization with full control over the locking mechanism, or in environments without <code>Lazy&lt;T&gt;</code>.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ThreadSafeSingleton.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// sealed: prevents subclassing (subclass could create second instance)
public sealed class ThreadSafeSingleton
{
    // volatile: prevents CPU/JIT from reordering reads/writes
    // Without volatile, Thread B could see a non-null pointer
    // before the constructor has finished running
    private static volatile ThreadSafeSingleton? _instance;

    // Dedicated lock object â€” never lock on 'this' or typeof(T)
    private static readonly object _lock = new();

    private ThreadSafeSingleton() { }

    public static ThreadSafeSingleton Instance
    {
        get
        {
            // First check: avoid acquiring lock on every call
            // (lock only needed during first initialization)
            if (_instance == null)
            {
                lock (_lock)
                {
                    // Second check: another thread may have
                    // initialized between our first check and
                    // acquiring the lock
                    if (_instance == null)
                        _instance = new ThreadSafeSingleton();
                }
            }
            return _instance;
        }
    }
}</code></pre></div>
    </div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Keyword</th><th>Purpose</th><th>What breaks without it</th></tr></thead>
        <tbody>
          <tr><td><code>sealed</code></td><td>Prevents subclasses from creating additional instances</td><td>A subclass could be instantiated freely, creating a second instance</td></tr>
          <tr><td><code>volatile</code></td><td>Inserts memory barriers â€” all threads see writes in order</td><td>Thread B could read a non-null pointer to an object whose constructor has not finished yet</td></tr>
          <tr><td>1st null check</td><td>Fast path â€” skips lock acquisition after initialization</td><td>Every call to Instance would acquire the lock, serializing all readers (massive contention)</td></tr>
          <tr><td>2nd null check</td><td>Guards against race between first check and lock acquisition</td><td>Two threads could both pass first check and both construct â€” defeating the pattern</td></tr>
          <tr><td>Dedicated <code>_lock</code></td><td>Scoped lock object, no external contention</td><td>Locking on <code>this</code> allows external code to lock the same object, causing deadlocks</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-star" style="color:var(--accent-green)"></i> Implementation 3 â€” <code>Lazy&lt;T&gt;</code> (Recommended for Hand-Rolled)</div>
    <p class="body-text">The modern, idiomatic C# approach. <code>Lazy&lt;T&gt;</code> encapsulates all thread-safety logic in BCL-tested, production-hardened code â€” no manual locks needed.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ModernSingleton.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">public sealed class ModernSingleton
{
    // LazyThreadSafetyMode.ExecutionAndPublication:
    // - Only ONE thread calls the factory lambda
    // - Other threads block until initialization completes
    // - All threads then see the same, fully-initialized instance
    private static readonly Lazy&lt;ModernSingleton&gt; _lazy =
        new(() =&gt; new ModernSingleton(),
            LazyThreadSafetyMode.ExecutionAndPublication);

    private ModernSingleton() { }

    public static ModernSingleton Instance =&gt; _lazy.Value;

    // IsValueCreated: useful for diagnostics and health checks
    public static bool IsInitialized =&gt; _lazy.IsValueCreated;
}

// -------------------------------------------------------
// EAGER ALTERNATIVE: When you always need the instance
// and startup time is not a concern
// -------------------------------------------------------
public sealed class EagerSingleton
{
    // CLR guarantees this field is initialized before any
    // thread accesses it â€” thread-safe without any locks.
    // The type initializer (static constructor) runs exactly once.
    private static readonly EagerSingleton _instance = new();

    private EagerSingleton() { }

    public static EagerSingleton Instance =&gt; _instance;
}</code></pre></div>
    </div>
    <h3 class="sub">4 Reasons <code>Lazy&lt;T&gt;</code> is Best for Hand-Rolled Singletons</h3>
    <div class="grid-2">
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-1"></i> BCL-Tested Thread Safety</div>The .NET BCL team has battle-tested Lazy&lt;T&gt; across millions of applications. Its double-checked locking is implemented with precise memory barrier semantics â€” more reliable than hand-rolling it.</div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-2"></i> Exception Handling Built In</div>With ExecutionAndPublication, if the factory throws, the exception is cached and re-thrown on every subsequent access â€” ensuring consistent failure behavior rather than silently swallowing errors on retry.</div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-3"></i> Diagnostics via IsValueCreated</div>You can check _lazy.IsValueCreated in health check endpoints to verify the Singleton was initialized without forcing initialization. Double-checked locking has no equivalent diagnostic property.</div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-4"></i> Communicates Intent Clearly</div>new Lazy&lt;T&gt;(() =&gt; new T()) communicates "intentionally lazy" to every reader. Double-checked locking is 10+ lines that require careful review to verify correctness each time.</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-boxes-stacked" style="color:var(--accent-purple)"></i> Implementation 4 â€” DI Container (Production Standard)</div>
    <p class="body-text">In modern .NET applications, the DI container manages singleton lifetime. This is the recommended approach for all new projects using ASP.NET Core or Generic Host.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DIRegistration.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// 1. Define the abstraction
public interface IMetricsService
{
    void Increment(string metricName, double value = 1);
    void RecordTiming(string metricName, TimeSpan duration);
    double GetCurrentValue(string metricName);
}

// 2. Implement the service
public class PrometheusMetricsService : IMetricsService
{
    private readonly ConcurrentDictionary&lt;string, double&gt; _counters = new();

    // Constructor: called exactly once by the DI container
    public PrometheusMetricsService(ILogger&lt;PrometheusMetricsService&gt; logger)
    {
        logger.LogInformation("MetricsService initialized (Singleton scope)");
    }

    public void Increment(string metricName, double value = 1)
        =&gt; _counters.AddOrUpdate(metricName, value, (_, cur) =&gt; cur + value);

    public void RecordTiming(string metricName, TimeSpan duration)
        =&gt; _counters[metricName + "_ms"] = duration.TotalMilliseconds;

    public double GetCurrentValue(string metricName)
        =&gt; _counters.TryGetValue(metricName, out var val) ? val : 0;
}

// 3. Register as Singleton
builder.Services.AddSingleton&lt;IMetricsService, PrometheusMetricsService&gt;();

// 4. Consume via constructor injection
public class OrderController : ControllerBase
{
    private readonly IMetricsService _metrics;

    public OrderController(IMetricsService metrics) =&gt; _metrics = metrics;

    [HttpPost("orders")]
    public async Task&lt;IActionResult&gt; CreateOrder([FromBody] OrderDto dto)
    {
        var sw = Stopwatch.StartNew();
        _metrics.Increment("orders.created");
        // ... order logic
        _metrics.RecordTiming("orders.create_duration", sw.Elapsed);
        return Ok();
    }
}</code></pre></div>
    </div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Approach</th><th>Thread Safety</th><th>Testable</th><th>Lazy</th><th>Interface</th><th>Recommended For</th></tr></thead>
        <tbody>
          <tr><td><span class="badge badge-red">Naive</span></td><td>âŒ Race condition</td><td>âŒ</td><td>âœ…</td><td>âŒ</td><td>Never</td></tr>
          <tr><td><span class="badge badge-yellow">Double-Checked Locking</span></td><td>âœ… With volatile</td><td>âš ï¸ Partial</td><td>âœ…</td><td>âŒ</td><td>Legacy .NET / no DI</td></tr>
          <tr><td><span class="badge badge-blue">Lazy&lt;T&gt;</span></td><td>âœ… BCL-tested</td><td>âš ï¸ Partial</td><td>âœ…</td><td>âŒ</td><td>Console apps / utilities</td></tr>
          <tr><td><span class="badge badge-green">DI Container</span></td><td>âœ… Container-managed</td><td>âœ… Full</td><td>âœ…</td><td>âœ…</td><td>All ASP.NET Core / production</td></tr>
          <tr><td><span class="badge badge-purple">Eager Static</span></td><td>âœ… CLR-guaranteed</td><td>âš ï¸ Partial</td><td>âŒ</td><td>âŒ</td><td>Immutable, always-needed data</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 10 -->
<section id="s10" class="section">
  <div class="section-header">
    <div class="section-icon red"><i class="fa-solid fa-bug"></i></div>
    <div><div class="section-num">Section 10</div><h2 class="section-title">Bug Case Studies</h2></div>
  </div>

  <!-- Bug #1 -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-1" style="color:var(--accent-red)"></i> Bug #1 â€” Captive Dependency (Singleton holding Scoped DbContext)</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: $23,000 in lost transactions</div>
      An e-commerce Singleton OrderProcessor captured a Scoped DbContext at construction time. After the first request completed and the scope was disposed, the captured DbContext became invalid. All subsequent requests failed with ObjectDisposedException. The bug ran undetected for 4 hours during a weekend sale event.
    </div>
    <h3 class="sub">Setup â€” The Captive Dependency Anti-Pattern</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderProcessor.cs â€” BROKEN</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// WRONG: Singleton captures a Scoped service!
// The Scoped DbContext is disposed after the first request.
// All subsequent calls use a disposed context â€” ObjectDisposedException!
public class OrderProcessor  // Singleton lifetime
{
    private readonly ApplicationDbContext _dbContext;  // Scoped lifetime!

    // DI resolves DbContext from the ROOT scope (not request scope)
    // The root-scope DbContext is never disposed â€” it holds a
    // stale connection for the entire app lifetime.
    public OrderProcessor(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task ProcessOrderAsync(Order order)
    {
        // After request 1 completes: DbContext is disposed
        // Request 2 reaches here: ObjectDisposedException!
        _dbContext.Orders.Add(order);
        await _dbContext.SaveChangesAsync();
    }
}</code></pre></div>
    </div>
    <h3 class="sub">Timeline of Failure</h3>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Time</th><th>Event</th><th>State</th></tr></thead>
        <tbody>
          <tr><td>T+0ms</td><td>App starts. DI creates OrderProcessor (Singleton) with DbContext from root scope</td><td>DbContext alive but from wrong scope</td></tr>
          <tr><td>T+1s</td><td>Request 1 arrives. OrderProcessor.ProcessOrderAsync runs successfully</td><td>Works â€” DbContext still alive</td></tr>
          <tr><td>T+2s</td><td>Request 2 arrives. Singleton reuses captured DbContext</td><td>Works â€” DbContext still alive (root scope never disposes)</td></tr>
          <tr><td>T+4h</td><td>DbContext connection pool exhausted. Or: app restarted mid-deployment.</td><td>ObjectDisposedException on all requests</td></tr>
          <tr><td>T+4h+1m</td><td>Alert fires: 500 error rate spikes to 100%</td><td>$23K in failed checkouts</td></tr>
        </tbody>
      </table>
    </div>
    <h3 class="sub">Fix Option 1 â€” Inject IDbContextFactory and create per-operation</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderProcessor.cs â€” FIXED with IDbContextFactory</span></div>
      <div class="macos-body"><pre><code class="language-csharp">public class OrderProcessor  // Singleton
{
    private readonly IDbContextFactory&lt;ApplicationDbContext&gt; _dbFactory;

    // IDbContextFactory is Singleton-safe â€” it creates new contexts on demand
    public OrderProcessor(IDbContextFactory&lt;ApplicationDbContext&gt; dbFactory)
    {
        _dbFactory = dbFactory;
    }

    public async Task ProcessOrderAsync(Order order)
    {
        // Creates a fresh DbContext, uses it, disposes it
        // No shared state â€” each operation gets its own context
        await using var context = await _dbFactory.CreateDbContextAsync();
        context.Orders.Add(order);
        await context.SaveChangesAsync();
    }
}

// Registration
builder.Services.AddDbContextFactory&lt;ApplicationDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString));</code></pre></div>
    </div>
    <h3 class="sub">Fix Option 2 â€” Change OrderProcessor to Scoped</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderProcessor.cs â€” FIXED as Scoped</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// If OrderProcessor doesn't need shared state, make it Scoped
public class OrderProcessor  // Now Scoped
{
    private readonly ApplicationDbContext _dbContext;

    public OrderProcessor(ApplicationDbContext dbContext)
        =&gt; _dbContext = dbContext;  // Now same lifetime â€” safe!

    public async Task ProcessOrderAsync(Order order)
    {
        _dbContext.Orders.Add(order);
        await _dbContext.SaveChangesAsync();
    }
}

// Registration
builder.Services.AddScoped&lt;OrderProcessor&gt;();
// DbContext is also Scoped (default) â€” lifetimes match</code></pre></div>
    </div>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-shield-halved"></i> Automatic Detection: ValidateScopes</div>
      ASP.NET Core has a built-in guard: set <code>ValidateScopes = true</code> in development. This throws an exception at startup if a Singleton captures a Scoped dependency â€” catching the bug before it reaches production.
      <div class="macos-body" style="margin-top:0.75rem;"><pre><code class="language-csharp">// In Program.cs:
builder.Host.UseDefaultServiceProvider(options =&gt;
{
    options.ValidateScopes = builder.Environment.IsDevelopment();
    options.ValidateOnBuild = true; // Also validates on app start
});</code></pre></div>
    </div>
  </div>

  <!-- Bug #2 -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-2" style="color:var(--accent-red)"></i> Bug #2 â€” Double Singleton (Race Condition with 400MB ML Model)</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: $1.2M â€” Production OOM Crash</div>
      An ML inference service loaded a 400MB model in a naive Singleton. On deployment, 50 threads simultaneously hit the Instance property during the first burst of traffic. 50 threads each saw <code>_instance == null</code> and started loading the model. 50 x 400MB = 20GB allocated simultaneously. The pod crashed with OOM. Kubernetes entered CrashLoopBackOff. The service was down for 4 hours.
    </div>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MLModelService.cs â€” BROKEN</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// NOT thread-safe â€” naive singleton with expensive initialization
public class MLModelService
{
    private static MLModelService? _instance;

    private readonly OnnxModel _model;  // 400MB loaded in constructor

    private MLModelService()
    {
        // Loads 400MB ONNX model from disk â€” takes ~3 seconds
        _model = OnnxRuntime.LoadModel("model.onnx");
    }

    // RACE CONDITION: 50 threads can all enter here simultaneously!
    // 50 constructors run = 50 x 400MB = 20GB allocated
    public static MLModelService Instance
    {
        get
        {
            if (_instance == null)              // All 50 threads pass here
                _instance = new MLModelService(); // All 50 load the model!
            return _instance;
        }
    }

    public float[] Predict(float[] input) =&gt; _model.Run(input);
}</code></pre></div>
    </div>
    <h3 class="sub">Fix â€” Lazy&lt;T&gt; + IHostedService Warm-Up</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MLModelService.cs â€” FIXED</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// Thread-safe: Lazy&lt;T&gt; guarantees exactly one initialization
public sealed class MLModelService
{
    private static readonly Lazy&lt;MLModelService&gt; _lazy =
        new(() =&gt; new MLModelService(),
            LazyThreadSafetyMode.ExecutionAndPublication);

    private readonly OnnxModel _model;

    private MLModelService()
    {
        _model = OnnxRuntime.LoadModel("model.onnx");
    }

    public static MLModelService Instance =&gt; _lazy.Value;
    public float[] Predict(float[] input) =&gt; _model.Run(input);
}

// IHostedService warm-up: loads model BEFORE first request arrives
// This avoids the cold-start problem in production
public class MLModelWarmupService : IHostedService
{
    private readonly ILogger&lt;MLModelWarmupService&gt; _logger;

    public MLModelWarmupService(ILogger&lt;MLModelWarmupService&gt; logger)
        =&gt; _logger = logger;

    public Task StartAsync(CancellationToken ct)
    {
        _logger.LogInformation("Pre-loading ML model...");
        // Access Instance before any HTTP requests arrive
        // Forces initialization on the startup thread â€” no race possible
        _ = MLModelService.Instance;
        _logger.LogInformation("ML model ready.");
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken ct) =&gt; Task.CompletedTask;
}

// Register warm-up service
builder.Services.AddHostedService&lt;MLModelWarmupService&gt;();</code></pre></div>
    </div>
  </div>

  <!-- Bug #3 -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-3" style="color:var(--accent-red)"></i> Bug #3 â€” Immortal Cache (ConcurrentDictionary Memory Leak)</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: Cascading Production Failure</div>
      A Singleton cache using ConcurrentDictionary with string keys grew unboundedly over 3 months. The keys were user-specific URLs containing GUIDs â€” millions of unique keys. At 4.8GB heap, GC pauses hit 400ms. Response times spiked. Load balancer health checks timed out. Pods were terminated and restarted. During restart, traffic shifted to remaining pods â€” which also had 4.8GB heaps. All pods failed within minutes.
    </div>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ProductCacheService.cs â€” BROKEN</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// Singleton cache with no eviction â€” grows forever!
public sealed class ProductCacheService
{
    private static readonly Lazy&lt;ProductCacheService&gt; _lazy =
        new(() =&gt; new ProductCacheService());

    // ConcurrentDictionary has NO maximum size, NO expiration
    // Every unique key added stays FOREVER
    private readonly ConcurrentDictionary&lt;string, Product&gt; _cache = new();

    private ProductCacheService() { }

    public static ProductCacheService Instance =&gt; _lazy.Value;

    public Product GetOrAdd(string cacheKey, Func&lt;Product&gt; factory)
    {
        // Each unique URL/key is permanently stored
        // After 3 months: millions of entries, 4.8GB
        return _cache.GetOrAdd(cacheKey, _ =&gt; factory());
    }
}</code></pre></div>
    </div>
    <h3 class="sub">Fix â€” IMemoryCache with SizeLimit and Expiration</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ProductCacheService.cs â€” FIXED</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// Fix: Use IMemoryCache with bounded size and sliding expiration
public class ProductCacheService : IProductCacheService
{
    private readonly IMemoryCache _cache;
    private readonly ILogger&lt;ProductCacheService&gt; _logger;

    public ProductCacheService(
        IMemoryCache cache,
        ILogger&lt;ProductCacheService&gt; logger)
    {
        _cache = cache;
        _logger = logger;
    }

    public async Task&lt;Product?&gt; GetOrAddAsync(
        string cacheKey,
        Func&lt;Task&lt;Product?&gt;&gt; factory,
        int cacheSizeUnits = 1)
    {
        if (_cache.TryGetValue(cacheKey, out Product? cached))
            return cached;

        var product = await factory();

        if (product is not null)
        {
            var options = new MemoryCacheEntryOptions
            {
                // Sliding expiration: entry expires if not accessed
                SlidingExpiration = TimeSpan.FromMinutes(15),
                // Absolute expiration: entry ALWAYS expires after this
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1),
                // Size: counted against SizeLimit
                Size = cacheSizeUnits,
                // Low-priority entries evicted first when under pressure
                Priority = CacheItemPriority.Low
            };

            _cache.Set(cacheKey, product, options);
            _logger.LogDebug("Cache SET: {Key}", cacheKey);
        }

        return product;
    }
}

// Registration with SizeLimit
builder.Services.AddMemoryCache(options =&gt;
{
    // Maximum 10,000 size units in the cache
    // Each entry is 1 unit by default â€” max 10,000 entries
    options.SizeLimit = 10_000;
    // Check for expired items every 5 minutes
    options.ExpirationScanFrequency = TimeSpan.FromMinutes(5);
});

builder.Services.AddSingleton&lt;IProductCacheService, ProductCacheService&gt;();</code></pre></div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 12 -->
<section id="s12" class="section">
  <div class="section-header">
    <div class="section-icon cyan"><i class="fa-solid fa-cubes"></i></div>
    <div><div class="section-num">Section 12</div><h2 class="section-title">SOLID Principles Mapping</h2></div>
  </div>

  <!-- S -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-s" style="color:var(--accent-blue)"></i> S â€” Single Responsibility Principle</div>
    <p class="body-text">A God Singleton does everything: logging, config, caching, metrics. The SRP says each class should have one reason to change. A God Singleton has as many reasons to change as it has responsibilities.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> BEFORE â€” God Singleton (SRP Violation)</div>
        <div class="macos-body"><pre><code class="language-csharp">// One class does everything â€” changes for logging,
// caching, config, AND metrics reasons
public sealed class AppServices
{
    private static readonly Lazy&lt;AppServices&gt; _lazy =
        new(() =&gt; new AppServices());
    public static AppServices Instance =&gt; _lazy.Value;

    // Logging
    public void Log(string msg) =&gt; Console.WriteLine(msg);

    // Config
    public string GetSetting(string key) =&gt; config[key];

    // Cache
    private Dictionary&lt;string, object&gt; _cache = new();
    public object? Get(string key) =&gt;
        _cache.TryGetValue(key, out var v) ? v : null;

    // Metrics
    public void RecordMetric(string name, double value) { }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> AFTER â€” Separate Singletons (SRP Enforced)</div>
        <div class="macos-body"><pre><code class="language-csharp">// Each service has one responsibility
// Registered as separate Singleton services

// Logging: changes when log format/sink changes
builder.Services.AddSingleton&lt;ILogService, SerilogService&gt;();

// Config: changes when config source changes
builder.Services.AddSingleton&lt;IConfigService, ConfigService&gt;();

// Cache: changes when cache strategy changes
builder.Services.AddSingleton&lt;ICacheService, MemoryCacheService&gt;();

// Metrics: changes when metrics provider changes
builder.Services.AddSingleton&lt;IMetricsService, PrometheusService&gt;();

// Each service is independently testable, replaceable,
// and deployable without touching the others</code></pre></div>
      </div>
    </div>
  </div>

  <!-- O -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-o" style="color:var(--accent-purple)"></i> O â€” Open/Closed Principle</div>
    <p class="body-text">A concrete static Singleton is sealed against extension. You cannot add new behaviors without modifying the class. With DI and interfaces, you extend behavior by adding new implementations â€” not by modifying existing code.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> BEFORE â€” Static, Closed to Extension</div>
        <div class="macos-body"><pre><code class="language-csharp">// Adding Azure Blob support requires modifying this class!
public sealed class StorageService
{
    public void Save(string path, byte[] data)
    {
        // Hardcoded to local disk
        File.WriteAllBytes(path, data);
        // To add S3: must modify this method
        // To add Azure: must modify this method
        // Every change risks breaking existing behavior
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> AFTER â€” Open via Interface Swap</div>
        <div class="macos-body"><pre><code class="language-csharp">public interface IStorageService
{
    Task SaveAsync(string path, byte[] data);
}

// Existing implementation â€” never modified
public class LocalStorageService : IStorageService
{
    public Task SaveAsync(string path, byte[] data)
        =&gt; File.WriteAllBytesAsync(path, data);
}

// New behavior: just add a new class
public class S3StorageService : IStorageService
{
    private readonly IAmazonS3 _s3;
    public S3StorageService(IAmazonS3 s3) =&gt; _s3 = s3;
    public async Task SaveAsync(string path, byte[] data)
        =&gt; await _s3.PutObjectAsync(...);
}

// Swap without touching callers
builder.Services.AddSingleton&lt;IStorageService, S3StorageService&gt;();</code></pre></div>
      </div>
    </div>
  </div>

  <!-- L -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-l" style="color:var(--accent-green)"></i> L â€” Liskov Substitution Principle</div>
    <p class="body-text">Static Singleton access (<code>MySingleton.Instance</code>) cannot be substituted in tests. Interface-based Singleton injection can be substituted with any implementation that satisfies the contract.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> BEFORE â€” Static Access, Not Substitutable</div>
        <div class="macos-body"><pre><code class="language-csharp">public class ReportService
{
    public Report Generate()
    {
        // Static call â€” impossible to substitute in tests!
        var config = ConfigSingleton.Instance;
        var reportPath = config.Get("Reports:OutputPath");
        // Tests are forced to use the real config file
        return new Report(reportPath);
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> AFTER â€” Interface Injection, Substitutable</div>
        <div class="macos-body"><pre><code class="language-csharp">public class ReportService
{
    private readonly IConfigService _config;
    public ReportService(IConfigService config) =&gt; _config = config;

    public Report Generate()
    {
        var reportPath = _config.Get("Reports:OutputPath");
        return new Report(reportPath);
    }
}

// Test: substitute a mock that satisfies IConfigService
[Fact]
public void Generate_UsesConfiguredPath()
{
    var mockConfig = new Mock&lt;IConfigService&gt;();
    mockConfig.Setup(c =&gt; c.Get("Reports:OutputPath"))
              .Returns("/test/reports");

    var service = new ReportService(mockConfig.Object);
    var report = service.Generate();

    Assert.Equal("/test/reports", report.Path);
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- I -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-i" style="color:var(--accent-yellow)"></i> I â€” Interface Segregation Principle</div>
    <p class="body-text">A fat Singleton interface forces callers to depend on methods they don't use. Segregated interfaces let each caller depend only on what it needs.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> BEFORE â€” Fat Interface</div>
        <div class="macos-body"><pre><code class="language-csharp">// One interface with everything â€” callers depend on all of it
public interface IApplicationService
{
    string GetConfig(string key);
    void Log(string message, LogLevel level);
    void CacheSet(string key, object value);
    object? CacheGet(string key);
    void RecordMetric(string name, double val);
    string GetFeatureFlag(string flag);
}

// OrderService only needs config, but depends on the entire interface
public class OrderService
{
    private readonly IApplicationService _app;
    // If RecordMetric signature changes, OrderService recompiles
    // even though it never calls RecordMetric!
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> AFTER â€” Segregated Interfaces</div>
        <div class="macos-body"><pre><code class="language-csharp">// Focused interfaces â€” each caller takes only what it needs
public interface IConfigService { string Get(string key); }
public interface ILogService { void Log(string msg, LogLevel l); }
public interface ICacheService
{
    void Set(string key, object value);
    object? Get(string key);
}
public interface IMetricsService { void Record(string name, double val); }

// OrderService only depends on what it actually uses
public class OrderService
{
    private readonly IConfigService _config;
    private readonly ILogService _logger;

    public OrderService(IConfigService config, ILogService logger)
    {
        _config = config;
        _logger = logger;
    }
    // Changes to IMetricsService never affect OrderService
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- D -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-d" style="color:var(--accent-red)"></i> D â€” Dependency Inversion Principle</div>
    <p class="body-text">High-level modules should not depend on low-level modules. Both should depend on abstractions. Directly accessing a Singleton's static <code>Instance</code> property violates DIP â€” the caller is coupled to the concrete Singleton.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> BEFORE â€” Concrete Dependency (DIP Violation)</div>
        <div class="macos-body"><pre><code class="language-csharp">// High-level OrderService directly depends on
// low-level CacheSingleton concrete class
public class OrderService
{
    public Order? GetOrder(int id)
    {
        // Directly coupled to concrete Singleton
        var cached = CacheSingleton.Instance.Get($"order:{id}");
        if (cached is Order order) return order;

        // If CacheSingleton changes, OrderService breaks
        // Cannot test without real CacheSingleton
        return null;
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> AFTER â€” Abstraction + DI (DIP Enforced)</div>
        <div class="macos-body"><pre><code class="language-csharp">// High-level OrderService depends on abstraction ICacheService
public class OrderService
{
    private readonly ICacheService _cache;  // Abstraction

    public OrderService(ICacheService cache) =&gt; _cache = cache;

    public Order? GetOrder(int id)
    {
        // Depends on interface â€” not on implementation details
        var cached = _cache.Get($"order:{id}");
        return cached as Order;
    }
}

// DI wires concrete Singleton to abstraction
// OrderService never knows it IS a Singleton
builder.Services.AddSingleton&lt;ICacheService, RedisCacheService&gt;();

// In tests, use in-memory implementation
services.AddSingleton&lt;ICacheService, InMemoryCacheService&gt;();</code></pre></div>
      </div>
    </div>
  </div>

  <!-- Summary Table -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-table" style="color:var(--accent-cyan)"></i> Hand-Rolled vs DI-Managed â€” SOLID Summary</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Principle</th><th>Hand-Rolled Singleton</th><th>DI-Managed Singleton</th></tr></thead>
        <tbody>
          <tr><td><strong>S</strong> â€” Single Responsibility</td><td>âš ï¸ Easy to become a God class</td><td>âœ… Each service has one responsibility</td></tr>
          <tr><td><strong>O</strong> â€” Open/Closed</td><td>âŒ Sealed â€” must modify to add behaviors</td><td>âœ… Swap implementations via DI registration</td></tr>
          <tr><td><strong>L</strong> â€” Liskov Substitution</td><td>âŒ Static access â€” not substitutable in tests</td><td>âœ… Any implementation satisfying interface can substitute</td></tr>
          <tr><td><strong>I</strong> â€” Interface Segregation</td><td>âŒ Often one class implements everything</td><td>âœ… Each interface is focused; callers take only what they need</td></tr>
          <tr><td><strong>D</strong> â€” Dependency Inversion</td><td>âŒ Callers depend on concrete Singleton class</td><td>âœ… Callers depend on abstraction; DI injects concrete</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 13 -->
<section id="s13" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-scale-balanced"></i></div>
    <div><div class="section-num">Section 13</div><h2 class="section-title">Pattern Comparisons</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-table" style="color:var(--accent-blue)"></i> Singleton vs Alternatives â€” Full Comparison</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Aspect</th><th>Singleton</th><th>Static Class</th><th>Monostate</th><th>Service Locator</th><th>DI Container</th></tr></thead>
        <tbody>
          <tr><td><strong>Instance count</strong></td><td>1</td><td>0 (no instances)</td><td>Many instances, shared state</td><td>1 registry</td><td>1 per registration</td></tr>
          <tr><td><strong>Instantiation</strong></td><td>Lazy or Eager</td><td>Static initializer</td><td><code>new Monostate()</code></td><td>Locator.Get&lt;T&gt;()</td><td>Constructor injection</td></tr>
          <tr><td><strong>Inheritance</strong></td><td>âŒ Difficult</td><td>âŒ Not possible</td><td>âœ… Normal inheritance</td><td>âœ… Via abstraction</td><td>âœ… Via interface</td></tr>
          <tr><td><strong>Testability</strong></td><td>âš ï¸ Hard (static)</td><td>âŒ Very hard</td><td>âš ï¸ Hard (shared state)</td><td>âŒ Hidden deps</td><td>âœ… Excellent</td></tr>
          <tr><td><strong>Lazy init</strong></td><td>âœ… Supported</td><td>âš ï¸ Static ctor</td><td>âœ… Supported</td><td>âš ï¸ Depends</td><td>âœ… First resolve</td></tr>
          <tr><td><strong>Thread safety</strong></td><td>Manual / Lazy&lt;T&gt;</td><td>Manual</td><td>Manual (shared state!)</td><td>Manual</td><td>Container-managed</td></tr>
          <tr><td><strong>Serializable</strong></td><td>âš ï¸ Complex</td><td>âŒ</td><td>âœ… Yes</td><td>N/A</td><td>âœ… Yes</td></tr>
          <tr><td><strong>DI-friendly</strong></td><td>âš ï¸ Partial</td><td>âŒ</td><td>âš ï¸ Partial</td><td>âŒ Anti-pattern</td><td>âœ… Native</td></tr>
          <tr><td><strong>Use case</strong></td><td>Shared mutable state</td><td>Pure stateless utils</td><td>Rare: polymorphic singleton</td><td>Avoid in new code</td><td>All modern apps</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-code-branch" style="color:var(--accent-purple)"></i> Decision Tree â€” Which Pattern to Use?</div>
    <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
      <div class="mermaid">
flowchart TD
    A{Need a single shared instance?} -->|NO| B[Use Scoped or Transient]
    A -->|YES| C{Holds mutable state?}
    C -->|NO| D{Purely stateless utility?}
    D -->|YES| E["âœ… Use static class\n(Math.Max, Path.Combine)"]
    D -->|NO| F["âœ… Use Singleton via DI\n(safer, testable)"]
    C -->|YES| G{In ASP.NET Core / Generic Host?}
    G -->|YES| H["AddSingleton via DI\nManages lifetime, disposal"]
    G -->|NO| I["Lazy of T with\nExecutionAndPublication"]

    style A fill:#1e293b,stroke:#3b82f6,color:#f1f5f9
    style B fill:#334155,stroke:#ef4444,color:#f1f5f9
    style C fill:#1e293b,stroke:#8b5cf6,color:#f1f5f9
    style D fill:#1e293b,stroke:#f59e0b,color:#f1f5f9
    style E fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style F fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style G fill:#1e293b,stroke:#06b6d4,color:#f1f5f9
    style H fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style I fill:#064e3b,stroke:#10b981,color:#f1f5f9
      </div>
    </div>
    <div style="margin-top:1rem;padding:1rem;background:rgba(59,130,246,0.1);border-left:3px solid var(--accent-blue);border-radius:0 8px 8px 0;">
      <p style="font-size:0.9375rem;color:var(--accent-blue);font-weight:600;margin-bottom:0.25rem;"><i class="fa-solid fa-graduation-cap"></i> Senior Decision Rule</p>
      <p style="font-size:1rem;">Prefer DI Singleton over hand-rolled Singleton. Prefer Scoped over Singleton when in doubt. Use static class ONLY for pure functions with no state.</p>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-person-chalkboard" style="color:var(--accent-green)"></i> Singleton vs Static Class â€” When to Use Which</div>
    <div class="grid-2">
      <div>
        <h3 class="sub" style="color:var(--accent-blue);">Use Singleton When</h3>
        <ul class="styled">
          <li>You need to hold <strong>mutable state</strong> (counters, connections, cache entries)</li>
          <li>You need to implement an <strong>interface</strong> for testability</li>
          <li>You need <strong>lazy initialization</strong> (expensive resource, load on first use)</li>
          <li>You need to be <strong>injected via DI</strong> into constructors</li>
          <li>The service needs <strong>dependencies injected</strong> into it (ILogger, IConfiguration)</li>
          <li>You need <strong>polymorphism</strong> â€” ability to swap implementations</li>
          <li>The class might need to be <strong>mocked in tests</strong></li>
        </ul>
      </div>
      <div>
        <h3 class="sub" style="color:var(--accent-green);">Use Static Class When</h3>
        <ul class="styled green">
          <li>The class is <strong>purely stateless</strong> â€” pure functions only (Math, StringUtils)</li>
          <li>You never need to inject it â€” callers call it <strong>directly</strong></li>
          <li>No interface needed â€” callers depend on concrete implementation</li>
          <li>Performance is critical â€” static calls are <strong>slightly faster</strong> (no vtable lookup)</li>
          <li>The utility methods are <strong>trivially testable</strong> by calling them directly</li>
          <li>The class will <strong>never have mutable state</strong> â€” guaranteed by design</li>
        </ul>
      </div>
    </div>
    <div class="callout callout-warning">
      <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> The Monostate Anti-Pattern</div>
      Monostate uses multiple instances that all share the same static state. It appears like regular classes (you use <code>new Monostate()</code>) but behaves like a Singleton. It combines the worst of both worlds: the complexity of instance management WITH shared global state. Avoid it â€” use a proper Singleton via DI instead.
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 14 -->
<section id="s14" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-comments"></i></div>
    <div><div class="section-num">Section 14</div><h2 class="section-title">Interview Q&amp;As â€” All 25 Questions</h2></div>
  </div>

  <div class="callout callout-info">
    <div class="callout-title"><i class="fa-solid fa-circle-info"></i> How to Use This Section</div>
    Click any question to expand it. Each Q&amp;A includes: the question, how to think about it (framing), a full answer with code where applicable, and "what separates good from great answers." Questions are grouped by interview category.
  </div>

  <!-- Category 1: Conceptual -->
  <h3 class="sub"><i class="fa-solid fa-brain" style="color:var(--accent-blue)"></i> Category 1 â€” Conceptual (Q1â€“Q5)</h3>

  <div class="qa-item active" id="qa1">
    <div class="qa-header">
      <div><div class="qa-question">Q1. What is the Singleton pattern and when should you use it? <span class="badge badge-blue">Conceptual</span></div><div class="qa-meta">Follow-up: What are the two problems it solves?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Don't just memorize the textbook definition. Instead, tell a story: "Here's the problem I faced, and here's how Singleton solved it." Ask yourself: what goes wrong if you create TWO of this thing? Walk through that problem first, then explain how Singleton fixes it. Think about it like this â€” imagine you have a school where students are constantly asking "who is the principal?" If you could create multiple principals, the school would be chaos. Singleton is the rule that says: there can only be ONE principal, and everyone who asks gets the same person.</div>
      <p class="body-text"><strong>Answer:</strong> The Singleton pattern makes sure only ONE object of a class ever exists in your entire application â€” like having only one principal in a school. No matter who asks for it, they all get the same one. It solves two problems at once: (1) it stops your code from accidentally creating duplicate objects â€” because some objects MUST be unique, and (2) it makes that single object easy to reach from anywhere in your code, without having to pass it through every method call like a baton in a relay race.</p>
      <p class="body-text"><strong>When to use it:</strong> Use Singleton when having TWO copies of something would cause problems. For example: a connection pool (a collection of open database connections shared by everyone) â€” if you had two pools, one would be empty while the other is overloaded. An in-memory cache â€” if you had two caches, updating one wouldn't update the other, so different parts of your app see different data. A logger, a circuit breaker, a feature flag reader. The test is simple: "would two separate instances of this class cause bugs?"</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Singleton.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// The minimal modern Singleton in C#
public sealed class ApplicationCache
{
    private static readonly Lazy&lt;ApplicationCache&gt; _lazy =
        new(() =&gt; new ApplicationCache());

    private readonly ConcurrentDictionary&lt;string, object&gt; _store = new();

    private ApplicationCache() { }

    public static ApplicationCache Instance =&gt; _lazy.Value;

    public void Set(string key, object value) =&gt; _store[key] = value;
    public bool TryGet(string key, out object? value)
        =&gt; _store.TryGetValue(key, out value);
}

// In production: prefer DI over direct static access
builder.Services.AddSingleton&lt;IApplicationCache, ApplicationCache&gt;();</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer points out there are actually TWO kinds of Singleton. The first is the "hand-rolled Singleton" â€” a class that controls its own creation with a static property like <code>Instance</code>. The second is the "DI Singleton" â€” where you just tell the framework (<code>AddSingleton</code>) "create this class once and reuse it forever." They're different tools for different problems. The hand-rolled version is a structural decision (the class itself enforces one-instance-only). The DI version is a lifetime decision â€” meaning: the framework decides when to create the object and how long to keep it alive, not the class itself. Great candidates also mention: Singletons can be controversial because they create global shared state â€” and shared state means any bug in one part of your app can affect every other part. That makes code harder to understand and test.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa2">
    <div class="qa-header">
      <div><div class="qa-question">Q2. Explain the four approaches to thread-safe Singleton in C# and their tradeoffs. <span class="badge badge-blue">Conceptual</span></div><div class="qa-meta">Follow-up: Which would you use in production and why?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Walk through this as a journey from "broken but obvious" to "correct and production-ready." Think of it like building a better lock for a bathroom â€” first attempt has no lock at all (disaster), second attempt always locks even when no one is in (slow), third attempt only locks when someone might be entering (smart). Your job is to explain each step and why it's an improvement over the previous one.</div>
      <p class="body-text"><strong>Answer:</strong></p>
      <p class="body-text"><strong>1. Naive (broken):</strong> No protection at all. Imagine two people simultaneously checking if a bathroom is empty â€” both see "empty" at the exact same moment and both walk in. In code, two threads can both check <code>_instance == null</code> at the same time and both create a new instance â€” so you end up with two Singletons. This defeats the whole point.</p>
      <p class="body-text"><strong>2. Lock-Every-Read (safe but slow):</strong> Put a <code>lock</code> around the entire getter. A <strong>lock</strong> â€” like a key to a room â€” means only one thread can enter at a time. This is safe, but every single read (even after the object is already created) has to wait for the lock. Under heavy traffic, all threads queue up at the door, one by one. Correct, but slow.</p>
      <p class="body-text"><strong>3. Double-Checked Locking (fast, but needs volatile):</strong> Check if the object exists BEFORE locking. If it already exists, skip the lock entirely. Only lock when creating for the first time. This is fast, but there's a subtle trap: CPUs and compilers can reorder instructions for speed. Without marking the field as <code>volatile</code> â€” which means "always read this fresh from memory, never from CPU cache" â€” one thread might see the variable as non-null before the constructor has actually finished running. Modern CPUs and compilers sometimes rearrange the order your code runs in â€” as an optimization. This is normally invisible, but in multi-threaded code it can cause one thread to see a variable in an incomplete state. This is a hardware-level timing issue, not a code bug. The <code>volatile</code> keyword adds a <strong>memory barrier</strong> â€” a guarantee that all writes before it are visible to all threads after it.</p>
      <p class="body-text"><strong>4. Lazy&lt;T&gt; with ExecutionAndPublication (recommended for hand-rolled):</strong> <strong><code>Lazy&lt;T&gt;</code></strong> is a built-in C# type that does "create this object only when first needed, and do it safely." Think of it as a sealed envelope â€” the letter inside is only written when you first open it, and if two people try to open it at once, only one writes the letter and the other waits. The <code>ExecutionAndPublication</code> mode means: only ONE thread creates the object, all others wait. Simpler, battle-tested, no need to worry about volatile.</p>
      <p class="body-text"><strong>5. DI Container (production standard):</strong> Let the framework handle it. When you call <code>AddSingleton</code>, ASP.NET Core creates the object once and gives everyone the same one. Thread-safe, testable, and you can swap implementations without touching any other code.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> Great candidates can name the exact failure mode: it is called the 'partially constructed object' bug â€” one thread sees the reference as non-null but the object's fields haven't been assigned yet. This is distinct from a race condition creating two instances. Most developers just copy-paste double-checked locking without understanding why <code>volatile</code> is there. Knowing this shows real depth.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa3">
    <div class="qa-header">
      <div><div class="qa-question">Q3. "Singleton is an anti-pattern" â€” agree or disagree? Defend your position. <span class="badge badge-blue">Conceptual</span></div><div class="qa-meta">Follow-up: When is it definitely an anti-pattern?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Don't take a hard yes-or-no stance. The honest answer is: "It depends on HOW you use it." This kind of nuanced answer impresses interviewers far more than a one-sided opinion. Think of it like a kitchen knife â€” a knife is not an anti-pattern. But using a kitchen knife as a screwdriver is. The same pattern can be used well or badly.</div>
      <p class="body-text"><strong>Answer â€” It Depends on Implementation:</strong></p>
      <p class="body-text"><strong>When Singleton IS an anti-pattern:</strong> (1) Hand-rolled static access via <code>MySingleton.Instance</code> â€” this is like hardcoding a phone number instead of looking it up. You can never swap it out for a fake version in tests, the dependency is hidden inside the class, and it creates global shared state that any code can mess with. (2) God Singleton â€” one class that does everything (logging, config, cache, metrics) â€” this violates the Single Responsibility Principle: every class should have ONE job. (3) Singleton holding a shorter-lived dependency â€” a Singleton holding a database connection that was meant to be created fresh per request. This is like a permanent employee borrowing a visitor badge indefinitely. (4) An unbounded cache â€” a Singleton that stores data forever with no cleanup, eventually eating all available memory.</p>
      <p class="body-text"><strong>When Singleton is NOT an anti-pattern:</strong> (1) Registered through the DI framework with an interface â€” <code>AddSingleton&lt;ICache, MemoryCache&gt;()</code>. You can replace it with a fake in tests, inject it normally, and swap implementations without touching anything else. Fully testable and clean. (2) Immutable configuration registered once at startup â€” if nothing changes it after creation, there are no threading problems or shared-state bugs. (3) Thread-safe, bounded shared resources â€” like a connection pool with a fixed size, or a circuit breaker that tracks failure counts globally.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> Making the distinction between two different things that both use the word "Singleton": the structural pattern (the class itself controls how many instances exist) vs lifetime management (the framework decides to create this once and reuse it). When you use <code>AddSingleton</code> in ASP.NET Core, the CLASS doesn't need to do anything special â€” the framework just creates it once and hands out the same object every time someone asks. That means you can have a Singleton-lifetime service that is fully testable, has an interface, and can be swapped out in tests â€” none of the traditional "anti-pattern" problems apply. That insight is what separates someone who just memorized the pattern from someone who really understands it.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa4">
    <div class="qa-header">
      <div><div class="qa-question">Q4. Explain the three LazyThreadSafetyMode values and when to use each. <span class="badge badge-blue">Conceptual</span></div><div class="qa-meta">Follow-up: What happens if the factory throws?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Think of <code>Lazy&lt;T&gt;</code> as a "create on demand" wrapper. The three modes answer the question: "what happens if two threads try to create the object at the same time?" Each mode makes a different choice about safety vs speed. Then explain what happens when the creation fails â€” most candidates skip this, but it reveals real production awareness.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LazyModes.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Mode 1: ExecutionAndPublication (default, recommended for Singleton)
// - Only ONE thread executes the factory
// - Other threads block until initialization completes
// - If factory throws: exception is CACHED, re-thrown on every access
// - Use for: Singletons, expensive initialization, correctness required
var singleton = new Lazy&lt;HeavyService&gt;(
    () =&gt; new HeavyService(),
    LazyThreadSafetyMode.ExecutionAndPublication);

// Mode 2: PublicationOnly
// - MULTIPLE threads may execute the factory concurrently
// - Only the FIRST result is published; others are discarded
// - If factory throws: exception is NOT cached; next thread retries
// - Use for: cheap factory, idempotent init, no blocking wanted
var concurrent = new Lazy&lt;LightService&gt;(
    () =&gt; new LightService(),
    LazyThreadSafetyMode.PublicationOnly);

// Mode 3: None (no thread safety)
// - Factory runs once with NO synchronization
// - Use ONLY in single-threaded contexts (unit tests, etc.)
// - Fastest, but race condition possible in multi-threaded scenarios
var singleThread = new Lazy&lt;Service&gt;(
    () =&gt; new Service(),
    LazyThreadSafetyMode.None);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> The sneaky difference that trips everyone up â€” what happens when the creation fails (throws an exception). With <code>ExecutionAndPublication</code>: the exception is remembered ("cached") forever. Every future attempt to access <code>.Value</code> throws the same exception again. The factory code never runs again. If it failed once, it's failed forever â€” until you restart the app. With <code>PublicationOnly</code>: the exception is NOT remembered. The next thread that tries will run the factory fresh. This matters when your failure is temporary â€” like trying to connect to a database that was momentarily unavailable. With <code>ExecutionAndPublication</code>, one bad connection attempt at startup permanently breaks the app. With <code>PublicationOnly</code>, the next request gets another chance to connect.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa5">
    <div class="qa-header">
      <div><div class="qa-question">Q5. How does ASP.NET Core's DI container implement AddSingleton internally? <span class="badge badge-blue">Conceptual</span></div><div class="qa-meta">Follow-up: What is the root scope and why does it matter?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> This question tests whether you know what happens behind the scenes when you call <code>AddSingleton</code>. Think of the DI container as a registry â€” like a hotel reception desk. When you register a Singleton, you're telling the desk: "if anyone asks for Room 42, give them the key to the same room every time." Then explain why the "root scope" (the master reception desk that never closes) causes a nasty bug when Singletons borrow short-lived objects.</div>
      <p class="body-text"><strong>Answer:</strong> When you call <code>builder.Services.AddSingleton&lt;IService, Service&gt;()</code>, the DI framework writes down a note called a <strong><code>ServiceDescriptor</code></strong> â€” basically a recipe card that says: "to make an <code>IService</code>, create a <code>Service</code> object, and the lifetime is Singleton." When the app builds (via <code>builder.Build()</code>), the framework creates the master container â€” the <strong><code>ServiceProvider</code></strong> â€” available as <code>app.Services</code>. Think of it as the hotel's root reception desk that runs for the entire life of the application.</p>
      <p class="body-text">The root <code>ServiceProvider</code> keeps a lookup table: "service type â†’ the one object we created." The first time someone asks for the Singleton, the container creates it, stores it in this table, and from then on returns the same stored object to everyone who asks â€” no matter where in the app they're asking from.</p>
      <p class="body-text">Each HTTP request creates a temporary child container called an <strong><code>IServiceScope</code></strong> â€” like a temporary guest desk for that one request. Services registered as "Scoped" (meaning "one per request") are stored in this temporary desk and cleaned up when the request ends. Singleton services are NEVER stored in the temporary desk â€” they always come from the master root desk, which never closes.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> Understanding the "captive dependency" bug that comes from this design. Imagine a Singleton service needs a database connection (which should be created fresh per request â€” a Scoped service). When the DI container creates the Singleton for the first time, it looks up the database connection from the ROOT desk â€” not the request desk. That database connection is then held by the Singleton permanently, never cleaned up, potentially holding an open transaction for the entire lifetime of the app. This is called a captive dependency â€” the long-lived Singleton has "captured" a short-lived dependency and is keeping it alive far longer than intended. The setting <code>ValidateScopes = true</code> makes ASP.NET Core check for this mistake at startup and throw an error immediately, instead of letting the bug quietly corrupt data in production.</div>
    </div></div>
  </div>

  <!-- Category 2: Design Challenges -->
  <h3 class="sub"><i class="fa-solid fa-pencil-ruler" style="color:var(--accent-purple)"></i> Category 2 â€” Design Challenges (Q6â€“Q10)</h3>

  <div class="qa-item" id="qa6">
    <div class="qa-header">
      <div><div class="qa-question">Q6. Design a thread-safe Feature Flag service as a Singleton. It must support real-time flag updates without restart. <span class="badge badge-purple">Design</span></div><div class="qa-meta">Follow-up: How do you handle a flag that changes mid-request?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A feature flag is basically a global on/off switch for parts of your app â€” like "is the dark mode feature enabled?" You need to design a service that: (1) can be read by thousands of simultaneous requests without slowing down, (2) periodically checks a remote source for updated flag values without stopping the whole app, and (3) is consistent during a single request â€” a flag shouldn't flip from ON to OFF in the middle of handling one user's request. Think through each problem in order: reading speed â†’ refresh mechanism â†’ per-request consistency.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FeatureFlagService.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public sealed class FeatureFlagService : IHostedService, IDisposable
{
    // Immutable snapshot â€” replaced atomically via Interlocked
    private volatile IReadOnlyDictionary&lt;string, bool&gt; _flags
        = new Dictionary&lt;string, bool&gt;();

    private readonly IFlagProvider _provider;
    private readonly ILogger&lt;FeatureFlagService&gt; _logger;
    private Timer? _refreshTimer;

    public FeatureFlagService(
        IFlagProvider provider,
        ILogger&lt;FeatureFlagService&gt; logger)
    {
        _provider = provider;
        _logger = logger;
    }

    // Thread-safe read â€” no lock needed (volatile reference swap)
    public bool IsEnabled(string flagName)
        =&gt; _flags.TryGetValue(flagName, out var val) &amp;&amp; val;

    public Task StartAsync(CancellationToken ct)
    {
        // Initial load
        _ = RefreshAsync();
        // Poll every 30 seconds
        _refreshTimer = new Timer(_ =&gt; _ = RefreshAsync(),
            null, TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
        return Task.CompletedTask;
    }

    private async Task RefreshAsync()
    {
        try
        {
            var newFlags = await _provider.GetAllFlagsAsync();
            // Atomic reference swap â€” readers always see a complete snapshot
            Volatile.Write(ref _flags, newFlags);
            _logger.LogDebug("Feature flags refreshed: {Count}", newFlags.Count);
        }
        catch (Exception ex)
        {
            // Keep serving old flags â€” don't crash on refresh failure
            _logger.LogWarning(ex, "Feature flag refresh failed. Serving cached flags.");
        }
    }

    public Task StopAsync(CancellationToken ct) { _refreshTimer?.Change(Timeout.Infinite, 0); return Task.CompletedTask; }
    public void Dispose() =&gt; _refreshTimer?.Dispose();
}

builder.Services.AddSingleton&lt;FeatureFlagService&gt;();
builder.Services.AddHostedService(p =&gt; p.GetRequiredService&lt;FeatureFlagService&gt;());</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> The clever trick in this design is replacing the entire dictionary at once instead of updating it entry by entry. Think of it like swapping out a whole menu board at a restaurant rather than changing individual items while customers are reading it. If you changed items one by one, a customer might see "Burger: $5" and then glance up a moment later and see "Burger: $8" â€” a confusing mix of old and new. By swapping the entire board atomically (all at once, instantly), every reader either sees the old complete menu or the new complete menu â€” never a half-updated mess. This is what <code>Volatile.Write</code> does â€” it swaps the reference to the whole dictionary in one safe operation. For mid-request consistency: at the start of each request, grab the current dictionary into a local variable and use that same variable throughout the whole request. This way, flags can't change mid-request.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa7">
    <div class="qa-header">
      <div><div class="qa-question">Q7. Design a Singleton-based rate limiter that allows N requests per second per API key. <span class="badge badge-purple">Design</span></div><div class="qa-meta">Follow-up: What happens when you add a second app instance (scale-out)?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A rate limiter is like a bouncer at a club â€” it tracks how many people came in recently and stops letting more in if the limit is hit. A Singleton is the right choice because the counter must be shared across ALL requests (if each request had its own counter starting at zero, the limit would never be reached). Design the single-process version first, then proactively mention the follow-up trap: what happens when your app runs on multiple servers?</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RateLimiterService.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public sealed class InProcessRateLimiter : IRateLimiter
{
    // Token bucket per API key
    private readonly ConcurrentDictionary&lt;string, SlidingWindowCounter&gt; _counters = new();
    private readonly int _requestsPerSecond;

    public InProcessRateLimiter(int requestsPerSecond = 100)
        =&gt; _requestsPerSecond = requestsPerSecond;

    public bool TryConsume(string apiKey)
    {
        var counter = _counters.GetOrAdd(
            apiKey,
            _ =&gt; new SlidingWindowCounter(_requestsPerSecond));

        return counter.TryIncrement();
    }
}

internal class SlidingWindowCounter
{
    private readonly Queue&lt;long&gt; _timestamps = new();
    private readonly object _lock = new();
    private readonly int _limit;

    public SlidingWindowCounter(int limit) =&gt; _limit = limit;

    public bool TryIncrement()
    {
        var now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        var windowStart = now - 1000; // 1 second window

        lock (_lock)
        {
            // Remove timestamps outside the window
            while (_timestamps.Count &gt; 0 &amp;&amp; _timestamps.Peek() &lt; windowStart)
                _timestamps.Dequeue();

            if (_timestamps.Count &gt;= _limit)
                return false; // Rate limit exceeded

            _timestamps.Enqueue(now);
            return true;
        }
    }
}

// Registration
builder.Services.AddSingleton&lt;IRateLimiter, InProcessRateLimiter&gt;();</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Bringing up the scale-out problem unprompted. If you deploy your app on 5 servers (5 "pods"), each server has its own Singleton rate limiter with its own counters. So if your limit is 100 requests/second per API key, with 5 servers you're actually allowing 500 requests/second total â€” 5x your intended limit. The fix: use Redis (a fast shared database) to store the counters. All servers read and write to the same Redis counter, so the limit is enforced globally across all servers. Also worth mentioning: .NET 7+ has built-in rate limiting in <code>System.Threading.RateLimiting</code> â€” you don't need to hand-roll this for new projects.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa8">
    <div class="qa-header">
      <div><div class="qa-question">Q8. Design a Singleton background job scheduler that can run jobs on a cron schedule. <span class="badge badge-purple">Design</span></div><div class="qa-meta">Follow-up: How do you prevent a job from running twice if it takes longer than its interval?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A background job scheduler is a task that keeps running as long as the app is alive â€” cleaning up old records, sending reminder emails, etc. Since it runs in the background for the app's lifetime, Singleton is the right fit. The tricky part is: what if the job is still running when its next scheduled time arrives? Like a train that hasn't arrived at the station yet when the next train is supposed to depart. You need a way to say "skip this run if the previous one isn't done yet." Focus on that overlap prevention as your key insight.</div>
      <p class="body-text"><code>BackgroundService</code> is a built-in .NET base class for tasks that run continuously in the background for the lifetime of the app â€” like a loop that keeps processing work.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">JobScheduler.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public class OrderCleanupJob : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory;
    private readonly ILogger&lt;OrderCleanupJob&gt; _logger;
    // Prevents overlapping execution
    private readonly SemaphoreSlim _mutex = new(1, 1);

    public OrderCleanupJob(
        IServiceScopeFactory scopeFactory,
        ILogger&lt;OrderCleanupJob&gt; logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);

            // Non-blocking: skip this tick if previous run still in progress
            if (!await _mutex.WaitAsync(0, stoppingToken))
            {
                _logger.LogWarning("Job still running. Skipping this tick.");
                continue;
            }

            try
            {
                // Create a new scope for each job run (allows Scoped dependencies)
                using var scope = _scopeFactory.CreateScope();
                var orderRepo = scope.ServiceProvider
                    .GetRequiredService&lt;IOrderRepository&gt;();

                await orderRepo.DeleteExpiredOrdersAsync(stoppingToken);
                _logger.LogInformation("Order cleanup completed.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Order cleanup failed.");
            }
            finally
            {
                _mutex.Release();
            }
        }
    }
}

builder.Services.AddHostedService&lt;OrderCleanupJob&gt;();</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> The <strong><code>IServiceScopeFactory</code></strong> pattern â€” this is important! The background service is a Singleton (lives forever), but to do its work it needs to talk to the database through a repository or <code>DbContext</code>. Database connections are meant to be short-lived (created per request, then disposed). If the Singleton just held onto a database connection permanently, that connection would go stale and start throwing errors. The solution: at the START of each job run, ask the framework to create a fresh temporary context (a "scope"), get a fresh database connection from it, do the work, then throw the scope away. The code does this with <code>_scopeFactory.CreateScope()</code>. Also worth mentioning: for real production systems, use Quartz.NET or Hangfire â€” pre-built libraries that handle distributed scheduling (multiple pods), automatic retry, and overlap prevention, so you don't have to build all this from scratch.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa9">
    <div class="qa-header">
      <div><div class="qa-question">Q9. Design a Singleton connection pool that handles connection failures gracefully. <span class="badge badge-purple">Design</span></div><div class="qa-meta">Follow-up: How do you handle connection validation before lending?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A connection pool is like a library that lends out books â€” except the "books" are database connections, which are expensive to create (opening a connection takes time and resources). Instead of creating a brand-new connection for every request, we keep a collection of reusable connections. Think of it as a car rental agency: you pick up a car when you need it, return it when done, and someone else can use it next. Your design needs to handle: (1) checking the "car" still runs before handing it over, (2) getting a replacement if a car breaks down, (3) telling customers to wait if all cars are out (not failing immediately), and (4) enforcing a maximum fleet size so the agency doesn't rent out more cars than it owns.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ConnectionPool.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public sealed class ManagedConnectionPool
{
    private static readonly Lazy&lt;ManagedConnectionPool&gt; _lazy =
        new(() =&gt; new ManagedConnectionPool());
    public static ManagedConnectionPool Instance =&gt; _lazy.Value;

    private readonly ConcurrentBag&lt;IDbConnection&gt; _pool = new();
    private readonly SemaphoreSlim _throttle;
    private readonly string _connectionString;
    private const int MaxPoolSize = 20;
    private const int MinPoolSize = 5;

    private ManagedConnectionPool()
    {
        _connectionString = Environment.GetEnvironmentVariable("DB_CONN")!;
        _throttle = new SemaphoreSlim(MaxPoolSize, MaxPoolSize);

        // Pre-warm minimum connections
        for (int i = 0; i &lt; MinPoolSize; i++)
            _pool.Add(CreateValidConnection());
    }

    public async Task&lt;PooledConnection&gt; RentAsync(
        TimeSpan timeout = default)
    {
        var effectiveTimeout = timeout == default
            ? TimeSpan.FromSeconds(30) : timeout;

        // Block if pool is at max capacity
        if (!await _throttle.WaitAsync(effectiveTimeout))
            throw new TimeoutException(
                $"Connection pool exhausted. Waited {effectiveTimeout}.");

        // Try to get a valid connection from pool
        while (_pool.TryTake(out var conn))
        {
            if (IsConnectionAlive(conn))
                return new PooledConnection(conn, this);

            // Dead connection â€” discard and let throttle count stand
            // (we'll create a new one implicitly)
            conn.Dispose();
        }

        // No pooled connections available â€” create new (within throttle)
        return new PooledConnection(CreateValidConnection(), this);
    }

    internal void Return(IDbConnection conn)
    {
        if (IsConnectionAlive(conn))
            _pool.Add(conn);
        else
            conn.Dispose(); // Discard dead connections

        _throttle.Release(); // Always release the slot
    }

    private static bool IsConnectionAlive(IDbConnection conn)
    {
        try
        {
            if (conn.State != ConnectionState.Open) return false;
            using var cmd = conn.CreateCommand();
            cmd.CommandText = "SELECT 1";
            cmd.ExecuteScalar();
            return true;
        }
        catch { return false; }
    }

    private IDbConnection CreateValidConnection()
    {
        var conn = new SqlConnection(_connectionString);
        conn.Open();
        return conn;
    }
}

// RAII wrapper: auto-returns connection when disposed
public sealed class PooledConnection : IAsyncDisposable
{
    private readonly IDbConnection _conn;
    private readonly ManagedConnectionPool _pool;
    public IDbConnection Connection =&gt; _conn;

    internal PooledConnection(IDbConnection conn, ManagedConnectionPool pool)
        =&gt; (_conn, _pool) = (conn, pool);

    public ValueTask DisposeAsync()
    {
        _pool.Return(_conn);
        return ValueTask.CompletedTask;
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Two things stand out. First: <strong><code>SemaphoreSlim</code></strong> â€” think of it as a ticket machine at a deli counter. If you set it to 20, only 20 people can have a ticket at once. When someone new arrives, they wait until a ticket is returned. This is called "backpressure" â€” instead of failing with an error immediately when the pool is full, we make callers wait. That's usually the right behavior. Second: the <strong><code>PooledConnection</code> RAII pattern</strong> â€” RAII stands for 'Resource Acquisition Is Initialization' â€” a pattern where cleanup (returning the connection) is tied to the object's disposal. In practice: when this wrapper object is disposed (thrown away), the connection automatically returns to the pool. The <code>await using</code> keyword guarantees cleanup happens even if an exception is thrown. This prevents connections from being permanently lost. Also worth saying: in real production code, <code>SqlClient</code> already has built-in connection pooling â€” you don't need to build this yourself. This design exercise is to show you understand the mechanics behind it.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa10">
    <div class="qa-header">
      <div><div class="qa-question">Q10. Why must an HttpClient be a Singleton (via IHttpClientFactory) rather than created per-request? <span class="badge badge-purple">Design</span></div><div class="qa-meta">Follow-up: What is socket exhaustion and how does IHttpClientFactory prevent it?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> This is one of the most famous "gotcha" bugs in .NET â€” developers hit this in production all the time without understanding why. Start by explaining what happens at the networking level when you create a new HttpClient per request. Then explain why the naive fix (making HttpClient a static field) also has a problem. Finally explain how <code>IHttpClientFactory</code> solves BOTH problems at once.</div>
      <p class="body-text"><strong>Answer:</strong> <code>HttpClient</code> internally holds something called an <strong><code>HttpMessageHandler</code></strong>, which manages a pool of network connections (called <strong>TCP sockets</strong> â€” think of them as phone lines between your app and a remote server). When you call <code>new HttpClient()</code> and then throw it away (dispose it), those phone lines don't hang up immediately. They enter a state called <strong>TIME_WAIT</strong> â€” the OS keeps them "on hold" for 2-4 minutes to make sure all data was received before closing. Now imagine 1,000 requests per second, each creating a new <code>HttpClient</code>. After 2 minutes, you have 120,000 "phone lines on hold." Your operating system has a hard limit on how many of these 'on-hold' connections it can track simultaneously â€” typically in the tens of thousands. Once you hit that limit, new connections fail with "address already in use" â€” your service stops working completely. This is called <strong>socket exhaustion</strong>.</p>
      <p class="body-text"><strong><code>IHttpClientFactory</code></strong> is a Singleton that maintains a shared pool of <code>HttpMessageHandler</code> instances â€” it reuses the same underlying connections across many requests instead of creating new ones. Every 2 minutes it creates a fresh handler (so it picks up any DNS address changes) but keeps the old one alive long enough for in-flight requests to finish. This solves BOTH the socket exhaustion problem (handlers are shared and reused) and the DNS staleness problem (handlers are periodically refreshed to pick up updated IP addresses).</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">HttpClientSetup.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Registration: use named or typed clients via IHttpClientFactory
builder.Services.AddHttpClient("PaymentGateway", client =&gt;
{
    client.BaseAddress = new Uri("https://api.stripe.com");
    client.DefaultRequestHeaders.Add("Authorization", "Bearer sk_...");
    client.Timeout = TimeSpan.FromSeconds(30);
})
.AddTransientHttpErrorPolicy(p =&gt; p.RetryAsync(3))          // Polly retry
.AddTransientHttpErrorPolicy(p =&gt; p.CircuitBreakerAsync(5, TimeSpan.FromMinutes(1)));

// Usage
public class StripeService
{
    private readonly IHttpClientFactory _factory;
    public StripeService(IHttpClientFactory factory) =&gt; _factory = factory;

    public async Task&lt;ChargeResult&gt; ChargeAsync(ChargeRequest req)
    {
        // Creates an HttpClient backed by a pooled handler â€” no socket exhaustion
        using var client = _factory.CreateClient("PaymentGateway");
        var response = await client.PostAsJsonAsync("/v1/charges", req);
        return await response.Content.ReadFromJsonAsync&lt;ChargeResult&gt;()!;
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing the second trap: the naive fix "just make HttpClient a static Singleton field" avoids socket exhaustion, but creates a new problem called <strong>DNS staleness</strong>. Here's why: when your app first connects to a remote server (say, an API), it looks up the server's IP address using DNS (like checking a phone directory). If you reuse the same <code>HttpClient</code> forever, it caches that IP address and never looks it up again. But remote services change their IP addresses all the time â€” for load balancing, blue/green deployments, failovers. If the IP changes and your HttpClient doesn't know, it keeps sending requests to an address that no longer works. <code>IHttpClientFactory</code> solves this by swapping out the handler every 2 minutes â€” forcing a fresh DNS lookup while still reusing connections efficiently. It's the only approach that solves BOTH problems simultaneously.</div>
    </div></div>
  </div>

  <!-- Category 3: Debugging -->
  <h3 class="sub"><i class="fa-solid fa-bug" style="color:var(--accent-red)"></i> Category 3 â€” Debugging (Q11â€“Q15)</h3>

  <div class="qa-item" id="qa11">
    <div class="qa-header">
      <div><div class="qa-question">Q11. Your Singleton service throws ObjectDisposedException after the first request. What's wrong and how do you fix it? <span class="badge badge-red">Debug</span></div><div class="qa-meta">Follow-up: How do you catch this at startup instead of runtime?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> This is called the <strong>captive dependency</strong> problem â€” 'captive' because a long-lived service has trapped (captured) a short-lived dependency and is keeping it alive far longer than intended. Think through the chain of events step by step: a permanent (Singleton) service holds a reference to a temporary (Scoped) service. The temporary service gets cleaned up (disposed) at the end of the first request. On the second request, the permanent service tries to use the already-cleaned-up temporary service â€” and it explodes. Walk through this story clearly, then offer three ways to fix it.</div>
      <p class="body-text"><strong>Diagnosis:</strong> Your Singleton service has a constructor dependency on a Scoped service â€” typically a <code>DbContext</code> (the EF Core database context), an <code>IRepository</code>, or similar. Here's what happens: when the DI container creates the Singleton for the first time, it grabs the Scoped service from the root container (the permanent one). This creates a mismatch â€” the Scoped service was designed to be fresh per request and then thrown away, but now it's being held hostage by a Singleton that lives forever. When the Scoped service's internal resources (database connection, open transaction) get cleaned up after the first request ends, the Singleton is still holding a reference to the now-broken shell. On the second request, the Singleton tries to use it â€” crash.</p>
      <p class="body-text"><strong>Fix 1:</strong> Use <code>IDbContextFactory&lt;T&gt;</code> â€” instead of holding a <code>DbContext</code> directly, hold a factory that creates a fresh one on demand. Create it, use it, dispose it â€” all within a single method call.</p>
      <p class="body-text"><strong>Fix 2:</strong> Use <code>IServiceScopeFactory</code> â€” ask the framework to create a temporary scope (a mini-container for one operation), get your short-lived services from it, do your work, then throw the scope away. The background job example in Q8 shows exactly this pattern.</p>
      <p class="body-text"><strong>Fix 3:</strong> Change the service lifetime to Scoped (if it doesn't actually need to be a Singleton). Ask yourself: does this service truly need to be shared across ALL requests? If not, make it Scoped.</p>
      <p class="body-text"><strong>Prevention:</strong> Enable <code>ValidateScopes = true</code> in development â€” this makes ASP.NET Core check for this mistake at startup and throw an immediate error, instead of letting the bug silently corrupt data in production:</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs</span></div><div class="macos-body"><pre><code class="language-csharp">builder.Host.UseDefaultServiceProvider(options =&gt;
{
    options.ValidateScopes = builder.Environment.IsDevelopment();
    options.ValidateOnBuild = true;
});</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> There are actually TWO ways this bug can manifest, and the second one is harder to find. The first way: the Scoped service gets fully cleaned up and then used â€” you get an <code>ObjectDisposedException</code> right away. This is painful but at least obvious. The second way (the sneaky one): the Scoped service doesn't get cleaned up (because the root container holds it alive) but it accumulates wrong state over time â€” a database transaction that should have been rolled back, an EF Core change tracker full of stale objects from the previous request. In this case there's NO exception â€” your app just quietly returns wrong data. A customer might see someone else's order details, or a product update might silently fail. This second mode is far more dangerous because it's invisible until something is clearly wrong in production.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa12">
    <div class="qa-header">
      <div><div class="qa-question">Q12. Your application is leaking memory. Profiling shows a Singleton service holding millions of objects. What are the likely causes and fixes? <span class="badge badge-red">Debug</span></div><div class="qa-meta">Follow-up: How do you monitor Singleton memory usage in production?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A Singleton lives for the entire lifetime of the app. Anything it holds onto also lives for the entire lifetime of the app. Memory leaks in Singletons happen when something keeps ADDING to a collection inside the Singleton but never REMOVES anything. Think of it like a sink with the drain blocked â€” water keeps flowing in but can never drain out. Identify the three most common "blocked drains" in Singleton services.</div>
      <p class="body-text"><strong>Cause 1 â€” Unbounded Dictionary (the most common cause):</strong> A cache keyed by user IDs, request IDs, URLs, or session IDs where new keys are constantly added but old ones are never removed. After a few days of traffic, this dictionary has millions of entries. Fix: Use <code>IMemoryCache</code> with a <code>SizeLimit</code> and sliding expiration â€” old entries automatically get cleaned up after they haven't been accessed for a set time period.</p>
      <p class="body-text"><strong>Cause 2 â€” Event Handler Leaks:</strong> Your Singleton registers itself to listen to events (like "user logged in" or "config changed") but never unregisters. In C#, when you subscribe to an event (like <code>button.Click += MyHandler</code>), the event owner (the <strong>publisher</strong> â€” the thing firing the event) holds a reference to you (the <strong>subscriber</strong> â€” the thing listening). As long as the event exists, the subscriber can never be garbage collected â€” the <strong>GC</strong> (Garbage Collector â€” the part of .NET that automatically frees unused memory) sees it as "still in use" because something is pointing at it. Fix: use a <code>WeakEventManager</code> (which holds a <strong>weak reference</strong> â€” a reference that doesn't count as 'in use' from the garbage collector's perspective, so the object can still be cleaned up), or unsubscribe from the event when the service is disposed.</p>
      <p class="body-text"><strong>Cause 3 â€” Growing Work Queue Without Draining:</strong> A Singleton that receives incoming work items into a queue, but the background worker processing them is too slow. Under high load, items pile up faster than they're processed. The queue grows forever until memory runs out. Fix: Use a <strong>bounded channel</strong> (<code>BoundedChannel&lt;T&gt;</code>) â€” a queue with a maximum size. When it's full, either make new arrivals wait, or drop the oldest items to make room.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">BoundedQueue.cs â€” Fix for growing queue</span></div><div class="macos-body"><pre><code class="language-csharp">// Replace unbounded Queue with bounded Channel
private readonly Channel&lt;WorkItem&gt; _channel =
    Channel.CreateBounded&lt;WorkItem&gt;(new BoundedChannelOptions(10_000)
    {
        FullMode = BoundedChannelFullMode.DropOldest, // Drop old items when full
        SingleReader = false,
        SingleWriter = false
    });</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing how to diagnose a memory leak in production, not just in theory. Two command-line tools: <code>dotnet-counters monitor --process-id PID System.Runtime</code> â€” this shows you live memory metrics (GC heap size, number of objects) as the app runs. If the heap is growing steadily and never coming back down, you have a leak. <code>dotnet-gcdump collect</code> â€” captures a snapshot of everything currently in memory (a "heap dump"). You can load this into Visual Studio or PerfView and see which objects are using the most memory and what is holding onto them. Also a great answer: expose a health check endpoint that reports how many items are in your Singleton caches. Instead of waiting for an outage, you can alert when a cache grows above a threshold â€” catching the leak before it becomes a crisis.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa13">
    <div class="qa-header">
      <div><div class="qa-question">Q13. Your service creates two instances of a Singleton in production. How is this possible and how do you prevent it? <span class="badge badge-red">Debug</span></div><div class="qa-meta">Follow-up: Can reflection break a Singleton?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> If you have two instances of a Singleton, that means there are two different code paths that each created one independently. Work through the possible ways that could happen: a race condition during creation, multiple separate registrations, or someone bypassing the rules using reflection. This question is also a good reminder that "Singleton" is a promise your code makes, not an absolute physical law â€” it can be broken.</div>
      <p class="body-text"><strong>Cause 1 â€” Race Condition in Naive Implementation:</strong> Two threads both check "is the instance created?" at the exact same moment. Both see "no." Both create a new instance. Now you have two. Fix: Use <code>Lazy&lt;T&gt;</code> with <code>ExecutionAndPublication</code> â€” this guarantees only one thread runs the creation code.</p>
      <p class="body-text"><strong>Cause 2 â€” Multiple AppDomains (old .NET Framework only):</strong> An <strong>AppDomain</strong> is like a separate isolated compartment inside one process. In the old .NET Framework, you could have multiple AppDomains in one app â€” each would have its own copy of all static fields, including your Singleton. Each compartment thinks it has the one true Singleton, but there are actually multiple. Not a problem in modern .NET Core (which only ever has one AppDomain per process).</p>
      <p class="body-text"><strong>Cause 3 â€” Multiple DI Registrations:</strong> If someone accidentally registers the same interface twice with different implementations, the DI container keeps both. When you call <code>GetService&lt;IService&gt;()</code>, you get the last one registered. But when you call <code>GetServices&lt;IService&gt;()</code> (plural), you get all of them â€” multiple instances. Fix: don't double-register unless you intentionally want multiple implementations.</p>
      <p class="body-text"><strong>Cause 4 â€” Reflection Bypass:</strong> Yes, <strong>reflection</strong> â€” the C# feature that lets you inspect and call private members of a class â€” can bypass a private constructor and create additional instances. It's like having a master key that can open any lock:</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ReflectionBreak.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Reflection CAN bypass private constructor
var type = typeof(MySingleton);
var ctor = type.GetConstructor(
    BindingFlags.Instance | BindingFlags.NonPublic,
    null, Type.EmptyTypes, null);
var second = ctor!.Invoke(null); // Creates a SECOND instance!

// Prevention: throw in constructor if instance already exists
private MySingleton()
{
    if (_lazy.IsValueCreated)
        throw new InvalidOperationException(
            "Use MySingleton.Instance â€” do not use reflection.");
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> In modern cloud deployments, "two instances of my Singleton" often doesn't mean two objects in the same process â€” it means two completely separate server instances (called "pods" in Kubernetes). Each server runs its own copy of your app, with its own memory, its own Singleton, its own state. This is actually INTENDED â€” it's how cloud apps handle more traffic by running multiple copies. The problem arises when those multiple Singletons hold state that should be consistent across ALL of them â€” like a cache where you want everyone to see the same data, or a rate limiter that should count requests globally. The fix: move that shared state OUT of the in-process Singleton and INTO a shared external store like Redis, which all servers can read and write to.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa14">
    <div class="qa-header">
      <div><div class="qa-question">Q14. What happens if the Singleton constructor throws an exception? How does the behavior differ between hand-rolled and DI approaches? <span class="badge badge-red">Debug</span></div><div class="qa-meta">Follow-up: How do you implement retry logic for Singleton initialization?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> "What happens when creation fails?" is a practical question that catches many developers off guard. Think about it from the user's perspective: if the Singleton fails to initialize, can the app recover and try again, or is it permanently broken until someone restarts it? The answer depends on WHICH approach you used. Walk through each approach and explain its behavior when things go wrong.</div>
      <p class="body-text"><strong>Lazy&lt;T&gt; (ExecutionAndPublication mode â€” the default):</strong> If the creation code throws an error, that error is <em>permanently remembered</em>. Every future attempt to access <code>.Value</code> throws the exact same error again â€” forever, until the app restarts. The creation code is NEVER run again. This is like a vending machine that jams on the first use and stays jammed forever. Bad if your failure is temporary (like a database that was briefly unavailable at startup).</p>
      <p class="body-text"><strong>Lazy&lt;T&gt; (PublicationOnly mode):</strong> If the creation code throws, the error is NOT remembered. The next thread that tries will run the creation code fresh. This is like a vending machine that resets itself after a jam â€” the next customer can try again. Use this mode when you expect the creation might fail temporarily and want automatic retry.</p>
      <p class="body-text"><strong>DI Container (AddSingleton):</strong> The DI container does NOT permanently cache failures. If the constructor throws, the exception propagates to whoever asked for the service, and the next request can try again. However, in ASP.NET Core, the Singleton is usually created at app startup â€” if it throws there, it typically crashes the entire startup process, which means the app never starts accepting requests at all.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RetryInit.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Retry pattern for Singleton initialization that may fail transiently
public sealed class DatabaseSingleton
{
    private static readonly Lazy&lt;DatabaseSingleton&gt; _lazy =
        new(CreateWithRetry, LazyThreadSafetyMode.ExecutionAndPublication);

    public static DatabaseSingleton Instance =&gt; _lazy.Value;

    private static DatabaseSingleton CreateWithRetry()
    {
        var retryPolicy = Policy
            .Handle&lt;SqlException&gt;()
            .WaitAndRetry(5, attempt =&gt;
                TimeSpan.FromSeconds(Math.Pow(2, attempt)));

        return retryPolicy.Execute(() =&gt; new DatabaseSingleton());
    }

    private DatabaseSingleton()
    {
        // May throw SqlException if DB is not yet ready
        using var conn = new SqlConnection(connStr);
        conn.Open(); // Throws if DB not ready
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Instead of putting retry logic inside the constructor (which makes the constructor complex and hard to test), recommend separating the concerns: use an <strong><code>IHostedService</code></strong> to handle startup initialization with retry logic, and a <strong>health check endpoint</strong> to signal when the service is ready. Here's why this is better: while the service is still trying to initialize (retrying a failed database connection), the health check reports "Unhealthy." Kubernetes sees this and does NOT route any user traffic to this server until the health check says "Healthy." This means users never hit a server that isn't fully ready â€” no failed requests, no errors, clean startup. The constructor stays simple; the retry logic is cleanly separated into its own place.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa15">
    <div class="qa-header">
      <div><div class="qa-question">Q15. Your Singleton configuration service returns stale data after a config update. How do you implement live config reload? <span class="badge badge-red">Debug</span></div><div class="qa-meta">Follow-up: How do you handle mid-request config changes safely?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Config services are almost always Singletons â€” they're created once at startup and shared everywhere. The problem: if the config changes (someone updates a setting file), a Singleton reads it once and never checks again. Think of it like a GPS that only downloads the map when you start your trip â€” if a new road opens, your GPS doesn't know about it. .NET has three built-in ways to read config, each with different "freshness" behavior. Knowing the difference between them is what this question is really testing.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LiveConfigReload.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// IOptions&lt;T&gt;: Singleton â€” reads config ONCE at startup. STALE after reload.
// IOptionsSnapshot&lt;T&gt;: Scoped â€” reads current config per request. NOT usable in Singletons.
// IOptionsMonitor&lt;T&gt;: Singleton-safe â€” CurrentValue always returns latest config.

public class FeatureService
{
    private readonly IOptionsMonitor&lt;FeatureOptions&gt; _options;
    private readonly ILogger&lt;FeatureService&gt; _logger;

    public FeatureService(
        IOptionsMonitor&lt;FeatureOptions&gt; options,
        ILogger&lt;FeatureService&gt; logger)
    {
        _options = options;
        _logger = logger;

        // React to config changes in real-time
        // OnChange callback signature: Action&lt;TOptions, string&gt;
        // where string = the named options name (empty string for default)
        _options.OnChange((newOptions, name) =&gt;
        {
            _logger.LogInformation(
                "FeatureOptions changed. NewBeta={Beta}",
                newOptions.BetaEnabled);
        });
    }

    public bool IsBetaEnabled()
        // Always reads the CURRENT value â€” never stale
        =&gt; _options.CurrentValue.BetaEnabled;
}

public class FeatureOptions
{
    public bool BetaEnabled { get; set; }
    public int MaxRetries { get; set; } = 3;
}

// Registration
builder.Services.Configure&lt;FeatureOptions&gt;(
    builder.Configuration.GetSection("Features"));

// appsettings.json changes are picked up automatically
// when reloadOnChange is true (default in AddJsonFile)</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing the three options interfaces and when to use each: <strong><code>IOptions&lt;T&gt;</code></strong> â€” reads config ONCE at startup and never changes. Use for config that should be fixed for the app's lifetime. <strong><code>IOptionsSnapshot&lt;T&gt;</code></strong> â€” reads the CURRENT config once per HTTP request. Great for catching updates between requests. BUT it's a Scoped service, which means it cannot be injected into Singletons (captive dependency problem!). <strong><code>IOptionsMonitor&lt;T&gt;</code></strong> â€” the Singleton-safe option. <code>CurrentValue</code> always gives you the latest config, and the <code>OnChange</code> callback lets you react immediately when something changes. For mid-request consistency: at the start of a method, grab <code>var options = _optionsMonitor.CurrentValue</code> into a local variable and use only that variable throughout. This way, if the config changes mid-method, your current execution still sees consistent values.</div>
    </div></div>
  </div>

  <!-- Category 4: Comparisons -->
  <h3 class="sub"><i class="fa-solid fa-scale-balanced" style="color:var(--accent-green)"></i> Category 4 â€” Comparisons (Q16â€“Q20)</h3>

  <div class="qa-item" id="qa16">
    <div class="qa-header">
      <div><div class="qa-question">Q16. Compare Singleton, Scoped, and Transient lifetimes. When would choosing the wrong one cause a bug? <span class="badge badge-green">Compare</span></div><div class="qa-meta">Follow-up: Can a Scoped service depend on a Singleton? Can a Transient depend on a Singleton?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Think of these three lifetimes like employees with different contract lengths: Singleton is a permanent employee (lives for the whole app lifetime), Scoped is a contractor hired for one project (lives for one HTTP request), and Transient is a freelancer hired for one task (lives only as long as you use it, then gone). The golden rule: a shorter-lived service can safely depend on a longer-lived one â€” the longer-lived thing will always be around. But a longer-lived service must NOT hold a reference to a shorter-lived one â€” the shorter-lived thing will expire while the longer-lived thing still holds a dead reference. Like a permanent employee still holding a work badge that expired when the contractor left. That's the captive dependency bug. Use this mental model to explain the direction of safe dependencies.</div>
      <div class="table-wrapper"><table>
        <thead><tr><th>Lifetime</th><th>Created</th><th>Disposed</th><th>Instances per App</th><th>Thread Safe?</th></tr></thead>
        <tbody>
          <tr><td><strong>Singleton</strong></td><td>First resolve</td><td>App shutdown</td><td>1</td><td>Must be â€” shared across all threads</td></tr>
          <tr><td><strong>Scoped</strong></td><td>Per request scope</td><td>Request end</td><td>1 per concurrent request</td><td>Usually â€” one thread per request</td></tr>
          <tr><td><strong>Transient</strong></td><td>Every resolve</td><td>When caller disposes</td><td>Unlimited</td><td>N/A â€” private instance</td></tr>
        </tbody>
      </table></div>
      <p class="body-text"><strong>Safe dependency directions:</strong></p>
      <ul class="styled">
        <li>Singleton â†’ depends on Singleton âœ…</li>
        <li>Scoped â†’ depends on Singleton âœ… (safe â€” Singleton lives longer)</li>
        <li>Scoped â†’ depends on Scoped âœ…</li>
        <li>Transient â†’ depends on Singleton âœ…</li>
        <li>Transient â†’ depends on Scoped âœ…</li>
        <li>Singleton â†’ depends on Scoped âŒ CAPTIVE DEPENDENCY â€” BUG!</li>
        <li>Singleton â†’ depends on Transient âŒ CAPTIVE DEPENDENCY â€” only first instance used forever</li>
      </ul>
      <div class="qa-great"><strong>What separates good from great:</strong> Most people only know about the Singleton-captures-Scoped problem. But the Singleton-captures-Transient problem is just as real and often overlooked. A <strong>Transient</strong> service is supposed to be a fresh, brand-new object every time someone asks for it â€” like a freshly sharpened pencil for every use. But if a Singleton grabs a Transient in its constructor and holds onto it, that one "pencil" gets used for the entire lifetime of the app. It's never "fresh" again. Concrete example: imagine a Transient service that generates random values using a fixed seed. If a Singleton captures it, the same seeded generator is reused forever â€” producing the same predictable sequence instead of random values. This is a subtle correctness bug, not a crash, so it's hard to detect.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa17">
    <div class="qa-header">
      <div><div class="qa-question">Q17. What is the difference between Singleton pattern and a static class? When would you choose one over the other? <span class="badge badge-green">Compare</span></div><div class="qa-meta">Follow-up: Can a static class be mocked in unit tests?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A static class is like a toolbox â€” it holds tools (methods) but has no "state" of its own. A Singleton is like an employee â€” it has state, history, and can be swapped out for someone else (a test double). The critical practical difference: can you swap it out in tests? With a Singleton (via an interface), yes. With a static class, no. That one distinction drives most of the design decision.</div>
      <div class="table-wrapper"><table>
        <thead><tr><th>Dimension</th><th>Singleton</th><th>Static Class</th></tr></thead>
        <tbody>
          <tr><td><strong>Instantiation</strong></td><td>One instance of the class</td><td>No instances â€” only the class itself</td></tr>
          <tr><td><strong>Inheritance</strong></td><td>Can inherit, implement interfaces</td><td>Cannot inherit, cannot implement interfaces</td></tr>
          <tr><td><strong>State</strong></td><td>Instance fields (shared across callers)</td><td>Only static fields (always global)</td></tr>
          <tr><td><strong>Testability</strong></td><td>âœ… Via interface injection</td><td>âŒ Cannot mock static calls</td></tr>
          <tr><td><strong>DI-injectable</strong></td><td>âœ… Yes (AddSingleton)</td><td>âŒ No</td></tr>
          <tr><td><strong>Lazy init</strong></td><td>âœ… Controllable with Lazy&lt;T&gt;</td><td>Static ctor â€” runs before first use</td></tr>
          <tr><td><strong>Use case</strong></td><td>Stateful shared service</td><td>Stateless utility functions</td></tr>
        </tbody>
      </table></div>
      <p class="body-text"><strong>When to use static class:</strong> Pure utility functions with no state â€” <code>Math.Sqrt()</code>, <code>string.IsNullOrEmpty()</code>, <code>Path.Combine()</code>. These don't depend on anything, always return the same output for the same input, and don't need to be replaced in tests.</p>
      <p class="body-text"><strong>When to use Singleton:</strong> A stateful service that must be shared â€” a cache, connection pool, config reader. It has state that changes over time, needs to be injected into other services, and you need to be able to replace it with a fake version in unit tests.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> Static classes cannot be replaced (mocked) in unit tests using standard tools like Moq or NSubstitute. A <strong>mock</strong> is a fake version of a service you inject in tests so your tests don't actually hit a real database or real API â€” they use a controllable fake instead. If you use static calls directly (<code>FileHelper.Read()</code>), there's no way to inject a fake. Three workarounds: (1) Wrap the static class behind an interface (the Adapter pattern â€” create an <code>IFileHelper</code> interface and a real implementation that calls the static class). Now you can inject a fake in tests. (2) Use Microsoft Fakes (a heavy-weight testing tool) to intercept static calls. (3) Inject the behavior as a delegate â€” pass <code>Func&lt;string, string&gt;</code> instead of the static method itself. The cleanest solution: design for injection from day one, and only use static classes for truly stateless math-like utilities.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa18">
    <div class="qa-header">
      <div><div class="qa-question">Q18. Compare Singleton pattern vs Service Locator pattern. Why is Service Locator considered an anti-pattern? <span class="badge badge-green">Compare</span></div><div class="qa-meta">Follow-up: Is ServiceProvider.GetService&lt;T&gt;() a service locator?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> The Service Locator pattern is like a class going to a warehouse and picking up whatever tools it needs, without telling anyone what it grabbed. Singleton via constructor injection is like listing everything you need on a requisition form â€” everyone can see exactly what you depend on before you start work. The key difference is visibility: who can see what a class needs? This matters enormously for testing and understanding code.</div>
      <p class="body-text"><strong>Service Locator Anti-Pattern:</strong> A class calls a global registry inside its methods to fetch its own dependencies â€” like <code>ServiceLocator.GetService&lt;ICache&gt;()</code>. Here's why this is bad: (1) <strong>Hidden dependencies</strong> â€” you cannot tell what a class needs by looking at its constructor. You have to read through all its method bodies to discover what it secretly pulls from the locator. (2) <strong>Untestable</strong> â€” you can't inject a fake version of <code>ICache</code> in tests because the class grabs it internally from the locator â€” you'd have to configure the entire locator for every test. (3) <strong>Runtime failures</strong> â€” if a service isn't registered in the locator, you get an error at runtime, not at compile time. Compile-time errors are caught instantly; runtime errors might only appear in production. (4) <strong>Action at a distance</strong> â€” a term for when code in one place secretly changes behaviour somewhere completely different â€” the class's behavior can change based on what's in the locator, which is invisible to whoever is calling the class.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ServiceLocator.cs â€” Anti-Pattern vs Singleton</span></div><div class="macos-body"><pre><code class="language-csharp">// ANTI-PATTERN: Service Locator (hidden dependencies)
public class OrderService
{
    public void ProcessOrder(Order order)
    {
        // Dependencies hidden inside method body!
        // Callers of OrderService cannot see these dependencies
        var cache = ServiceLocator.GetService&lt;ICache&gt;();
        var logger = ServiceLocator.GetService&lt;ILogger&gt;();
        var validator = ServiceLocator.GetService&lt;IValidator&gt;();
        // ... what else does this class need? Unknown without reading source!
    }
}

// PREFERRED: Constructor Injection (dependencies explicit)
public class OrderService
{
    private readonly ICache _cache;
    private readonly ILogger _logger;
    private readonly IValidator _validator;

    // Every dependency is visible â€” no hidden requirements
    public OrderService(ICache cache, ILogger logger, IValidator validator)
    {
        _cache = cache; _logger = logger; _validator = validator;
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Recognizing that calling <code>serviceProvider.GetService&lt;T&gt;()</code> INSIDE a class is ALSO a Service Locator â€” even though it uses the official .NET DI container. It has all the same problems: hidden dependencies, hard to test, runtime failures instead of compile-time. However, there ARE a few legitimate cases where you genuinely need to use it: (1) <code>IServiceScopeFactory.CreateScope()</code> inside a Singleton background service â€” as we saw in Q8, this is the correct way to access Scoped services from a long-lived Singleton, and there's no other clean way. (2) Middleware and filters that need to pick which service to use based on runtime conditions. (3) Factory methods that dynamically choose between multiple implementations. Outside these specific cases, always inject dependencies through the constructor where they're visible and testable.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa19">
    <div class="qa-header">
      <div><div class="qa-question">Q19. How does Singleton combine with Factory Method pattern? Give a real example. <span class="badge badge-green">Compare</span></div><div class="qa-meta">Follow-up: What's the Registry pattern and how does it differ?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> The Factory Method pattern is about choosing WHICH object to create based on some input â€” like a vending machine that gives you different products based on which button you press. The Singleton pattern is about having only ONE vending machine shared by everyone. Combining them: one shared factory that creates different products on demand. The factory itself is the Singleton; the products it creates are not. Make this distinction clear.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SingletonFactory.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Singleton Factory: one factory instance, creates multiple products
public interface IPaymentProcessor { Task&lt;Receipt&gt; ProcessAsync(Payment p); }

public sealed class PaymentProcessorFactory
{
    private static readonly Lazy&lt;PaymentProcessorFactory&gt; _lazy =
        new(() =&gt; new PaymentProcessorFactory());
    public static PaymentProcessorFactory Instance =&gt; _lazy.Value;

    private readonly IReadOnlyDictionary&lt;string, IPaymentProcessor&gt; _processors;

    private PaymentProcessorFactory()
    {
        _processors = new Dictionary&lt;string, IPaymentProcessor&gt;
        {
            ["stripe"] = new StripeProcessor(),
            ["paypal"] = new PayPalProcessor(),
            ["square"] = new SquareProcessor()
        };
    }

    // Factory Method: creates/selects the right processor
    public IPaymentProcessor GetProcessor(string provider)
        =&gt; _processors.TryGetValue(provider.ToLowerInvariant(), out var p)
            ? p
            : throw new ArgumentException($"Unknown provider: {provider}");
}

// Usage: factory is a Singleton, processors are selected at runtime
var processor = PaymentProcessorFactory.Instance.GetProcessor("stripe");
var receipt = await processor.ProcessAsync(payment);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing the <strong>Registry pattern</strong> â€” which takes the Singleton Factory one step further. A Registry is a Singleton that maps names to objects AND allows dynamic registration at runtime. The factory in the code above has hardcoded mappings ("stripe" â†’ StripeProcessor). A Registry can have NEW processors plugged in at runtime without changing the factory code â€” like an app store where new apps can be installed without rewriting the phone. Example: MEF (Managed Extensibility Framework) in .NET is a Registry that discovers and registers plugins at startup â€” mostly legacy today in modern .NET; the same pattern is achieved more simply using keyed services in the DI container. The key difference: factory = fixed menu you coded in advance; registry = open menu where anyone can add new items dynamically. This makes registries ideal for plugin-based systems where new implementations are added by third parties.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa20">
    <div class="qa-header">
      <div><div class="qa-question">Q20. How does Singleton implementation differ between C#, C++, and Rust? What does each language guarantee? <span class="badge badge-green">Compare</span></div><div class="qa-meta">Follow-up: Why is the C++ "static local variable" trick safe in C++11 but not earlier?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Every programming language has different built-in safety guarantees. C# has libraries that handle threading for you. C++ used to be broken in this regard and got fixed in 2011. Rust takes the most extreme approach â€” the language itself refuses to compile unsafe code, rather than leaving safety up to the developer. For each language, ask: "does the language GUARANTEE this is thread-safe, or does the developer have to be careful?"</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">CrossLanguage.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// C# â€” Lazy&lt;T&gt;
public sealed class Singleton
{
    private static readonly Lazy&lt;Singleton&gt; _lazy = new(() =&gt; new Singleton());
    public static Singleton Instance =&gt; _lazy.Value;
    private Singleton() { }
}

// C++ (C++11 and later) â€” Static local variable (thread-safe by standard)
// class Singleton {
// public:
//     static Singleton&amp; GetInstance() {
//         static Singleton instance; // Thread-safe in C++11 (magic statics)
//         return instance;
//     }
// private:
//     Singleton() {}
// };

// Rust â€” OnceCell (lazy, thread-safe, no global mutable state)
// use once_cell::sync::OnceCell;
// static INSTANCE: OnceCell&lt;AppConfig&gt; = OnceCell::new();
// pub fn get_config() -&gt; &amp;'static AppConfig {
//     INSTANCE.get_or_init(|| AppConfig::load())
// }
// Rust's borrow checker prevents shared mutable state â€”
// true Singletons with mutable state require Arc&lt;Mutex&lt;T&gt;&gt;</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Two historical facts that show real depth. First: before C++11 (2011), the C++ static local variable trick was NOT thread-safe. Two threads could race to initialize the variable simultaneously â€” both entering the initialization block at once. This was a silent bug that caused crashes and corruption in production codebases for years. C++11 fixed this by adding "magic statics" â€” the language standard now guarantees exactly-once initialization even with concurrent access. Second: Rust is fundamentally different from C# and C++ in its approach. In C# and C++, you CAN write unsafe code â€” the language will compile it and let it crash at runtime. In Rust, the compiler's type system and "borrow checker" analyze your code for data races at compile time. If you try to share mutable state between threads without proper synchronization, Rust simply REFUSES to compile your code. Safety isn't a convention you follow â€” it's a compile-time guarantee. This is the most important philosophical difference between the three languages.</div>
    </div></div>
  </div>

  <!-- Category 5: Production -->
  <h3 class="sub"><i class="fa-solid fa-server" style="color:var(--accent-yellow)"></i> Category 5 â€” Production Scenarios (Q21â€“Q25)</h3>

  <div class="qa-item" id="qa21">
    <div class="qa-header">
      <div><div class="qa-question">Q21. Your Singleton HttpClient service is causing socket exhaustion in production. Walk through your diagnosis and fix. <span class="badge badge-yellow">Production</span></div><div class="qa-meta">Follow-up: How does IHttpClientFactory's 2-minute handler rotation work?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> This is a production incident walkthrough question. Structure your answer like a real incident investigation: first describe the symptoms you'd see (what is the system doing wrong?), then explain your diagnosis (how do you find the root cause?), then give the fix. Use the incident investigation structure: symptoms first, then root cause, then fix.</div>
      <p class="body-text"><strong>Symptoms you'd observe:</strong> Requests start failing with "Connection refused" or "address already in use" errors. The error rate increases as traffic goes up. Running <code>netstat -an | grep TIME_WAIT</code> (a network diagnostic command) shows thousands â€” maybe tens of thousands â€” of socket connections in "TIME_WAIT" state. Strangely, restarting the service makes it work again for a while, then it slowly degrades again as traffic builds up. This pattern strongly points to socket exhaustion.</p>
      <p class="body-text"><strong>Root Cause Diagnosis:</strong> Search the codebase for <code>new HttpClient()</code> â€” especially in places that get called per request (controller actions, service methods). Each <code>new HttpClient()</code> creates its own internal connection handler. When that HttpClient is disposed (or goes out of scope), the underlying network connection doesn't close immediately â€” the OS holds it in TIME_WAIT for 2-4 minutes as a safety buffer. At high traffic volumes, you create thousands of these "zombie connections" per minute until the OS port limit is hit.</p>
      <p class="body-text"><strong>Fix â€” Switch to IHttpClientFactory:</strong></p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">HttpClientFix.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// BEFORE: new HttpClient per call (socket exhaustion!)
public class PaymentService
{
    public async Task&lt;string&gt; ChargeAsync(string payload)
    {
        using var client = new HttpClient(); // Creates new handler per call!
        return await client.PostStringAsync("https://api.stripe.com", payload);
    }
}

// AFTER: Use IHttpClientFactory (pooled handlers, 2-min rotation)
public class PaymentService
{
    private readonly IHttpClientFactory _factory;
    public PaymentService(IHttpClientFactory factory) =&gt; _factory = factory;

    public async Task&lt;string&gt; ChargeAsync(string payload)
    {
        // Handler is pooled â€” not created per call
        // Handler rotated every 2 minutes for DNS freshness
        using var client = _factory.CreateClient("stripe");
        var response = await client.PostAsync("/v1/charges",
            new StringContent(payload));
        return await response.Content.ReadAsStringAsync();
    }
}

// Registration
builder.Services.AddHttpClient("stripe", c =&gt;
    c.BaseAddress = new Uri("https://api.stripe.com"));</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Understanding exactly how the 2-minute rotation works under the hood. The factory keeps a record of when each handler was created. After 2 minutes, any new requests for a named client get a NEW handler â€” forcing a fresh DNS lookup to pick up any IP address changes. But the old handler isn't thrown away immediately â€” it stays alive for up to 10 more minutes to let any currently-in-flight requests complete normally. This graceful overlap prevents two failure modes: DNS staleness (old handler would never refresh the IP) AND broken requests (throwing away a handler mid-request would cut the connection). The lifetime is configurable via <code>.SetHandlerLifetime(TimeSpan.FromMinutes(5))</code> if 2 minutes isn't right for your setup.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa22">
    <div class="qa-header">
      <div><div class="qa-question">Q22. Your Singleton cache is returning stale data after a distributed deployment. Different pods show different values. How do you fix this? <span class="badge badge-yellow">Production</span></div><div class="qa-meta">Follow-up: What is cache-aside pattern and how does it relate?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> This is the classic "distributed systems" problem with in-process caches. When your app runs on multiple servers (pods), each server has its own isolated memory â€” including its own Singleton cache. Updating data on Server A doesn't automatically update Server B's cache. Think of it like 5 post offices each keeping their own address book â€” if one updates an address, the others still have the old one. Describe three strategies, each with different tradeoffs between simplicity and consistency.</div>
      <p class="body-text"><strong>Root Cause:</strong> Each server (pod) has its own Singleton cache living in its own memory. When Server A updates a product and clears its own cache, servers B through E still have the old cached value. Users who hit Server B see stale data. The inconsistency only resolves when each server's cache entry expires on its own schedule â€” which could be minutes or hours away.</p>
      <p class="body-text"><strong>Solution 1 â€” Accept Eventual Consistency:</strong> Use short expiry times (30-60 seconds on cache entries). Accept that data might be up to 60 seconds stale. This is the simplest solution and is totally acceptable for data where "slightly old" is fine â€” product descriptions, feature flags, pricing that doesn't change mid-transaction. The data eventually becomes consistent once every server's cache expires. This trade-off has a name: <strong>eventual consistency</strong> â€” meaning all copies of the data will converge to the same value over time, just not necessarily at the exact same moment.</p>
      <p class="body-text"><strong>Solution 2 â€” Distributed Cache (Redis):</strong> Replace the in-process <code>IMemoryCache</code> with a shared external cache (Redis). Now ALL servers read from and write to the SAME cache store â€” like replacing 5 separate address books with one shared Google Contacts account. When you invalidate a key in Redis, every server immediately sees the change. Stronger consistency, but adds a network hop to every cache operation.</p>
      <p class="body-text"><strong>Solution 3 â€” Cache Invalidation via Message Bus:</strong> When one server updates data, it broadcasts a "this key is now stale" message to all other servers via a message queue (like Azure Service Bus or RabbitMQ). Every server listens for these messages and immediately removes the affected key from its own local cache. This gives you fast local reads (no network hop to Redis) AND near-immediate consistency when data changes. More complex to set up, but best of both worlds.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DistributedCache.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Distributed cache with IDistributedCache (Redis-backed)
public class ProductCacheService
{
    private readonly IDistributedCache _cache;
    private readonly IProductRepository _repo;

    public ProductCacheService(IDistributedCache cache, IProductRepository repo)
        =&gt; (_cache, _repo) = (cache, repo);

    public async Task&lt;Product?&gt; GetAsync(string productId)
    {
        var cached = await _cache.GetStringAsync($"product:{productId}");
        if (cached is not null)
            return JsonSerializer.Deserialize&lt;Product&gt;(cached);

        var product = await _repo.GetByIdAsync(productId);
        if (product is not null)
        {
            await _cache.SetStringAsync(
                $"product:{productId}",
                JsonSerializer.Serialize(product),
                new DistributedCacheEntryOptions
                {
                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
                });
        }
        return product;
    }
}

builder.Services.AddStackExchangeRedisCache(options =&gt;
    options.Configuration = builder.Configuration["Redis:ConnectionString"]);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing the three caching strategies by name. <strong>Cache-Aside (Lazy Loading)</strong> â€” the most common pattern. Your code checks the cache first; if the data isn't there (a "cache miss"), load it from the database and store it in the cache for next time. Simple, works for most cases. <strong>Write-Through</strong> â€” every time you UPDATE the database, also update the cache immediately. Data is always fresh in the cache, but every write takes longer (two places to write instead of one). <strong>Write-Around</strong> â€” writes go directly to the database and SKIP the cache entirely. The cache is only populated when someone reads the data. This avoids storing data that might never be read again. For Singleton caches in a multi-server deployment, Cache-Aside combined with Redis is the most commonly recommended production setup because it's simple, well-understood, and Redis handles the cross-server consistency automatically.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa23">
    <div class="qa-header">
      <div><div class="qa-question">Q23. Your service has a 3-second cold start because the Singleton ML model takes 3 seconds to load. How do you eliminate cold starts? <span class="badge badge-yellow">Production</span></div><div class="qa-meta">Follow-up: How does Kubernetes readiness probe interact with Singleton warmup?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A "cold start" is when the first user to arrive has to wait for something expensive to load before their request is processed. Think of it like a restaurant that only prepares the kitchen when the first customer walks in â€” they have to wait 10 minutes while the chef gets everything ready, while all subsequent customers walk into a fully ready kitchen. The solution: prepare the kitchen BEFORE opening the doors. Explain how to use <code>IHostedService</code> to do this preparation at startup, and how to use a Kubernetes readiness probe to keep the "door closed" until preparation is complete.</div>
      <p class="body-text"><strong>Anti-pattern â€” Lazy initialization on first request:</strong> <code>Lazy&lt;T&gt;</code> is perfect for delaying creation until first use. But if "first use" is a real user's request, that user waits 3 seconds for the ML model to load while everyone else watches a spinner. Even worse: if 50 users hit the app at the same time during startup, they might ALL trigger the initialization at once â€” a stampede that overwhelms the system. This is called a <strong>thundering herd</strong> problem.</p>
      <p class="body-text"><strong>Solution â€” IHostedService Warmup + Readiness Probe:</strong></p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">WarmupService.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public class MLModelWarmupService : IHostedService
{
    private readonly MLModelSingleton _model;
    private readonly ILogger&lt;MLModelWarmupService&gt; _logger;

    public MLModelWarmupService(
        MLModelSingleton model,
        ILogger&lt;MLModelWarmupService&gt; logger)
    {
        _model = model;  // DI injects the Singleton
        _logger = logger;
    }

    public async Task StartAsync(CancellationToken ct)
    {
        _logger.LogInformation("Warming up ML model...");
        var sw = Stopwatch.StartNew();

        // Force eager initialization â€” runs before HTTP server starts accepting
        await _model.EnsureLoadedAsync(ct);

        _logger.LogInformation("ML model loaded in {Ms}ms", sw.ElapsedMilliseconds);
    }

    public Task StopAsync(CancellationToken ct) =&gt; Task.CompletedTask;
}

// Readiness probe: reports "Healthy" only after warmup completes
public class MLReadinessCheck : IHealthCheck
{
    private readonly MLModelSingleton _model;
    public MLReadinessCheck(MLModelSingleton model) =&gt; _model = model;

    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(
        HealthCheckContext context, CancellationToken ct)
    {
        return Task.FromResult(_model.IsLoaded
            ? HealthCheckResult.Healthy("Model ready")
            : HealthCheckResult.Unhealthy("Model loading"));
    }
}

// Kubernetes readiness probe hits /health/ready
// Traffic is NOT sent to pod until readiness probe returns 200
// So: pod starts â†’ model loads â†’ readiness probe passes â†’ traffic flows</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Understanding the difference between a <strong>liveness probe</strong> and a <strong>readiness probe</strong> in Kubernetes. A liveness probe asks: "is the app still alive and running?" If it fails, Kubernetes kills and restarts the pod â€” it's the "heartbeat" check. A readiness probe asks: "is this pod READY to receive user traffic?" If it fails, Kubernetes keeps the pod alive but removes it from the load balancer pool â€” no user requests reach it until it's ready. By making your readiness probe return "Unhealthy" while the ML model is loading, Kubernetes naturally holds all traffic away from that server during warmup. The moment the model finishes loading and your readiness probe returns "Healthy," Kubernetes automatically starts sending traffic. The result: ZERO cold starts ever reach users. The restaurant prepares the kitchen before opening the doors â€” customers only see a fully-ready kitchen.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa24">
    <div class="qa-header">
      <div><div class="qa-question">Q24. Your circuit breaker Singleton is not tripping even after 100 consecutive failures. What's wrong? <span class="badge badge-yellow">Production</span></div><div class="qa-meta">Follow-up: How do you share circuit breaker state across multiple pods?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> A circuit breaker is like an electrical circuit breaker in your home â€” it trips (opens) after too many "overloads" (failures), cutting power to protect the system. For it to trip, it needs to REMEMBER each failure. If each request gets its own fresh circuit breaker with memory wiped clean, the failure count never accumulates and the breaker never trips. Walk through the logic and you'll arrive at the answer: this is the Singleton vs Transient lifetime bug. Walk through the diagnosis and fix clearly.</div>
      <p class="body-text"><strong>Root Cause â€” Transient Registration (most common):</strong> The circuit breaker is registered as Transient â€” meaning the DI container creates a brand new instance for every single request. Each new instance starts with a failure count of zero. Request 1 fails â€” counter goes to 1, then the instance is thrown away. Request 2 creates a NEW instance with counter = 0, fails, counter = 1, thrown away again. The circuit breaker never reaches the threshold because it never remembers previous failures. The fix is obvious once you understand it: the circuit breaker MUST be a Singleton so it shares its failure count across ALL requests.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">CircuitBreaker.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// WRONG: Transient circuit breaker â€” failure count resets every request
services.AddTransient&lt;ICircuitBreaker, PollyCircuitBreaker&gt;(); // BUG!

// RIGHT: Singleton circuit breaker â€” shared failure count across all requests
// Build the policy ONCE and share the same instance
var circuitBreakerPolicy = Policy
    .Handle&lt;HttpRequestException&gt;()
    .Handle&lt;TaskCanceledException&gt;()
    .CircuitBreakerAsync(
        exceptionsAllowedBeforeBreaking: 5,
        durationOfBreak: TimeSpan.FromMinutes(1),
        onBreak: (ex, ts) =&gt; logger.LogWarning("Circuit OPEN for {Ts}", ts),
        onReset: () =&gt; logger.LogInformation("Circuit RESET"),
        onHalfOpen: () =&gt; logger.LogInformation("Circuit HALF-OPEN"));

// Register the SAME policy instance as Singleton
services.AddSingleton&lt;IAsyncPolicy&gt;(circuitBreakerPolicy);

// Usage
public class PaymentGatewayClient
{
    private readonly IAsyncPolicy _policy;
    private readonly HttpClient _client;

    public PaymentGatewayClient(IAsyncPolicy policy, IHttpClientFactory factory)
    {
        _policy = policy;
        _client = factory.CreateClient("gateway");
    }

    public async Task&lt;Receipt&gt; ChargeAsync(ChargeRequest req)
        // All callers share the same circuit state
        =&gt; await _policy.ExecuteAsync(() =&gt; DoChargeAsync(req));
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Bringing up the multi-server (distributed) version of this problem without being asked. In a deployment with 5 servers, each server has its own Singleton circuit breaker with its own failure count. Server A might have hit 100 failures and opened its circuit (stopping calls to the broken service) â€” but Servers B through E each have their own counters and might be at only 20 failures, still happily sending requests to the broken external service. The system is far from protected. The fix: a Redis-backed circuit breaker where all servers read and write the failure count to a shared Redis key. When the failure count in Redis hits the threshold, ALL servers see the circuit as open simultaneously. Polly (the popular .NET resilience library) doesn't natively support this distributed pattern, but you can implement a custom Redis-backed strategy â€” or use it as a design discussion point to show you understand the limitations of in-process state for distributed systems.</div>
    </div></div>
  </div>

  <div class="qa-item" id="qa25">
    <div class="qa-header">
      <div><div class="qa-question">Q25. How do you design a Singleton service that behaves correctly in a multi-tenant SaaS application where each tenant has different configuration? <span class="badge badge-yellow">Production</span></div><div class="qa-meta">Follow-up: How does this interact with IOptionsMonitor?</div></div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>How to think about it:</strong> Multi-tenant means multiple companies ("tenants") all using the same application, but each with their own configuration, settings, and data â€” like multiple law firms all using the same case management software, but each seeing only their own cases and settings. A Singleton is one shared object. Multi-tenant is N sets of different configurations. How do you reconcile ONE shared object with N different configurations? The answer: the Singleton is the shared object, but it internally organizes its data into separate "buckets" per tenant. The tenant ID from the current request tells it which bucket to look in.</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MultiTenantConfig.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Multi-tenant Singleton: one service, N tenant partitions
public sealed class TenantConfigService : ITenantConfigService
{
    // Keyed by tenant ID â€” each tenant has its own config snapshot
    private readonly ConcurrentDictionary&lt;string, TenantConfig&gt; _configs = new();
    private readonly ITenantConfigProvider _provider;
    private readonly ILogger&lt;TenantConfigService&gt; _logger;

    public TenantConfigService(
        ITenantConfigProvider provider,
        ILogger&lt;TenantConfigService&gt; logger)
    {
        _provider = provider;
        _logger = logger;
    }

    public async Task&lt;TenantConfig&gt; GetConfigAsync(string tenantId)
    {
        // GetOrAdd ensures single load per tenant â€” thread-safe
        if (_configs.TryGetValue(tenantId, out var cached))
            return cached;

        var config = await _provider.LoadAsync(tenantId);
        _configs.TryAdd(tenantId, config);

        _logger.LogInformation("Loaded config for tenant {TenantId}", tenantId);
        return config;
    }

    // Called by background service when a tenant updates their config
    public void InvalidateTenant(string tenantId)
    {
        _configs.TryRemove(tenantId, out _);
        _logger.LogInformation("Config invalidated for tenant {TenantId}", tenantId);
    }
}

// IHttpContextAccessor provides the current tenant from the request
public class TenantMiddleware
{
    private readonly RequestDelegate _next;
    public TenantMiddleware(RequestDelegate next) =&gt; _next = next;

    public async Task InvokeAsync(HttpContext ctx, ITenantConfigService configSvc)
    {
        var tenantId = ctx.Request.Headers["X-Tenant-Id"].FirstOrDefault()
            ?? throw new InvalidOperationException("Missing X-Tenant-Id header");

        var config = await configSvc.GetConfigAsync(tenantId);
        ctx.Items["TenantConfig"] = config;

        await _next(ctx);
    }
}

builder.Services.AddSingleton&lt;ITenantConfigService, TenantConfigService&gt;();</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Knowing that .NET's built-in Options system actually supports multi-tenancy through <strong>Named options</strong> â€” meaning you can have multiple separate configurations of the same options class, each identified by a name (like a tenant ID). Instead of just <code>IOptionsMonitor&lt;TenantOptions&gt;.CurrentValue</code> (which gives you one global config), you can call <code>.Get(tenantId)</code> to get a named configuration specific to that tenant. You register per-tenant options at startup using a custom <code>IConfigureNamedOptions&lt;T&gt;</code> â€” a class that tells the framework: "for tenant X, the options should be Y." However, named options are best for tenants you know about at startup. For dynamic multi-tenancy â€” where new customer companies can sign up at any time without restarting the app â€” the <code>ConcurrentDictionary</code> approach shown in the code is more flexible. You load tenant config on first request, cache it per tenant ID, and provide an invalidation method to clear it when a tenant updates their settings. This handles unlimited tenants, added at any time, without any app restarts.</div>
    </div></div>
  </div>

</section>

<!-- ============================================================ SECTION 15 -->
<section id="s15" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-compass-drafting"></i></div>
    <div><div class="section-num">Section 15</div><h2 class="section-title">When To Use / Not Use</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-circle-check" style="color:var(--accent-green)"></i> 10 Valid Use Cases for Singleton</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>#</th><th>Use Case</th><th>Why Singleton Fits</th><th>Example Class</th></tr></thead>
        <tbody>
          <tr><td>1</td><td><strong>Connection Pool</strong></td><td>Pool state (available/in-use connections) must be shared globally. Two pools would defeat the purpose.</td><td>SqlConnectionPool</td></tr>
          <tr><td>2</td><td><strong>In-Memory Cache</strong></td><td>Cache entries must be visible to all callers simultaneously. Per-caller caches cause thundering herd on cache miss.</td><td>IMemoryCache</td></tr>
          <tr><td>3</td><td><strong>Application Logger</strong></td><td>Single logger shares enrichers, sinks, and log rotation logic. Multiple loggers produce fragmented output.</td><td>Serilog.Log</td></tr>
          <tr><td>4</td><td><strong>Configuration Reader</strong></td><td>Config loaded once from disk/network. Multiple readers cause redundant I/O and potential inconsistency.</td><td>IConfiguration</td></tr>
          <tr><td>5</td><td><strong>Circuit Breaker Policy</strong></td><td>Failure count must be global â€” per-request breakers never accumulate enough failures to open.</td><td>CircuitBreakerPolicy</td></tr>
          <tr><td>6</td><td><strong>Feature Flag Service</strong></td><td>Flag state refreshed by one background poller. Multiple pollers waste bandwidth and may see different states momentarily.</td><td>FeatureFlagService</td></tr>
          <tr><td>7</td><td><strong>HttpClient Handler Pool</strong></td><td>Socket reuse across requests prevents TIME_WAIT exhaustion. Per-request handlers exhaust OS ports.</td><td>IHttpClientFactory</td></tr>
          <tr><td>8</td><td><strong>Background Job Scheduler</strong></td><td>Job timers must not duplicate. Two schedulers would run each job twice â€” double processing, double billing.</td><td>BackgroundService</td></tr>
          <tr><td>9</td><td><strong>ML Model Host</strong></td><td>400MB+ models loaded once. Per-request loading is impossible. Shared model requires thread-safe inference (read-only).</td><td>OnnxModelService</td></tr>
          <tr><td>10</td><td><strong>Application Metrics Collector</strong></td><td>Counters must aggregate across all request threads. Per-request collectors would report fragmented, incorrect data.</td><td>IMetricsService</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-circle-xmark" style="color:var(--accent-red)"></i> 9 Anti-Patterns â€” When NOT to Use Singleton</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>#</th><th>Anti-Pattern</th><th>Why It Fails</th><th>Correct Alternative</th></tr></thead>
        <tbody>
          <tr><td>1</td><td><strong>Database Context</strong></td><td>DbContext is not thread-safe. A Singleton DbContext shared across threads causes concurrent change tracking corruption.</td><td>Scoped DbContext</td></tr>
          <tr><td>2</td><td><strong>User-Specific State</strong></td><td>Singleton is shared â€” storing user preferences or session data in a Singleton leaks data between users (catastrophic security bug).</td><td>Scoped or IHttpContextAccessor</td></tr>
          <tr><td>3</td><td><strong>Request-Scoped Data</strong></td><td>Correlation IDs, request timing, A/B test bucket â€” data that varies per request must live in the request scope.</td><td>Scoped service or HttpContext.Items</td></tr>
          <tr><td>4</td><td><strong>Short-Lived Objects</strong></td><td>Validators, command handlers, DTOs have no shared state. Making them Singleton saves no memory and complicates their design.</td><td>Transient</td></tr>
          <tr><td>5</td><td><strong>Services with Thread-Unsafe Dependencies</strong></td><td>If a Singleton captures a thread-unsafe dependency (non-concurrent dictionary, StreamWriter), concurrent access causes data corruption.</td><td>Use thread-safe types internally</td></tr>
          <tr><td>6</td><td><strong>High-Frequency Mutation Hotspot</strong></td><td>If every request writes to the Singleton (e.g., a global counter with a lock), the lock becomes a serialization bottleneck.</td><td>Interlocked ops, sharded counters</td></tr>
          <tr><td>7</td><td><strong>Services That Need Disposal Per Operation</strong></td><td>A Singleton IDisposable is never disposed during normal operation â€” only at app shutdown. Resources may leak if the service holds file handles or DB connections.</td><td>Create + dispose per operation</td></tr>
          <tr><td>8</td><td><strong>Environment-Specific Mocks</strong></td><td>Making a mock or fake implementation a Singleton in tests pollutes state between test methods. Test isolation requires fresh instances.</td><td>New instance per test or use DI scope</td></tr>
          <tr><td>9</td><td><strong>Distributed State That Should Be Centralized</strong></td><td>An in-process Singleton cache in a 10-pod deployment means 10 independent caches with 10 different stale values. Use Redis.</td><td>IDistributedCache + Redis</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-ruler" style="color:var(--accent-cyan)"></i> The 2-Algorithm Rule for Singleton Decisions</div>
    <p class="body-text">Before making any class a Singleton, apply this two-part test. If you fail either part, it should NOT be a Singleton.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SingletonDecisionTest.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// Algorithm 1: Would two instances cause incorrect behavior?
// Ask: if I resolve this service twice and get two different instances,
// does the application behave incorrectly?
public class CandidateTest
{
    public static bool NeedsSingleton_Algorithm1(string serviceName)
    {
        // YES â†’ Singleton needed: ConnectionPool, Cache, CircuitBreaker
        // If two pools existed, one would be underutilized while the other exhausts
        // If two caches existed, a cache write in one would miss in the other

        // NO â†’ Not needed: Validator, Mapper, EmailFormatter
        // Two validators always produce the same result â€” no shared state at risk
        return false; // Pseudocode â€” evaluate per case
    }

    // Algorithm 2: Is the state truly global (not request-scoped)?
    // Ask: does this data need to persist across requests?
    public static bool NeedsSingleton_Algorithm2(string serviceName)
    {
        // YES â†’ Could be Singleton: connection pool (persists across requests)
        // NO â†’ Should be Scoped or Transient: DbContext (request-specific)

        // ALSO CHECK: Is the state user-specific?
        // If yes â†’ NEVER Singleton (cross-user data leakage)
        return false; // Pseudocode â€” evaluate per case
    }
}

// Rule: Singleton ONLY if BOTH algorithms return YES
// AND you have no user-specific or request-specific state
// AND the class is thread-safe OR you can make it thread-safe</code></pre></div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 16 -->
<section id="s16" class="section">
  <div class="section-header">
    <div class="section-icon red"><i class="fa-solid fa-triangle-exclamation"></i></div>
    <div><div class="section-num">Section 16</div><h2 class="section-title">Common Pitfalls</h2></div>
  </div>

  <!-- Pitfall 1 -->
  <div class="collapsible active">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">1</span> God Singleton â€” One Class Does Everything</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">The God Singleton accumulates responsibilities over time. It starts as a config reader, then grows to include logging, caching, metrics, and session management. Soon it has 50 methods and every class depends on it. Changes to the God Singleton cascade to every dependent class.</p>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-skull"></i> Signs You Have a God Singleton</div>
        <ul class="styled red">
          <li>More than 5 distinct responsibilities in one class</li>
          <li>More than 20 methods or 500 lines</li>
          <li>Injected into more than 80% of your services</li>
          <li>"Every time we need a new feature, we add it here"</li>
        </ul>
      </div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fix: Decompose by Responsibility</div>Split into focused Singletons: <code>IConfigService</code>, <code>ICacheService</code>, <code>ILogService</code>, <code>IMetricsService</code>. Each service is registered independently, tested independently, and replaced independently. Services only inject the focused interfaces they actually need.</div>
    </div></div>
  </div>

  <!-- Pitfall 2 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">2</span> Captive Dependencies â€” Singleton Capturing Shorter-Lived Services</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A Singleton captures a Scoped or Transient dependency in its constructor. The captured dependency lives for the Singleton's lifetime â€” not its intended lifetime. DbContext captured by a Singleton holds an open connection and a change tracker for the entire app lifetime.</p>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-skull"></i> Classic Failure</div>
        Singleton captures DbContext â†’ Stale entities returned after updates â†’ ObjectDisposedException on connection timeout â†’ $23K in failed transactions
      </div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fixes</div>
        1. Use <code>IDbContextFactory&lt;T&gt;</code> â€” creates fresh contexts per operation.<br>
        2. Use <code>IServiceScopeFactory</code> â€” creates a scope per operation and resolves Scoped services from it.<br>
        3. Change to Scoped lifetime if the service doesn't truly need to be Singleton.<br>
        4. Enable <code>ValidateScopes = true</code> in development to catch this at startup.
      </div>
    </div></div>
  </div>

  <!-- Pitfall 3 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">3</span> Untestable Static Singleton â€” Hidden Global State</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A hand-rolled static Singleton accessed via <code>MySingleton.Instance</code> creates hidden global state. Unit tests cannot substitute a test double â€” the class is hardwired to use the concrete Singleton. Tests become order-dependent: state from test A bleeds into test B.</p>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-skull"></i> Signs</div>
        Tests pass individually but fail when run together. Tests behave differently in CI (which runs all tests) vs locally (which runs specific tests). You add <code>MySingleton._instance = null</code> hacks in test teardown.
      </div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fix: DI + Interface</div>
        Register via <code>AddSingleton&lt;IService, Service&gt;()</code>. Inject <code>IService</code> into constructors. Tests inject <code>Mock&lt;IService&gt;</code>. Each test creates its own DI scope â€” no shared static state between tests.
      </div>
    </div></div>
  </div>

  <!-- Pitfall 4 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">4</span> Unbounded Collections â€” Memory Leak</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A Singleton holds a <code>ConcurrentDictionary</code>, <code>List</code>, or <code>Queue</code> that grows without bound. Because the Singleton lives for the app's lifetime, so does the collection. After 3 months in production: 4.8GB heap, 400ms GC pauses, cascading timeouts.</p>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-skull"></i> Common Offenders</div>
        Cache without eviction policy. Event log without rotation. Request audit trail without maximum size. User session dictionary without expiration. All grow forever if the Singleton is never restarted.
      </div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fix: Always Use Bounded Collections</div>
        Replace <code>ConcurrentDictionary</code> with <code>IMemoryCache</code> (SizeLimit + expiration). Replace <code>Queue&lt;T&gt;</code> with <code>Channel&lt;T&gt;</code> (BoundedChannelOptions with FullMode). Set maximum sizes and expiration on every Singleton collection.
      </div>
    </div></div>
  </div>

  <!-- Pitfall 5 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">5</span> Mutable Configuration â€” IOptions vs IOptionsMonitor</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">Using <code>IOptions&lt;T&gt;</code> in a Singleton reads configuration once at startup and never picks up changes. After a config push (changing a rate limit, a feature flag, a connection timeout), the Singleton still serves the old values until the process restarts.</p>
      <div class="table-wrapper"><table>
        <thead><tr><th>Interface</th><th>Lifetime</th><th>Reads Config</th><th>Safe in Singleton?</th></tr></thead>
        <tbody>
          <tr><td><code>IOptions&lt;T&gt;</code></td><td>Singleton</td><td>Once at startup</td><td>âœ… Yes, but STALE after reload</td></tr>
          <tr><td><code>IOptionsSnapshot&lt;T&gt;</code></td><td>Scoped</td><td>Per request (fresh)</td><td>âŒ No â€” Captive dependency in Singleton</td></tr>
          <tr><td><code>IOptionsMonitor&lt;T&gt;</code></td><td>Singleton</td><td>Always current (<code>CurrentValue</code>)</td><td>âœ… Yes â€” designed for Singletons</td></tr>
        </tbody>
      </table></div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fix: Always Use IOptionsMonitor in Singletons</div>
        Inject <code>IOptionsMonitor&lt;T&gt;</code>. Access current values via <code>_options.CurrentValue</code>. Subscribe to changes via <code>_options.OnChange((opts, name) =&gt; { ... })</code>. Signature: <code>Action&lt;TOptions, string&gt;</code> where the second parameter is the named options name (empty string for default options).
      </div>
    </div></div>
  </div>

  <!-- Pitfall 6 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">6</span> Singleton in Distributed Systems â€” The Multi-Pod Problem</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">In a Kubernetes deployment with 5 pods, there are 5 Singleton instances â€” one per pod. If the Singleton holds state that should be consistent across all pods (rate limit counters, circuit breaker state, feature flags), each pod sees a different state. A rate limiter Singleton allows 5x the intended rate when scaled to 5 pods.</p>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-skull"></i> Distributed Singleton Problems</div>
        <ul class="styled red">
          <li>Rate limiter: 5 pods Ã— 100 req/sec = 500 req/sec actual rate (not 100)</li>
          <li>Circuit breaker: pod A trips circuit, pod B still sending requests to a dead service</li>
          <li>Feature flags: pod A has old flags from before restart, pod B has new flags</li>
          <li>Audit log: events distributed across 5 pods â€” incomplete audit trail per pod</li>
        </ul>
      </div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Fix: Externalize Shared State</div>
        Rate limiting: Redis INCR + EXPIRE. Circuit breaker: Redis-backed state machine. Feature flags: centralized flag service (LaunchDarkly). Audit log: centralized log aggregator (Elasticsearch). The in-process Singleton becomes a lightweight local client to the shared store.
      </div>
    </div></div>
  </div>

  <!-- Pitfall 7 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-red);font-size:1.25rem;">7</span> Testing with Shared Static State â€” Test Pollution</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">Static Singleton state persists between test methods in the same test run. Test A populates the cache. Test B expects an empty cache but finds Test A's data. Tests become order-dependent and fail intermittently in CI when test execution order differs from local.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">TestIsolation.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Pattern 1: Use DI WebApplicationFactory in integration tests
// Each test gets its own service scope â€” no shared static state
public class OrderTests : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
    private readonly WebApplicationFactory&lt;Program&gt; _factory;

    public OrderTests(WebApplicationFactory&lt;Program&gt; factory)
    {
        _factory = factory.WithWebHostBuilder(builder =&gt;
        {
            builder.ConfigureServices(services =&gt;
            {
                // Replace Singleton with in-memory test double
                services.AddSingleton&lt;ICacheService, InMemoryTestCache&gt;();
            });
        });
    }

    [Fact]
    public async Task GetOrder_ReturnsOk()
    {
        var client = _factory.CreateClient();
        // Each test creates a fresh HTTP client â€” no shared cache state
        var response = await client.GetAsync("/orders/123");
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }
}

// Pattern 2: For hand-rolled Singletons, expose a reset method for testing only
public sealed class ConfigSingleton
{
    private static ConfigSingleton? _instance;
    public static ConfigSingleton Instance =&gt; _instance ??= new();

    // Only for testing â€” resets shared state between tests
    internal static void ResetForTesting() =&gt; _instance = null;
}</code></pre></div></div>
      <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-wrench"></i> Best Fix: DI Throughout</div>
        The best fix is prevention: use DI-registered Singletons with interfaces from the start. Tests create a new IServiceCollection per test, register mock implementations, and get a fresh scope. No static state is shared between tests. No reset methods needed.
      </div>
    </div></div>
  </div>
</section>

<!-- ============================================================ SECTION 18 -->
<section id="s18" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-bolt"></i></div>
    <div><div class="section-num">Section 18</div><h2 class="section-title">Quick Reference Cheat Sheet</h2></div>
  </div>

  <!-- 9-card grid -->
  <div class="grid-9" style="margin-bottom:2rem;">
    <div class="cheat-card">
      <div class="cheat-card-title">1. Naive (Broken)</div>
      <div class="cheat-card-body">if (_inst == null)<br>  _inst = new();<br>return _inst;<br><br>// RACE: 2 threads<br>// both see null!</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">2. Double-Checked Lock</div>
      <div class="cheat-card-body">private volatile T? _inst;<br>private object _lock = new();<br>if (_inst == null)<br>  lock(_lock)<br>    if (_inst == null)<br>      _inst = new();</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">3. Lazy&lt;T&gt; (Best Manual)</div>
      <div class="cheat-card-body">private static readonly<br>Lazy&lt;T&gt; _lazy =<br>  new(() =&gt; new T(),<br>  ExecutionAnd<br>  Publication);<br>public static T I =&gt; _lazy.Value;</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">4. DI Singleton (Production)</div>
      <div class="cheat-card-body">services.AddSingleton<br>  &lt;IService, Service&gt;();<br><br>// Constructor inject<br>// IService everywhere<br>// Testable + swappable</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">5. Eager Static</div>
      <div class="cheat-card-body">private static readonly<br>T _inst = new T();<br><br>// CLR: guaranteed<br>// thread-safe init<br>// Always created</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">6. Lifetimes</div>
      <div class="cheat-card-body">Singleton: 1 per app<br>Scoped: 1 per request<br>Transient: 1 per resolve<br><br>Singleton &gt; Scoped<br>= safe dependency<br>Scoped &gt; Singleton<br>= CAPTIVE BUG!</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">7. Options in Singletons</div>
      <div class="cheat-card-body">IOptions&lt;T&gt;: stale<br>IOptionsSnapshot: scoped<br>IOptionsMonitor: live<br><br>In Singleton:<br>ALWAYS use<br>IOptionsMonitor</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">8. Thread Safety Rules</div>
      <div class="cheat-card-body">Read-only state: safe<br>ConcurrentDictionary: safe<br>Interlocked: safe<br>lock(): safe<br><br>Dictionary: UNSAFE<br>List: UNSAFE<br>int++: UNSAFE</div>
    </div>
    <div class="cheat-card">
      <div class="cheat-card-title">9. Distributed Systems</div>
      <div class="cheat-card-body">N pods = N Singletons<br>Each has own state!<br><br>Rate limit: Redis INCR<br>Circuit: Redis state<br>Cache: IDistributedCache<br>Flags: central service</div>
    </div>
  </div>

  <!-- One-liner summary -->
  <div class="callout callout-info" style="margin-bottom:1.5rem;">
    <div class="callout-title"><i class="fa-solid fa-star"></i> One-Liner Summary</div>
    <p style="font-size:1.1rem; font-weight:600;">"A Singleton is a service that must be shared â€” use DI to register it, interfaces to abstract it, thread-safe collections to store its state, and IOptionsMonitor to read live configuration. Never capture Scoped services, never grow collections without bounds, and always remember that one process = one Singleton, not one per Kubernetes cluster."</p>
  </div>

  <!-- Danger Zones Table -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-radiation" style="color:var(--accent-red)"></i> 7 Danger Zones â€” Red Flags in Code Review</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Red Flag</th><th>What It Signals</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td>Singleton constructor taking DbContext</td><td>Captive dependency â€” stale connection, ObjectDisposedException</td><td>Switch to IDbContextFactory or Scoped lifetime</td></tr>
          <tr><td>ConcurrentDictionary in Singleton with no eviction</td><td>Memory leak â€” collection grows unboundedly over app lifetime</td><td>Replace with IMemoryCache + SizeLimit + expiration</td></tr>
          <tr><td>IOptions&lt;T&gt; in Singleton</td><td>Stale configuration â€” changes require process restart</td><td>Replace with IOptionsMonitor&lt;T&gt;</td></tr>
          <tr><td>new HttpClient() in non-Singleton service</td><td>Socket exhaustion â€” TIME_WAIT accumulation at scale</td><td>Inject IHttpClientFactory, use CreateClient()</td></tr>
          <tr><td>Singleton with CircuitBreakerPolicy as Transient</td><td>Circuit never opens â€” failure count resets per request</td><td>Register policy as Singleton</td></tr>
          <tr><td>Static Singleton accessed directly (not via DI)</td><td>Untestable â€” no seam for mock injection</td><td>Register with AddSingleton, inject via constructor</td></tr>
          <tr><td>Lock on 'this' or typeof(T) in Singleton</td><td>External code can deadlock your Singleton</td><td>Use a private readonly object _lock = new()</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Decision Flowchart -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-code-branch" style="color:var(--accent-green)"></i> Quick Decision Flowchart</div>
    <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
      <div class="mermaid">
flowchart TD
    START{"Need shared state\nacross requests?"} -->|NO| Q1{"Pure stateless\nutility?"}
    Q1 -->|YES| R1["Use static class"]
    Q1 -->|NO| R2["Use Transient or Scoped"]
    START -->|YES| Q2{"Is state user-specific\nor request-specific?"}
    Q2 -->|YES| R3["NEVER Singleton!\nData leaks between users"]
    Q2 -->|NO| Q3{"Distributed system?\nMultiple pods/processes"}
    Q3 -->|YES| R4["Redis / external store\n+ thin client Singleton"]
    Q3 -->|NO| Q4{"In ASP.NET Core?"}
    Q4 -->|YES| R5["AddSingleton via DI"]
    Q4 -->|NO| Q5{"Expensive init?\nNeeds lazy loading?"}
    Q5 -->|YES| R6["Lazy of T with\nExecutionAndPublication"]
    Q5 -->|NO| R7["Static readonly field"]

    style START fill:#1e293b,stroke:#3b82f6,color:#f1f5f9
    style Q1 fill:#1e293b,stroke:#f59e0b,color:#f1f5f9
    style Q2 fill:#1e293b,stroke:#8b5cf6,color:#f1f5f9
    style Q3 fill:#1e293b,stroke:#06b6d4,color:#f1f5f9
    style Q4 fill:#1e293b,stroke:#8b5cf6,color:#f1f5f9
    style Q5 fill:#1e293b,stroke:#f59e0b,color:#f1f5f9
    style R1 fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style R2 fill:#334155,stroke:#64748b,color:#f1f5f9
    style R3 fill:#7f1d1d,stroke:#ef4444,color:#f1f5f9
    style R4 fill:#1e3a5f,stroke:#3b82f6,color:#f1f5f9
    style R5 fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style R6 fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style R7 fill:#064e3b,stroke:#10b981,color:#f1f5f9
      </div>
    </div>
  </div>
</section>

<div class="footer">
  <div style="font-size:1.5rem;font-weight:900;background:linear-gradient(135deg,#3b82f6,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin-bottom:0.5rem;">Singleton Design Pattern</div>
  <p>GoF Creational Pattern &bull; C# / .NET &bull; 25 Interview Q&amp;As &bull; 3 Bug Case Studies &bull; 7 Pitfalls</p>
  <p style="margin-top:0.5rem;font-size:0.8rem;">Pattern 01 of 18 &bull; Complete Wiki Reference</p>
  <p style="margin-top:1.5rem;padding-top:1rem;border-top:1px solid var(--border-color);font-size:0.8rem;color:var(--text-muted);">&copy; 2026 Rafikul Alam. All rights reserved.</p>
</div>

</div><!-- /wiki-container -->

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Wrap card content into collapsible card-body divs
  document.querySelectorAll('.card').forEach(function(card) {
    var title = card.querySelector('.card-title');
    if (!title) return;
    var body = document.createElement('div');
    body.className = 'card-body';
    while (title.nextSibling) {
      body.appendChild(title.nextSibling);
    }
    card.appendChild(body);
    title.addEventListener('click', function() {
      card.classList.toggle('open');
    });
  });

  // Jr â†’ Sr toggle: close others, toggle current
  window.toggleSrSolution = function(btn) {
    var item = btn.closest('.jr-sr-item');
    var wrap = item.querySelector('.sr-solution-wrap');
    var isOpen = wrap.classList.contains('show');
    // Close all open solutions
    document.querySelectorAll('.sr-solution-wrap.show').forEach(function(w) {
      w.classList.remove('show');
    });
    // Toggle current (if it was closed, open it)
    if (!isOpen) {
      wrap.classList.add('show');
    }
  };

  // Make mermaid diagrams collapsible (start collapsed)
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var label = 'Show Diagram';
    var prev = container.previousElementSibling;
    if (prev && prev.tagName === 'H3') {
      label = prev.textContent.trim();
      prev.style.display = 'none';
    }
    var toggle = document.createElement('div');
    toggle.className = 'diagram-toggle';
    toggle.innerHTML = '<i class="fa-solid fa-diagram-project"></i> ' + label + ' <i class="fa-solid fa-chevron-down chevron"></i>';
    container.parentNode.insertBefore(toggle, container);
    container.classList.add('collapsed');
    toggle.addEventListener('click', function() {
      toggle.classList.toggle('open');
      container.classList.toggle('collapsed');
    });
  });

  // Pinch-to-zoom + zoom buttons for mermaid diagrams
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var mermaidEl = container.querySelector('.mermaid');
    if (!mermaidEl) return;
    var scale = 1;
    var minScale = 0.5;
    var maxScale = 3;

    // Add zoom buttons
    var zoomDiv = document.createElement('div');
    zoomDiv.className = 'diagram-zoom-controls';
    zoomDiv.innerHTML = '<button class="diagram-zoom-btn" data-action="out" title="Zoom out"><i class="fa-solid fa-minus"></i></button><button class="diagram-zoom-btn" data-action="reset" title="Reset zoom"><i class="fa-solid fa-rotate-left"></i></button><button class="diagram-zoom-btn" data-action="in" title="Zoom in"><i class="fa-solid fa-plus"></i></button>';
    container.appendChild(zoomDiv);

    function applyZoom() {
      mermaidEl.style.transform = 'scale(' + scale + ')';
      mermaidEl.style.transformOrigin = 'top left';
    }

    zoomDiv.addEventListener('click', function(e) {
      var btn = e.target.closest('[data-action]');
      if (!btn) return;
      var action = btn.getAttribute('data-action');
      if (action === 'in') scale = Math.min(maxScale, scale + 0.25);
      else if (action === 'out') scale = Math.max(minScale, scale - 0.25);
      else { scale = 1; }
      applyZoom();
    });

    // Touch pinch-to-zoom
    var lastDist = 0;
    var startScale = 1;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        startScale = scale;
      }
    }, { passive: false });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        var dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        scale = Math.min(maxScale, Math.max(minScale, startScale * (dist / lastDist)));
        applyZoom();
      }
    }, { passive: false });

    // Single-finger pan when zoomed
    var panStartX, panStartY, scrollStartX, scrollStartY;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        panStartX = e.touches[0].clientX;
        panStartY = e.touches[0].clientY;
        scrollStartX = container.scrollLeft;
        scrollStartY = container.scrollTop;
      }
    });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 1 && scale > 1) {
        e.preventDefault();
        container.scrollLeft = scrollStartX - (e.touches[0].clientX - panStartX);
        container.scrollTop = scrollStartY - (e.touches[0].clientY - panStartY);
      }
    }, { passive: false });
  });

  // Click outside to close nav panel and open diagrams
  document.addEventListener('click', function(e) {
    if (navPanel.classList.contains('open') && !navPanel.contains(e.target) && !navFab.contains(e.target)) {
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    }
    document.querySelectorAll('.diagram-toggle.open').forEach(function(toggle) {
      var container = toggle.nextElementSibling;
      if (!toggle.contains(e.target) && !container.contains(e.target)) {
        toggle.classList.remove('open');
        container.classList.add('collapsed');
      }
    });
  });

  // Initialize Highlight.js
  document.querySelectorAll('pre code').forEach(function(block) {
    hljs.highlightElement(block);
  });

  // Q&A toggle
  document.querySelectorAll('.qa-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Generic collapsible sections
  document.querySelectorAll('.collapsible-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Tab system
  document.querySelectorAll('.tab-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var container = this.closest('.tab-container');
      var target = this.getAttribute('data-tab');

      container.querySelectorAll('.tab-btn').forEach(function(b) {
        b.classList.remove('active');
      });
      container.querySelectorAll('.tab-panel').forEach(function(p) {
        p.classList.remove('active');
      });

      this.classList.add('active');
      var panel = container.querySelector('[data-panel="' + target + '"]');
      if (panel) panel.classList.add('active');
    });
  });

  // Nav toggle
  var navFab = document.getElementById('navFab');
  var navPanel = document.getElementById('navPanel');
  navFab.addEventListener('click', function() {
    navPanel.classList.toggle('open');
    navFab.classList.toggle('active');
  });

  // Smooth scroll helper with easing
  function smoothScrollTo(targetY, duration) {
    if(window.matchMedia('(prefers-reduced-motion:reduce)').matches){window.scrollTo(0,targetY);return;}
    var startY = window.scrollY;
    var diff = targetY - startY;
    var startTime = null;
    function step(timestamp) {
      if (!startTime) startTime = timestamp;
      var progress = Math.min((timestamp - startTime) / duration, 1);
      var ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      window.scrollTo(0, startY + diff * ease);
      if (progress < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // Nav panel links â€” smooth scroll + auto-close
  document.querySelectorAll('.nav-panel a').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      var target = document.querySelector(this.getAttribute('href'));
      if (target) {
        var offset = target.getBoundingClientRect().top + window.scrollY - ((document.querySelector('.top-toolbar')||{}).offsetHeight||56) - 8;
        smoothScrollTo(offset, 800);
      }
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    });
  });

  // Scroll up/down buttons
  document.getElementById('scrollUp').addEventListener('click', function() {
    window.scrollBy({ top: -Math.round(window.innerHeight*0.35), behavior: 'smooth' });
  });
  document.getElementById('scrollDown').addEventListener('click', function() {
    window.scrollBy({ top: Math.round(window.innerHeight*0.35), behavior: 'smooth' });
  });

  // Scroll percentage tracker
  var percentText = document.getElementById('percentText');
  window.addEventListener('scroll', function() {
    var docHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percent = docHeight > 0 ? Math.round((window.scrollY / docHeight) * 100) : 0;
    percentText.textContent = percent + '%';
  });

  // Fullscreen toggle
  var fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', function() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });
  document.addEventListener('fullscreenchange', function() {
    var icon = fsBtn.querySelector('i');
    if (document.fullscreenElement) {
      icon.className = 'fa-solid fa-compress';
    } else {
      icon.className = 'fa-solid fa-expand';
    }
  });

  // Expand/Collapse all cards toggle
  var expandBtn = document.getElementById('expandAllBtn');
  var allExpanded = false;
  expandBtn.addEventListener('click', function() {
    allExpanded = !allExpanded;
    var cards = document.querySelectorAll('.card');
    cards.forEach(function(card) {
      if (allExpanded) {
        card.classList.add('open');
      } else {
        card.classList.remove('open');
      }
    });
    var icon = expandBtn.querySelector('i');
    icon.className = allExpanded ? 'fa-solid fa-angles-up' : 'fa-solid fa-angles-down';
    expandBtn.title = allExpanded ? 'Collapse all cards' : 'Expand all cards';
  });
});
</script>
</body>
</html>
