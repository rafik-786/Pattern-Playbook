<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Factory Method Design Pattern â€” Complete Wiki</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“˜</text></svg>">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- highlight.js CDN stylesheet REMOVED â€” custom syntax colors below -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true,theme:'base',themeVariables:{primaryColor:'#1e3a5f',primaryTextColor:'#f1f5f9',primaryBorderColor:'#3b82f6',lineColor:'#60a5fa',secondaryColor:'#2d1b4e',secondaryTextColor:'#f1f5f9',secondaryBorderColor:'#8b5cf6',tertiaryColor:'#1a3a2a',tertiaryTextColor:'#f1f5f9',tertiaryBorderColor:'#10b981',mainBkg:'#1e3a5f',nodeBorder:'#3b82f6',clusterBkg:'#0f172a',clusterBorder:'#334155',titleColor:'#f1f5f9',edgeLabelBackground:'#1e293b',nodeTextColor:'#f1f5f9',actorBkg:'#1e3a5f',actorBorder:'#3b82f6',actorTextColor:'#f1f5f9',actorLineColor:'#60a5fa',signalColor:'#60a5fa',signalTextColor:'#f1f5f9',labelBoxBkgColor:'#1e293b',labelBoxBorderColor:'#3b82f6',labelTextColor:'#f1f5f9',loopTextColor:'#f1f5f9',activationBorderColor:'#3b82f6',activationBkgColor:'#1e3a5f',sequenceNumberColor:'#f1f5f9',noteBkgColor:'#2d1b4e',noteTextColor:'#e2e8f0',noteBorderColor:'#8b5cf6',classText:'#f1f5f9',relationColor:'#60a5fa',relationLabelColor:'#94a3b8',fontFamily:'Inter',fontSize:'14px',background:'#0f172a'}});</script>
<style>
:root{--bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-tertiary:#334155;--accent-blue:#3b82f6;--accent-purple:#8b5cf6;--accent-green:#10b981;--accent-red:#ef4444;--accent-yellow:#f59e0b;--accent-cyan:#06b6d4;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--border-color:#334155;--glass-bg:rgba(30,41,59,0.7);--glass-border:rgba(148,163,184,0.1);}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}
html{scroll-behavior:smooth;}
body{font-family:'Inter',sans-serif;background:var(--bg-primary);color:var(--text-primary);line-height:1.6;font-size:1rem;padding-top:52px;}
::-webkit-scrollbar{width:8px;}::-webkit-scrollbar-track{background:var(--bg-secondary);}::-webkit-scrollbar-thumb{background:var(--bg-tertiary);border-radius:4px;}::-webkit-scrollbar-thumb:hover{background:var(--accent-blue);}
.wiki-container{max-width:100%;margin:0 auto;padding:0 2rem 4rem;}
.hero{background:linear-gradient(135deg,#0f172a 0%,#1e1b4b 50%,#0f172a 100%);border-bottom:1px solid var(--border-color);padding:3rem 2rem 3rem;text-align:center;position:relative;overflow:hidden;}
.hero::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at 50% 0%,rgba(59,130,246,0.15) 0%,transparent 70%);}
.hero-badge{display:inline-flex;align-items:center;gap:0.5rem;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);color:var(--accent-blue);padding:0.375rem 1rem;border-radius:999px;font-size:0.875rem;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;margin-bottom:1.5rem;}
.hero h1{font-size:clamp(2.5rem,5vw,4rem);font-weight:900;background:linear-gradient(135deg,#f1f5f9,#93c5fd,#a78bfa);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin-bottom:1rem;position:relative;}
.hero-subtitle{font-size:1.25rem;color:var(--text-secondary);max-width:700px;margin:0 auto 2rem;}
.hero-meta{display:flex;justify-content:center;gap:2rem;flex-wrap:wrap;font-size:0.9rem;color:var(--text-muted);}
.hero-meta span{display:flex;align-items:center;gap:0.4rem;}
.hero-meta i{color:var(--accent-blue);}
/* Top toolbar â€” horizontal bar above all content */
.top-toolbar{position:fixed;top:0;left:0;right:0;z-index:1000;display:flex;align-items:center;justify-content:space-between;padding:0.5rem 1.25rem;background:rgba(15,23,42,0.95);backdrop-filter:blur(12px);border-bottom:1px solid rgba(59,130,246,0.15);box-shadow:0 2px 12px rgba(0,0,0,0.3);overflow:hidden;}
.toolbar-left,.toolbar-right{display:flex;align-items:center;gap:0.5rem;}
.fab-btn{width:38px;height:38px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(30,41,59,0.8);color:#93c5fd;font-size:0.9rem;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.25);transition:background-color 0.2s,border-color 0.2s,color 0.2s,transform 0.2s;display:flex;align-items:center;justify-content:center;text-decoration:none;padding:0;-webkit-tap-highlight-color:transparent;outline:none;}
.fab-btn:hover{background:rgba(59,130,246,0.2);border-color:var(--accent-blue);color:#fff;}
.fab-btn.active{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-color:transparent;color:#fff;}
.fab-back{border-color:rgba(239,68,68,0.35);color:#fca5a5;width:36px;height:36px;font-size:0.8rem;margin-left:0.75rem;}
.fab-back:hover{border-color:var(--accent-red);background:rgba(239,68,68,0.15);color:#fca5a5;}
.scroll-percent{font-family:'JetBrains Mono',monospace;font-size:0.6875rem;font-weight:700;color:var(--text-muted);user-select:none;min-width:2rem;text-align:center;}
/* Nav panel â€” anchored below toolbar */
.nav-panel{position:fixed;top:3.5rem;left:1rem;background:rgba(15,23,42,0.97);backdrop-filter:blur(16px);border:1px solid rgba(59,130,246,0.3);border-radius:1rem;padding:1rem;z-index:1001;max-height:70vh;overflow-y:auto;width:220px;max-width:calc(100vw - 2rem);box-shadow:0 12px 40px rgba(0,0,0,0.5);opacity:0;visibility:hidden;transform:translateY(-10px) scale(0.95);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0.25s;}
.nav-panel.open{opacity:1;visibility:visible;transform:translateY(0) scale(1);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0s;}
.nav-panel-title{font-size:0.6875rem;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.08em;margin-bottom:0.5rem;padding:0 0.25rem;}
.nav-panel a{display:flex;align-items:center;gap:0.5rem;padding:0.5rem 0.625rem;border-radius:0.5rem;font-size:0.8125rem;font-weight:500;text-decoration:none;color:#93c5fd;transition:background-color 0.15s,color 0.15s;min-height:44px;}
.nav-panel a i{width:16px;text-align:center;font-size:0.75rem;color:var(--accent-blue);}
.nav-panel::-webkit-scrollbar{width:4px;}
.nav-panel::-webkit-scrollbar-thumb{background:#475569;border-radius:2px;}
.section{margin:3rem 0;scroll-margin-top:5rem;overflow:hidden;}
.section-header{display:flex;align-items:center;gap:1rem;margin-bottom:2rem;padding-bottom:1rem;border-bottom:2px solid var(--border-color);flex-wrap:wrap;}
.section-icon{width:3rem;height:3rem;border-radius:0.75rem;display:flex;align-items:center;justify-content:center;font-size:1.25rem;flex-shrink:0;}
.section-icon.blue{background:rgba(59,130,246,0.15);color:var(--accent-blue);}
.section-icon.purple{background:rgba(139,92,246,0.15);color:var(--accent-purple);}
.section-icon.green{background:rgba(16,185,129,0.15);color:var(--accent-green);}
.section-icon.red{background:rgba(239,68,68,0.15);color:var(--accent-red);}
.section-icon.yellow{background:rgba(245,158,11,0.15);color:var(--accent-yellow);}
.section-icon.cyan{background:rgba(6,182,212,0.15);color:var(--accent-cyan);}
.section-title{font-size:1.875rem;font-weight:800;}
.section-num{font-size:0.875rem;color:var(--text-muted);font-weight:600;}
.card{background:var(--glass-bg);backdrop-filter:blur(10px);border:1px solid var(--glass-border);border-radius:1rem;padding:0;transition:border-color 0.3s;margin-bottom:0.75rem;overflow:hidden;}
.card.open{overflow:visible;}
.card:hover{border-color:rgba(59,130,246,0.3);}
.card-title{font-size:1.125rem;font-weight:700;margin:0;padding:1rem 1.25rem;display:flex;align-items:center;gap:0.5rem;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;position:relative;}
.card-title::after{content:'\f078';font-family:'Font Awesome 6 Free';font-weight:900;font-size:0.75rem;color:var(--text-muted);margin-left:auto;transition:transform 0.3s;}
.card.open .card-title::after{transform:rotate(180deg);}
.card-body{max-height:0;overflow:hidden;transition:max-height 0.4s cubic-bezier(0.4,0,0.2,1),padding 0.3s;padding:0 1.25rem;}
.card.open .card-body{max-height:none;padding:0 1.25rem 1.25rem;overflow:visible;}
/* Jr -> Sr toggle system */
.jr-sr-list{display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;}
@media(max-width:768px){.jr-sr-list{grid-template-columns:1fr;}}
.jr-sr-item{position:relative;display:flex;flex-direction:column;}
.jr-sr-item>.callout{flex:1;}
.sr-toggle{display:flex;width:fit-content;align-items:center;gap:0.4rem;margin-top:0.75rem;padding:0.5rem 0.9rem 0.4rem;border-radius:999px;border:1px solid rgba(16,185,129,0.4);background:rgba(16,185,129,0.1);color:#6ee7b7;font-size:0.8rem;font-weight:600;cursor:pointer;transition:background-color 0.2s,border-color 0.2s,color 0.2s;-webkit-tap-highlight-color:transparent;position:relative;z-index:11;}
.sr-toggle:hover{background:rgba(16,185,129,0.2);border-color:var(--accent-green);color:#a7f3d0;}
.sr-solution-wrap{position:absolute;left:0;right:0;top:0;z-index:10;pointer-events:none;opacity:0;transition:opacity 0.25s ease;}
.sr-solution-wrap.show{pointer-events:auto;opacity:1;}
@media(max-width:768px){
.sr-solution-wrap{position:static;opacity:0;max-height:0;overflow:hidden;transition:opacity 0.25s ease,max-height 0.4s cubic-bezier(0.4,0,0.2,1);}
.sr-solution-wrap.show{opacity:1;max-height:3000px;pointer-events:auto;}
}
.sr-solution-wrap>.sr-solution{margin:0;padding:1.25rem 1.5rem;border-left:3px solid var(--accent-green);border-radius:0.75rem;background:#0a1f14;border:1px solid rgba(16,185,129,0.3);box-shadow:0 12px 48px rgba(0,0,0,0.7),0 0 0 1px rgba(16,185,129,0.15);min-height:100%;}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;align-items:start;}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:1.5rem;align-items:start;}
.grid-4{display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;align-items:start;}
.grid-9{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;}
.grid-2>*,.grid-3>*,.grid-4>*,.grid-9>*,.two-col>*{min-width:0;}
@media(max-width:768px){.grid-2,.grid-3,.grid-4,.grid-9{grid-template-columns:1fr;}}
/* Tablet & mobile responsive */
@media(max-width:1024px){
body{font-size:0.9375rem;padding-top:48px;}
.wiki-container{max-width:100%;padding:0 1rem 2rem;}
.hero{padding:2.5rem 1rem 2rem;}
.hero h1{font-size:clamp(1.75rem,4vw,2.5rem);}
.hero-subtitle{font-size:1rem;}
.hero-meta{gap:1rem;font-size:0.8rem;}
.section{margin:2rem 0;scroll-margin-top:4.5rem;}
.section-title{font-size:1.375rem;}
.section-header{gap:0.75rem;margin-bottom:1.25rem;}
.section-icon{width:2.25rem;height:2.25rem;font-size:1rem;}
.card{margin-bottom:1rem;border-radius:0.75rem;}
.card-title{font-size:1rem;}
.callout{padding:1rem;margin:0.75rem 0;}
.macos-body{padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.8rem;line-height:1.5;}
.grid-2{gap:1rem;}
.grid-3{grid-template-columns:repeat(2,1fr);gap:0.75rem;}
table{font-size:0.8125rem;}
td,th{padding:0.5rem 0.75rem;}
.top-toolbar{padding:0.375rem 0.75rem;}
.fab-btn{width:36px;height:36px;font-size:0.8rem;}
.nav-panel{top:3rem;left:0.5rem;width:180px;}
.sr-toggle{padding:0.75rem 1rem;min-height:44px;display:inline-flex;align-items:center;}
.mermaid-container{padding:1rem;max-height:50vh;}
.diagram-hint{display:block;}
}
@media(max-width:480px){
body{font-size:1rem;padding-top:44px;}
.wiki-container{padding:0 0.625rem 1.5rem;}
.hero{padding:2rem 0.75rem 1.5rem;}
.hero h1{font-size:1.5rem;}
.hero-subtitle{font-size:0.875rem;}
.section-title{font-size:1.2rem;}
.card-title{font-size:0.9375rem;padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.75rem;}
.top-toolbar{padding:0.25rem 0.5rem;}
.fab-btn{width:36px;height:36px;font-size:0.75rem;}
.nav-panel{top:2.75rem;left:0.5rem;width:min(170px,calc(100vw - 1rem));}
.hero-meta{gap:0.5rem;}
.collapsible-body{padding:0.75rem;}
.diagram-zoom-btn{width:44px;height:44px;}
.qa-content{padding:0 1rem 1rem;}
.section{scroll-margin-top:3.5rem;}
th{white-space:normal;word-break:break-word;}
.footer{padding:2rem 1rem;}
}
@media(max-width:375px){.wiki-container{padding:0 0.5rem 1.5rem;}.qa-content{padding:0 0.75rem 0.75rem;}}
@media(max-width:360px){
  .top-toolbar{padding:0.25rem 0.25rem;}
  .toolbar-left,.toolbar-right{gap:0.25rem;}
  .fab-btn{width:32px;height:32px;font-size:0.7rem;}
  .fab-back{width:32px;height:32px;margin-left:0.25rem;}
  .scroll-percent{min-width:1.75rem;font-size:0.6rem;}
}
.macos-window{background:#1a1a2e;border-radius:0.75rem;border:1px solid rgba(255,255,255,0.08);overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.5);margin-bottom:1.5rem;max-width:100%;margin-left:auto;margin-right:auto;}
@media(min-width:1025px){.macos-window{max-width:85%;}}
.macos-titlebar{background:#2d2d3f;padding:0.75rem 1rem;display:flex;align-items:center;gap:0.5rem;border-bottom:1px solid rgba(255,255,255,0.05);}
.dot{width:12px;height:12px;border-radius:50%;}
.dot-red{background:#ff5f57;}.dot-yellow{background:#ffbd2e;}.dot-green{background:#28c840;}
.macos-filename{margin-left:0.75rem;font-size:0.8rem;color:#6b7280;font-family:'JetBrains Mono',monospace;}
.macos-body{padding:1.25rem 1.5rem;max-height:400px;overflow-y:auto;overflow-x:auto;overscroll-behavior:contain;}
.macos-body::-webkit-scrollbar{width:6px;}
.macos-body::-webkit-scrollbar-track{background:rgba(30,41,59,0.5);border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb{background:#475569;border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb:hover{background:#64748b;}
.macos-body pre{margin:0;padding:0;background:transparent;overflow-x:auto;}
.macos-body pre code{display:block!important;font-family:'JetBrains Mono',monospace;font-size:0.9rem;line-height:1.6;background:transparent!important;}
.callout{border-radius:0.75rem;padding:1.25rem 1.5rem;border-left:4px solid;margin:1rem 0;}
.callout-danger{background:rgba(239,68,68,0.08);border-color:var(--accent-red);}
.callout-success{background:rgba(16,185,129,0.08);border-color:var(--accent-green);}
.callout-info{background:rgba(59,130,246,0.08);border-color:var(--accent-blue);}
.callout-warning{background:rgba(245,158,11,0.08);border-color:var(--accent-yellow);}
.callout-title{font-weight:700;font-size:0.9rem;text-transform:uppercase;letter-spacing:0.05em;margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;}
.callout-danger .callout-title{color:var(--accent-red);}
.callout-success .callout-title{color:var(--accent-green);}
.callout-info .callout-title{color:var(--accent-blue);}
.callout-warning .callout-title{color:var(--accent-yellow);}
.table-wrapper{overflow-x:auto;border-radius:0.75rem;border:1px solid var(--border-color);margin-bottom:1.5rem;}
table{width:100%;border-collapse:collapse;}
thead{background:rgba(59,130,246,0.1);}
th{padding:0.875rem 1.25rem;text-align:left;font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);white-space:nowrap;}
td{padding:0.875rem 1.25rem;border-top:1px solid var(--border-color);font-size:0.9rem;vertical-align:top;}
tr:hover td{background:rgba(255,255,255,0.02);}
:not(pre)>code{font-family:'JetBrains Mono',monospace;font-size:max(0.75rem,0.85em);background:rgba(59,130,246,0.12);padding:0.15rem 0.4rem;border-radius:0.3rem;color:#93c5fd;display:inline;overflow-wrap:break-word;word-break:break-all;white-space:pre-wrap;border:1px solid rgba(59,130,246,0.15);line-height:1;vertical-align:baseline;}
/* Custom syntax highlighting (replaces highlight.js CDN stylesheet) */
pre code.hljs{display:block;overflow-x:auto;padding:1em;}
.hljs{color:#abb2bf;background:transparent;}
.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic;}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd;}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75;}
.hljs-literal{color:#56b6c2;}
.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379;}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66;}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee;}
.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b;}
.hljs-emphasis{font-style:italic;}
.hljs-strong{font-weight:700;}
.badge{display:inline-flex;align-items:center;padding:0.2rem 0.6rem;border-radius:0.375rem;font-size:0.75rem;font-weight:700;}
.badge-blue{background:rgba(59,130,246,0.15);color:#93c5fd;}
.badge-green{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.badge-red{background:rgba(239,68,68,0.15);color:#fca5a5;}
.badge-yellow{background:rgba(245,158,11,0.15);color:#fcd34d;}
.badge-purple{background:rgba(139,92,246,0.15);color:#c4b5fd;}
.comparison-grid{display:grid;grid-template-columns:1fr auto 1fr;gap:1rem;align-items:start;}
.comparison-panel{border-radius:0.75rem;overflow:hidden;border:1px solid;padding-bottom:1rem;}
.comparison-panel>.macos-body,.comparison-panel>div:not(.comparison-header){padding-left:1.25rem;padding-right:1.25rem;}
.comparison-panel.bad{border-color:rgba(239,68,68,0.3);}
.comparison-panel.good{border-color:rgba(16,185,129,0.3);}
.comparison-header{padding:1rem 1.5rem;font-weight:700;display:flex;align-items:center;gap:0.5rem;}
.comparison-panel.bad .comparison-header{background:rgba(239,68,68,0.15);color:#fca5a5;}
.comparison-panel.good .comparison-header{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.vs-badge{width:3rem;height:3rem;border-radius:50%;background:linear-gradient(135deg,#ef4444,#3b82f6);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:0.875rem;align-self:center;justify-self:center;box-shadow:0 0 20px rgba(59,130,246,0.4);flex-shrink:0;margin-top:3rem;}
@media(max-width:900px){.comparison-grid{grid-template-columns:1fr;}.vs-badge{margin-top:0.5rem;margin-bottom:0.5rem;}}
.qa-item{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.qa-header{padding:1.25rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:flex-start;gap:1rem;transition:background 0.2s;}
.qa-header:hover{background:rgba(255,255,255,0.03);}
.qa-question{font-weight:700;font-size:1rem;color:var(--text-primary);}
.qa-meta{font-size:0.8rem;color:var(--text-muted);margin-top:0.25rem;}
.qa-chevron{color:var(--text-muted);transition:transform 0.3s;flex-shrink:0;margin-top:0.25rem;}
.qa-item.active .qa-chevron{transform:rotate(180deg);}
.qa-body{max-height:0;overflow:hidden;transition:max-height 0.5s ease;}
.qa-item.active .qa-body{max-height:6000px;}
.qa-content{padding:0 1.5rem 1.5rem;}
.qa-think{background:rgba(139,92,246,0.08);border-left:3px solid var(--accent-purple);border-radius:0.5rem;padding:1rem 1.25rem;margin-bottom:1rem;font-style:italic;font-size:0.95rem;color:#c4b5fd;}
.qa-think strong{color:var(--accent-purple);font-style:normal;}
.qa-great{background:rgba(16,185,129,0.08);border-left:3px solid var(--accent-green);border-radius:0.5rem;padding:1rem 1.25rem;margin-top:1rem;font-size:0.95rem;color:#6ee7b7;}
.qa-great strong{color:var(--accent-green);}
.collapsible{border:1px solid var(--border-color);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.collapsible-header{padding:1rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,0.02);transition:background 0.2s;}
.collapsible-header:hover{background:rgba(255,255,255,0.05);}
.collapsible-chevron{color:var(--text-muted);transition:transform 0.3s;}
.collapsible.active .collapsible-chevron{transform:rotate(180deg);}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height 0.4s ease;}
.collapsible.active .collapsible-content{max-height:10000px;}
.collapsible-body{padding:1.5rem;border-top:1px solid var(--border-color);}
@media(max-width:768px){.collapsible-body{padding:1rem;}}
ul.styled{list-style:none;padding:0;}
ul.styled li{padding:0.5rem 0 0.5rem 1.5rem;position:relative;color:var(--text-secondary);font-size:0.95rem;border-bottom:1px solid rgba(255,255,255,0.04);}
ul.styled li:last-child{border-bottom:none;}
ul.styled li::before{content:'â–¸';position:absolute;left:0;color:var(--accent-blue);font-size:0.8rem;top:0.6rem;}
ul.styled.green li::before{color:var(--accent-green);}
ul.styled.red li::before{color:var(--accent-red);content:'âœ—';}
.tab-container{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;overflow:hidden;margin-bottom:1.5rem;}
.tab-header{display:flex;background:rgba(0,0,0,0.2);border-bottom:1px solid var(--border-color);overflow-x:auto;}
.tab-btn{padding:0.75rem 1.25rem;cursor:pointer;font-size:0.85rem;font-weight:600;color:var(--text-muted);border-bottom:2px solid transparent;white-space:nowrap;transition:color 0.2s,border-color 0.2s;background:none;border-top:none;border-left:none;border-right:none;}
.tab-btn.active{color:var(--accent-blue);border-bottom-color:var(--accent-blue);}
.tab-btn:hover{color:var(--text-primary);}
.tab-panel{display:none;padding:1.5rem;}
.tab-panel.active{display:block;}
@media(max-width:768px){.tab-btn{padding:0.875rem 1rem;min-height:44px;}.tab-panel{padding:1rem;}}
.cheat-card{background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:0.75rem;padding:1.25rem;transition:border-color 0.2s,transform 0.2s;min-width:0;overflow:hidden;}
.cheat-card pre{overflow-x:auto;}
.cheat-card:hover{border-color:var(--accent-blue);}
.cheat-card-title{font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-muted);margin-bottom:0.75rem;}
.cheat-card-body{font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:#a5f3fc;line-height:1.5;}
.footer{text-align:center;padding:3rem 2rem;color:var(--text-muted);border-top:1px solid var(--border-color);margin-top:4rem;font-size:0.875rem;}
.mermaid-container{background:rgba(15,23,42,0.95);border:1px solid rgba(59,130,246,0.3);border-radius:12px;padding:2rem 1.5rem;margin:1rem 0;overflow:auto;overscroll-behavior:contain;-webkit-overflow-scrolling:touch;box-shadow:0 0 20px rgba(59,130,246,0.08);max-height:60vh;touch-action:pan-x pan-y;position:relative;max-width:100%;}
.diagram-zoom-controls{position:absolute;top:0.5rem;right:0.5rem;display:flex;gap:0.25rem;z-index:5;}
.diagram-zoom-btn{width:30px;height:30px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(15,23,42,0.9);color:#93c5fd;font-size:0.75rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:background-color 0.2s,color 0.2s;-webkit-tap-highlight-color:transparent;}
.diagram-zoom-btn:hover{background:rgba(59,130,246,0.2);color:#fff;}
@media(max-width:1024px){.diagram-zoom-btn{width:44px;height:44px;}}
.mermaid-container .mermaid{display:flex;justify-content:center;min-width:fit-content;}
.mermaid-container .mermaid svg{height:auto;}
.diagram-hint{display:none;position:absolute;bottom:0.5rem;right:0.75rem;font-size:0.6875rem;color:var(--text-muted);background:rgba(15,23,42,0.85);padding:0.2rem 0.5rem;border-radius:4px;pointer-events:none;}
/* Collapsible diagram toggle */
.diagram-toggle{display:flex;align-items:center;gap:0.5rem;padding:0.6rem 1rem;margin:0.75rem 0;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:0.5rem;cursor:pointer;color:#93c5fd;font-size:0.875rem;font-weight:600;user-select:none;-webkit-tap-highlight-color:transparent;transition:background-color 0.2s,border-color 0.2s;min-height:44px;}
.diagram-toggle:hover{background:rgba(59,130,246,0.15);border-color:var(--accent-blue);}
.diagram-toggle .chevron{font-size:0.7rem;transition:transform 0.3s;margin-left:auto;color:var(--text-muted);}
.diagram-toggle.open .chevron{transform:rotate(180deg);}
.mermaid-container.collapsed{max-height:0;overflow:hidden;padding:0;margin:0;border:none;box-shadow:none;}
/* Class diagram colors */
.mermaid .classGroup rect{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid .classGroup .label{fill:#f1f5f9!important;font-weight:600!important;}
.mermaid .classLabel .label{fill:#93c5fd!important;}
.mermaid .classTitle{font-weight:700!important;fill:#60a5fa!important;font-size:16px!important;}
.mermaid .classTitleText{fill:#60a5fa!important;font-size:16px!important;font-weight:700!important;}
.mermaid .relation{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .cardinality{fill:#94a3b8!important;}
.mermaid defs marker path{fill:#60a5fa!important;stroke:#60a5fa!important;}
/* Sequence diagram colors */
.mermaid .actor-line{stroke:#3b82f6!important;stroke-width:2px!important;stroke-dasharray:4;}
.mermaid .actor{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid text.actor>tspan{fill:#e2e8f0!important;font-weight:600!important;}
.mermaid .messageLine0,.mermaid .messageLine1{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .messageText{fill:#f1f5f9!important;font-weight:500!important;}
.mermaid .note{fill:#2d1b4e!important;stroke:#8b5cf6!important;stroke-width:1.5px!important;}
.mermaid .noteText>tspan{fill:#e2e8f0!important;}
.mermaid .activation0,.mermaid .activation1,.mermaid .activation2{fill:#1e3a5f!important;stroke:#3b82f6!important;}
.mermaid .loopText>tspan{fill:#94a3b8!important;}
.mermaid .loopLine{stroke:#334155!important;}
/* Flowchart node text */
.mermaid .nodeLabel{color:#f1f5f9!important;font-weight:500!important;}
.mermaid .edgeLabel{background:#1e293b!important;color:#94a3b8!important;}
.mermaid .label{color:#f1f5f9!important;}
h3.sub{font-size:1.1rem;font-weight:700;margin:1.5rem 0 0.75rem;color:var(--text-primary);}
p.body-text{color:var(--text-secondary);font-size:0.95rem;margin-bottom:0.75rem;}
.two-col{display:grid;grid-template-columns:1fr 1fr;gap:1.25rem;margin-top:1rem;}
@media(max-width:900px){.two-col{grid-template-columns:1fr;}}
.two-col pre{margin:0;background:#1a1a2e;border-radius:0 0 0.75rem 0.75rem;border:1px solid rgba(255,255,255,0.08);border-top:none;overflow-x:auto;}
.two-col pre code{display:block;font-family:'JetBrains Mono',monospace;font-size:0.8rem;line-height:1.6;padding:1rem 1.25rem;background:transparent!important;color:#e2e8f0;}
.two-col .callout{margin:0;border-radius:0.75rem 0.75rem 0 0;padding:0.6rem 1rem;}
@media(prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:0.01ms!important;transition-duration:0.01ms!important;}html{scroll-behavior:auto;}}
@media(hover:hover){
  .fab-btn:hover{transform:scale(1.08);}
  .cheat-card:hover{transform:translateY(-2px);}
  .nav-panel a:hover{background:rgba(59,130,246,0.15);color:#fff;}
}
</style>
</head>
<body>

<div class="hero">
  <div style="position:relative;z-index:1;">
    <div class="hero-badge"><i class="fa-solid fa-industry"></i> GoF Creational Pattern</div>
    <h1>Factory Method Design Pattern</h1>
    <p class="hero-subtitle">Let subclasses decide which object to create â€” because hardcoding <code style="-webkit-text-fill-color:#93c5fd;background:rgba(255,255,255,0.1);padding:0.1rem 0.4rem;border-radius:0.3rem;font-size:0.8rem;">new</code> is the first step toward a maintenance nightmare.</p>
    <div class="hero-meta">
      <span><i class="fa-solid fa-layer-group"></i> Creational Pattern</span>
      <span><i class="fa-brands fa-microsoft"></i> C# / .NET</span>
      <span><i class="fa-solid fa-list-check"></i> 25 Interview Q&amp;As</span>
      <span><i class="fa-solid fa-bug"></i> 3 Bug Case Studies</span>
      <span><i class="fa-solid fa-shield-halved"></i> 7 Pitfalls</span>
    </div>
  </div>
</div>

<div class="wiki-container">

<!-- Top toolbar â€” all controls in one horizontal bar -->
<div class="top-toolbar">
  <div class="toolbar-left">
    <button class="fab-btn" id="navFab" title="Navigate sections"><i class="fa-solid fa-compass"></i></button>
    <button class="fab-btn" id="expandAllBtn" title="Expand all cards"><i class="fa-solid fa-angles-down"></i></button>
    <button class="fab-btn" id="fullscreenBtn" title="Toggle fullscreen"><i class="fa-solid fa-expand"></i></button>
  </div>
  <div class="toolbar-right">
    <button class="fab-btn" id="scrollUp" title="Scroll up"><i class="fa-solid fa-chevron-up"></i></button>
    <span class="scroll-percent" id="percentText">0%</span>
    <button class="fab-btn" id="scrollDown" title="Scroll down"><i class="fa-solid fa-chevron-down"></i></button>
    <a href="../index.html" class="fab-btn fab-back" title="Back to Pattern Playbook"><i class="fa-solid fa-arrow-left"></i></a>
  </div>
</div>
<div class="nav-panel" id="navPanel">
  <div class="nav-panel-title">Jump to Section</div>
  <a href="#s3"><i class="fa-solid fa-lightbulb"></i> Analogies</a>
  <a href="#s4"><i class="fa-solid fa-diagram-project"></i> Core Pattern</a>
  <a href="#s5"><i class="fa-solid fa-graduation-cap"></i> Jr vs Sr</a>
  <a href="#s6"><i class="fa-solid fa-code"></i> Implementations</a>
  <a href="#s10"><i class="fa-solid fa-bug"></i> Bug Studies</a>
  <a href="#s12"><i class="fa-solid fa-cubes"></i> SOLID</a>
  <a href="#s13"><i class="fa-solid fa-scale-balanced"></i> Comparisons</a>
  <a href="#s14"><i class="fa-solid fa-comments"></i> Interview Q&amp;As</a>
  <a href="#s15"><i class="fa-solid fa-compass-drafting"></i> When To Use</a>
  <a href="#s16"><i class="fa-solid fa-triangle-exclamation"></i> Pitfalls</a>
  <a href="#s18"><i class="fa-solid fa-bolt"></i> Cheat Sheet</a>
</div>

<!-- ============================================================ SECTION 3 -->
<section id="s3" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-lightbulb"></i></div>
    <div><div class="section-num">Section 3</div><h2 class="section-title">Real-World Analogies</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-pizza-slice" style="color:var(--accent-blue)"></i> The Pizza Shop â€” Deep Mapping</div>
    <p class="body-text">Imagine you walk into a pizza chain like Domino's and say: "I want a large pepperoni pizza." You don't go into the kitchen, pick the dough, fire up the oven, or slice the cheese yourself. You just ORDER it. The shop decides HOW to make it. If you go to a different branch â€” maybe one in New York vs one in Chicago â€” you'll say the same words ("large pepperoni"), but each branch makes it their own way (thin crust vs deep dish). You don't care HOW they make it. You just want your pizza.</p>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Pizza Shop World</th><th>What It Means in Code</th></tr></thead>
        <tbody>
          <tr>
            <td><strong>The menu</strong> â€” says "we serve pizzas" but doesn't say how each branch makes them</td>
            <td><strong>Creator (abstract class)</strong> â€” defines a method <code>CreateProcessor()</code> but lets each subclass decide what to return</td>
          </tr>
          <tr>
            <td><strong>New York branch</strong> â€” makes thin-crust style pizza when you order</td>
            <td><strong>ConcreteCreator</strong> (e.g., <code>StripeProcessorFactory</code>) â€” returns a specific implementation</td>
          </tr>
          <tr>
            <td><strong>"A pizza"</strong> â€” the general idea of what you're ordering</td>
            <td><strong>Product (interface)</strong> â€” the contract: <code>IPaymentProcessor</code> with methods like <code>Process()</code>, <code>Refund()</code></td>
          </tr>
          <tr>
            <td><strong>The actual thin-crust pepperoni you receive</strong> â€” the real thing in your hand</td>
            <td><strong>ConcreteProduct</strong> (e.g., <code>StripePaymentProcessor</code>) â€” the actual object that does the work</td>
          </tr>
          <tr>
            <td><strong>Opening a Chicago branch</strong> â€” new style, zero changes to the menu or other branches</td>
            <td><strong>Open/Closed Principle</strong> â€” add <code>PayPalProcessorFactory</code> without touching existing code</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-circle-check"></i> Why This Analogy Works</div>
      <ul class="styled green">
        <li>You (the customer) never go into the kitchen â€” your code never uses <code>new StripeProcessor()</code> directly</li>
        <li>Every branch follows the same menu â€” every factory returns something that implements the same interface</li>
        <li>Adding a new branch doesn't change existing branches â€” adding a new factory doesn't change existing ones</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-quote-left" style="color:var(--accent-purple)"></i> Six Quick Analogies</div>
    <div class="grid-2">
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-box"></i> Vending Machine</div>You press "B3" for a Coke. The machine decides which slot to dispense from. You asked for "a drink," the machine figured out the rest. Same button layout, different drinks inside.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-car"></i> Uber Ride</div>You tap "Request Ride." Uber picks the driver and car â€” could be a Toyota, Honda, or Tesla. You asked for "a ride" (interface), Uber (factory) picked the specific car (concrete product).</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-money-bill"></i> ATM Withdrawal</div>You insert your card and say "Give me $100." The ATM doesn't care if it's Bank of America or Chase behind the scenes â€” it gives you cash. Different banks, same withdrawal experience.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-language"></i> Google Translate</div>You type "Hello" and pick "Spanish." Google picks the right translation engine for that language pair. You asked for "translate this" (interface), it handled the specifics.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-tv"></i> Streaming a Movie</div>You click "Play" on Netflix. Behind the scenes, it picks the right video codec, resolution, and CDN server based on your device and internet speed. You just said "play" â€” Netflix decided HOW.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-mug-hot"></i> Ordering a Coffee</div>You tell the barista "large latte." They decide whether to use the new espresso machine or the old one, which milk brand to use, and what cup size "large" means at this location. Same order, different execution per shop.</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-briefcase" style="color:var(--accent-green)"></i> Six Real-World Use Cases</div>
    <div class="grid-2">
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-blue);margin-bottom:0.4rem;"><i class="fa-solid fa-credit-card"></i> 1. Payment Processing</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Stripe, PayPal, and Square all work differently behind the scenes. A factory picks the right one based on the customer's choice â€” your checkout code stays the same.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-cyan);margin-bottom:0.4rem;"><i class="fa-solid fa-database"></i> 2. Database Connections</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">PostgreSQL, MySQL, and SQL Server each need different connection logic. A factory creates the right connection object â€” your data-access code doesn't care which database is behind it.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-purple);margin-bottom:0.4rem;"><i class="fa-solid fa-cloud"></i> 3. Cloud Storage</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">AWS S3, Azure Blob, and Google Cloud Storage all have different APIs. A factory picks the right one based on config â€” your upload/download code works the same everywhere.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.4rem;"><i class="fa-solid fa-bell"></i> 4. Sending Notifications</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Email via SendGrid, SMS via Twilio, push via Firebase â€” all different. A factory creates the right sender â€” your notification code just calls <code>Send()</code>.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-yellow);margin-bottom:0.4rem;"><i class="fa-solid fa-key"></i> 5. Login Providers</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Google login, Facebook login, GitHub login â€” each uses different authentication flows. A factory creates the right login handler â€” your app just calls <code>Authenticate()</code>.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.4rem;"><i class="fa-solid fa-file-export"></i> 6. Document Export</div>
        <p style="font-size:0.9rem;color:var(--text-secondary);">Export as PDF, Excel, or CSV â€” each format needs different generation logic. A factory creates the right exporter â€” your report code just calls <code>Export(data)</code>.</p>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 4 -->
<section id="s4" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-diagram-project"></i></div>
    <div><div class="section-num">Section 4</div><h2 class="section-title">Core Pattern &amp; UML</h2></div>
  </div>

  <div class="callout callout-info">
    <div class="callout-title"><i class="fa-solid fa-book"></i> GoF Formal Definition</div>
    <p style="font-style:italic;font-size:1.05rem;">"Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses."</p>
    <div class="table-wrapper" style="margin-top:1rem;">
      <table>
        <thead><tr><th>Phrase</th><th>What It Actually Means</th></tr></thead>
        <tbody>
          <tr>
            <td><strong>"Define an interface for creating an object"</strong></td>
            <td>The abstract Creator declares a method â€” <code>CreateProcessor()</code> â€” that returns a Product interface. The <em>how</em> of creation is deliberately left undefined at this level. This gives the system a stable creation contract without coupling to any concrete type.</td>
          </tr>
          <tr>
            <td><strong>"but let subclasses decide which class to instantiate"</strong></td>
            <td>Each ConcreteCreator overrides the factory method to return its specific product. <code>StripeProcessorFactory</code> returns <code>new StripePaymentProcessor()</code>. <code>PayPalProcessorFactory</code> returns <code>new PayPalPaymentProcessor()</code>. The decision lives in the subclass, not in any conditional logic.</td>
          </tr>
          <tr>
            <td><strong>"Factory Method lets a class defer instantiation to subclasses"</strong></td>
            <td>The Creator's business logic (e.g., <code>ProcessPayment()</code>) uses the product returned by <code>CreateProcessor()</code> without knowing which concrete type it is. The Creator is "complete" at the abstract level â€” it just defers <em>which</em> product to create down the hierarchy.</td>
          </tr>
          <tr>
            <td><strong>The structural result</strong></td>
            <td>Two parallel class hierarchies emerge: Creator hierarchy (abstract factory + concrete factories) mirrors the Product hierarchy (interface + concrete products). Each pair â€” <code>StripeProcessorFactory</code> + <code>StripePaymentProcessor</code> â€” is cohesive, isolated, and independently extensible.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <h3 class="sub">The Four Participants</h3>
  <div class="grid-2" style="margin-bottom:1.5rem;">
    <div style="padding:1rem;border:1px solid rgba(59,130,246,0.2);border-radius:0.75rem;background:rgba(59,130,246,0.05);">
      <div style="font-weight:700;color:var(--accent-blue);margin-bottom:0.5rem;font-size:0.95rem;"><i class="fa-solid fa-shapes"></i> Product â€” IPaymentProcessor</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">The interface or abstract class that all concrete products implement. Defines the operations the client code will use. In our domain: <code>IPaymentProcessor</code> with <code>ProcessAsync()</code>, <code>RefundAsync()</code>, and <code>ValidateAsync()</code>. Client code only ever sees this type â€” it is shielded from all concrete implementations.</p>
    </div>
    <div style="padding:1rem;border:1px solid rgba(139,92,246,0.2);border-radius:0.75rem;background:rgba(139,92,246,0.05);">
      <div style="font-weight:700;color:var(--accent-purple);margin-bottom:0.5rem;font-size:0.95rem;"><i class="fa-solid fa-cube"></i> ConcreteProduct â€” StripePaymentProcessor</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">Implements the Product interface with provider-specific logic. Knows about Stripe's SDK, error codes, retry rules, and webhook format. Is entirely isolated â€” <code>PayPalPaymentProcessor</code> has zero knowledge of Stripe's implementation details, and vice versa. Adding a new provider never touches existing ConcreteProducts.</p>
    </div>
    <div style="padding:1rem;border:1px solid rgba(16,185,129,0.2);border-radius:0.75rem;background:rgba(16,185,129,0.05);">
      <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;font-size:0.95rem;"><i class="fa-solid fa-building-columns"></i> Creator â€” PaymentProcessorFactory</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">Abstract class that declares the factory method <code>CreateProcessor()</code> and defines the workflow template (Template Method pattern). Contains business logic that uses the product â€” e.g., <code>ProcessPayment()</code> which calls <code>CreateProcessor()</code> then uses its result. Creator is "complete" minus the creation decision.</p>
    </div>
    <div style="padding:1rem;border:1px solid rgba(245,158,11,0.2);border-radius:0.75rem;background:rgba(245,158,11,0.05);">
      <div style="font-weight:700;color:var(--accent-yellow);margin-bottom:0.5rem;font-size:0.95rem;"><i class="fa-solid fa-industry"></i> ConcreteCreator â€” StripeProcessorFactory</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">Overrides <code>CreateProcessor()</code> to return the specific concrete product. Is the only class that references <code>new StripePaymentProcessor()</code> â€” this coupling is intentional and fully contained. Inherits all the Creator's workflow logic for free. Adding a new provider means adding one new ConcreteCreator class, nothing more.</p>
    </div>
  </div>

  <h3 class="sub">UML Class Diagram â€” Payment Processing Domain</h3>
  <div class="mermaid-container">
    <span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
    <div class="mermaid">
classDiagram
    class IPaymentProcessor {
        &lt;&lt;interface&gt;&gt;
        +ProcessAsync(request PaymentRequest) Task~PaymentResult~
        +RefundAsync(transactionId string) Task~RefundResult~
        +ValidateAsync(request PaymentRequest) Task~bool~
        +GetSupportedCurrencies() List~string~
    }
    class StripePaymentProcessor {
        -_stripeClient StripeClient
        -_webhookSecret string
        +ProcessAsync(request PaymentRequest) Task~PaymentResult~
        +RefundAsync(transactionId string) Task~RefundResult~
        +ValidateAsync(request PaymentRequest) Task~bool~
        +GetSupportedCurrencies() List~string~
    }
    class PayPalPaymentProcessor {
        -_paypalClient PayPalHttpClient
        -_clientId string
        +ProcessAsync(request PaymentRequest) Task~PaymentResult~
        +RefundAsync(transactionId string) Task~RefundResult~
        +ValidateAsync(request PaymentRequest) Task~bool~
        +GetSupportedCurrencies() List~string~
    }
    class SquarePaymentProcessor {
        -_squareClient SquareClient
        +ProcessAsync(request PaymentRequest) Task~PaymentResult~
        +RefundAsync(transactionId string) Task~RefundResult~
        +ValidateAsync(request PaymentRequest) Task~bool~
        +GetSupportedCurrencies() List~string~
    }
    class ApplePayProcessor {
        -_merchantId string
        -_domainVerification string
        +ProcessAsync(request PaymentRequest) Task~PaymentResult~
        +RefundAsync(transactionId string) Task~RefundResult~
        +ValidateAsync(request PaymentRequest) Task~bool~
        +GetSupportedCurrencies() List~string~
    }
    class PaymentProcessorFactory {
        &lt;&lt;abstract&gt;&gt;
        +CreateProcessor() IPaymentProcessor
        +ProcessPayment(request PaymentRequest) Task~PaymentResult~
        +IssueRefund(transactionId string) Task~RefundResult~
    }
    class StripeProcessorFactory {
        -_config StripeConfig
        +CreateProcessor() IPaymentProcessor
    }
    class PayPalProcessorFactory {
        -_config PayPalConfig
        +CreateProcessor() IPaymentProcessor
    }
    class SquareProcessorFactory {
        -_config SquareConfig
        +CreateProcessor() IPaymentProcessor
    }
    class ApplePayProcessorFactory {
        -_config ApplePayConfig
        +CreateProcessor() IPaymentProcessor
    }
    class PaymentController {
        -_factory PaymentProcessorFactory
        +Charge(request PaymentRequest) Task~IActionResult~
    }

    IPaymentProcessor <|.. StripePaymentProcessor : implements
    IPaymentProcessor <|.. PayPalPaymentProcessor : implements
    IPaymentProcessor <|.. SquarePaymentProcessor : implements
    IPaymentProcessor <|.. ApplePayProcessor : implements
    PaymentProcessorFactory <|-- StripeProcessorFactory : extends
    PaymentProcessorFactory <|-- PayPalProcessorFactory : extends
    PaymentProcessorFactory <|-- SquareProcessorFactory : extends
    PaymentProcessorFactory <|-- ApplePayProcessorFactory : extends
    StripeProcessorFactory ..> StripePaymentProcessor : creates
    PayPalProcessorFactory ..> PayPalPaymentProcessor : creates
    SquareProcessorFactory ..> SquarePaymentProcessor : creates
    ApplePayProcessorFactory ..> ApplePayProcessor : creates
    PaymentController --> PaymentProcessorFactory : uses
    </div>
  </div>

  <h3 class="sub" style="margin-top:2rem;">Sequence Diagram â€” Runtime Flow</h3>
  <div class="mermaid-container">
    <span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
    <div class="mermaid">
sequenceDiagram
    participant C as PaymentController
    participant F as StripeProcessorFactory
    participant B as PaymentProcessorFactory (base)
    participant P as StripePaymentProcessor
    participant S as Stripe API

    C->>F: ProcessPayment(request)
    Note over F,B: Calls base class template method
    F->>B: base.ProcessPayment(request)
    B->>F: CreateProcessor()
    Note over F: Override returns concrete product
    F-->>B: returns StripePaymentProcessor instance
    B->>P: ValidateAsync(request)
    P-->>B: true (validation passed)
    B->>P: ProcessAsync(request)
    P->>S: POST /v1/charges (Stripe SDK)
    S-->>P: ChargeResponse (200 OK)
    P-->>B: PaymentResult { Success, TransactionId }
    B-->>C: PaymentResult { Success, TransactionId }
    Note over C: Controller never touched StripePaymentProcessor directly
    </div>
  </div>

  <div class="callout callout-info" style="margin-top:1.5rem;">
    <div class="callout-title"><i class="fa-solid fa-magnifying-glass"></i> Key Structural Observations</div>
    <p style="color:var(--text-secondary);margin-bottom:0.75rem;"><strong>Two parallel hierarchies:</strong> Factory Method produces two mirrored class trees. The Creator hierarchy (<code>PaymentProcessorFactory</code> base, four concrete factory subclasses) exactly mirrors the Product hierarchy (<code>IPaymentProcessor</code> interface, four concrete processor implementations). Each pair is cohesive and travels together â€” add <code>KlarnaProcessorFactory</code>, you also add <code>KlarnaPaymentProcessor</code>.</p>
    <p style="color:var(--text-secondary);margin-bottom:0.75rem;"><strong>Template Method connection:</strong> The abstract Creator's <code>ProcessPayment()</code> is a Template Method â€” it defines the algorithm skeleton (validate, then process, then log) while deferring the product creation step to <code>CreateProcessor()</code>. Factory Method is frequently implemented via Template Method at the Creator level. The two patterns are structurally coupled here.</p>
    <p style="color:var(--text-secondary);"><strong>Where coupling lives:</strong> The <em>only</em> place that references <code>new StripePaymentProcessor()</code> is <code>StripeProcessorFactory.CreateProcessor()</code>. The Controller, the base factory, the interface â€” all are Stripe-free. This is intentional tight coupling at the factory level, freeing everything else. The coupling is contained, named, and obvious.</p>
  </div>
</section>

<!-- ============================================================ SECTION 5 -->
<section id="s5" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-graduation-cap"></i></div>
    <div><div class="section-num">Section 5</div><h2 class="section-title">Junior vs Senior Thinking</h2></div>
  </div>

  <!-- SCENARIO A -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-cloud" style="color:var(--accent-blue)"></i> Scenario A â€” Add a New Cloud Storage Provider</div>
    <p class="body-text">Your <strong>SaaS</strong> (Software-as-a-Service â€” a product sold online as a subscription) platform stores user documents on AWS S3. The VP of Engineering says EU customers require Azure Blob Storage for <strong>GDPR data residency</strong> (a European privacy law requiring EU customer data to be stored on servers physically in Europe), and your largest enterprise client insists on Google Cloud Storage to match their existing infrastructure. How you handle this reveals your entire architecture philosophy.</p>

    <h3 class="sub">Context: The Requirement</h3>
    <p class="body-text"><strong>Sprint planning</strong> (a team meeting every 1-2 weeks to assign upcoming work) drops this on your desk: "Support S3 (existing), Azure Blob (EU region), and GCS (enterprise tier). Documents must upload, download, delete, and generate <strong>presigned URLs</strong> (temporary links that let someone download a private file for a limited time without needing a login) regardless of provider. New providers may be added quarterly as we expand to new markets."</p>

    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> Junior Approach â€” The Hardcoded Nightmare</div>
        <div class="macos-body" style="max-height:480px;"><pre><code class="language-csharp">// DocumentService.cs â€” Junior's first pass
public class DocumentService
{
    private readonly string _provider;
    private readonly AmazonS3Client _s3Client;
    private readonly BlobServiceClient _azureClient;
    private readonly StorageClient _gcsClient;

    public DocumentService(IConfiguration config)
    {
        _provider = config["Storage:Provider"]; // "S3" / "Azure" / "GCS"

        // ALL providers initialized even if only one is used
        _s3Client = new AmazonS3Client(
            config["AWS:AccessKey"],
            config["AWS:SecretKey"],
            RegionEndpoint.USEast1);

        _azureClient = new BlobServiceClient(
            config["Azure:ConnectionString"]);

        _gcsClient = StorageClient.Create(
            GoogleCredential.FromFile(config["GCS:CredentialsPath"]));
    }

    public async Task&lt;string&gt; UploadAsync(string fileName, Stream content)
    {
        // String-based routing â€” typo = runtime crash
        if (_provider == "S3")
        {
            var request = new PutObjectRequest
            {
                BucketName = "my-bucket",
                Key = fileName,
                InputStream = content
            };
            await _s3Client.PutObjectAsync(request);
            return $"s3://my-bucket/{fileName}";
        }
        else if (_provider == "Azure")
        {
            var container = _azureClient.GetBlobContainerClient("docs");
            var blob = container.GetBlobClient(fileName);
            await blob.UploadAsync(content);
            return blob.Uri.ToString();
        }
        else if (_provider == "GCS")
        {
            await _gcsClient.UploadObjectAsync(
                "my-gcs-bucket", fileName, null, content);
            return $"gs://my-gcs-bucket/{fileName}";
        }
        throw new Exception("Unknown provider: " + _provider);
    }

    public async Task&lt;Stream&gt; DownloadAsync(string fileName)
    {
        // Same if/else block duplicated here
        if (_provider == "S3") { /* S3 download logic */ }
        else if (_provider == "Azure") { /* Azure download logic */ }
        else if (_provider == "GCS") { /* GCS download logic */ }
        throw new Exception("Unknown provider");
    }

    public async Task DeleteAsync(string fileName)
    {
        // Same if/else block duplicated again
        if (_provider == "S3") { /* S3 delete logic */ }
        else if (_provider == "Azure") { /* Azure delete logic */ }
        else if (_provider == "GCS") { /* GCS delete logic */ }
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> Senior Approach â€” Factory Method Architecture</div>
        <div class="macos-body" style="max-height:480px;"><pre><code class="language-csharp">// ICloudStorageProvider.cs
public interface ICloudStorageProvider
{
    Task&lt;string&gt; UploadAsync(string key, Stream content,
        string contentType = "application/octet-stream");
    Task&lt;Stream&gt; DownloadAsync(string key);
    Task DeleteAsync(string key);
    Task&lt;string&gt; GetPresignedUrlAsync(string key,
        TimeSpan expiry);
    Task&lt;bool&gt; ExistsAsync(string key);
}

// CloudStorageFactory.cs â€” abstract Creator
public abstract class CloudStorageFactory
{
    // Factory Method â€” subclasses decide which provider
    public abstract ICloudStorageProvider CreateProvider();

    // Template Method â€” uses the product
    public async Task&lt;UploadResult&gt; UploadDocumentAsync(
        string key, Stream content, string contentType)
    {
        var provider = CreateProvider();
        var url = await provider.UploadAsync(
            key, content, contentType);
        return new UploadResult(url, DateTime.UtcNow);
    }
}

// S3StorageFactory.cs
public class S3StorageFactory : CloudStorageFactory
{
    private readonly S3Config _config;
    public S3StorageFactory(S3Config config) =>
        _config = config;

    public override ICloudStorageProvider CreateProvider() =>
        new S3StorageProvider(_config);
}

// AzureBlobStorageFactory.cs
public class AzureBlobStorageFactory : CloudStorageFactory
{
    private readonly AzureConfig _config;
    public AzureBlobStorageFactory(AzureConfig config) =>
        _config = config;

    public override ICloudStorageProvider CreateProvider() =>
        new AzureBlobStorageProvider(_config);
}

// GcsStorageFactory.cs
public class GcsStorageFactory : CloudStorageFactory
{
    private readonly GcsConfig _config;
    public GcsStorageFactory(GcsConfig config) =>
        _config = config;

    public override ICloudStorageProvider CreateProvider() =>
        new GcsStorageProvider(_config);
}

// DocumentUploadService.cs â€” clean consumer
public class DocumentUploadService
{
    private readonly CloudStorageFactory _factory;

    public DocumentUploadService(CloudStorageFactory factory)
        => _factory = factory;

    public async Task&lt;string&gt; UploadUserDocumentAsync(
        Guid userId, string fileName, Stream content)
    {
        var key = $"users/{userId}/{fileName}";
        var result = await _factory.UploadDocumentAsync(
            key, content, "application/pdf");
        return result.PublicUrl;
    }
}</code></pre></div>
      </div>
    </div>

    <h3 class="sub">Why Junior's Approach Fails â€” 7 Problems</h3>
    <div class="jr-sr-list">
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-1"></i> Shotgun Surgery</div>When a fourth provider (MinIO for <strong>on-premise</strong> â€” servers in your own company's building, not in the cloud) is requested, you must open <code>DocumentService.cs</code> and add an <code>else if</code> branch in <em>every single method</em> â€” <code>UploadAsync</code>, <code>DownloadAsync</code>, <code>DeleteAsync</code>, <code>GetPresignedUrlAsync</code>. That is four surgical cuts in one class. Miss one method? Silent bug where MinIO delete calls GCS by <strong>fallthrough</strong> (no condition matches, so all branches are skipped and code crashes). This is called <strong>Shotgun Surgery</strong> â€” a single feature change forces edits in multiple places, making it easy to miss a spot.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> One File, One Concern</div>Adding MinIO means creating two files: <code>MinioStorageProvider.cs</code> and <code>MinioStorageFactory.cs</code>. Zero changes to existing provider files, zero changes to <code>DocumentUploadService</code>, zero changes to the base factory. This is the <strong>Open/Closed Principle</strong> (existing code should be untouchable; add new behavior by creating new files alongside it) in action â€” the system is open for extension by creating new files, closed for modification of existing ones.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-2"></i> All Providers Initialized</div>The constructor initializes <code>AmazonS3Client</code>, <code>BlobServiceClient</code>, AND <code>StorageClient</code> even when only one will ever be used. An EU deployment using Azure still establishes AWS <strong>SDK</strong> (Software Development Kit â€” a code library a cloud provider gives you to talk to their services) initialization, validates GCS credentials, and allocates memory for clients that will never process a single byte. This wastes memory, startup time, and may fail on credential validation for unused providers in <strong>CI/CD</strong> (Continuous Integration/Deployment â€” automated pipeline that builds and tests code on every push).<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Lazy, Targeted Initialization</div>Each factory only holds config for its own provider. <code>AzureBlobStorageFactory</code> has no knowledge of AWS credentials â€” it only reads <code>AzureConfig</code>. The <strong>DI container</strong> (the framework's built-in system that automatically creates and connects objects for you) registers the correct factory based on config using <strong>AddScoped</strong> (tells DI to create a new instance per HTTP request): <code>builder.Services.AddScoped&lt;CloudStorageFactory, AzureBlobStorageFactory&gt;()</code>. EU deployments never touch AWS SDK. Zero wasted initialization.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-3"></i> String-Based Routing</div><code>if (_provider == "S3")</code> is a string comparison at <strong>runtime</strong> (while the program is actually running and handling real requests). A config typo â€” "s3" instead of "S3", "azure" instead of "Azure" â€” silently falls through to the <code>throw new Exception</code> at the bottom. This crashes in <strong>production</strong> (the live environment your real users access) for your first EU customer. The error message "Unknown provider: azure" at 2AM is not a good look.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Type Safety at Compile Time</div>The factory is <strong>resolved</strong> (automatically looked up and created by the framework) by the DI container at startup â€” if the <strong>registration</strong> (telling the DI container which class to use for an interface) is wrong, the app fails to start (not at 2AM on the first customer request). <code>DocumentUploadService</code> accepts <code>CloudStorageFactory</code> â€” the <strong>compiler</strong> (the tool that converts your code into a runnable program) enforces the type. No strings, no typos, no runtime surprises. Invalid configurations surface during <strong>integration tests</strong> (tests that verify multiple components work together correctly), not in production.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-4"></i> No Testability</div>How do you write a <strong>unit test</strong> (a small test that checks one piece of logic in isolation, no real cloud connections) for <code>DocumentService.UploadAsync()</code> without real AWS/Azure/GCS credentials? You can't â€” the constructor <strong>hardwires</strong> (directly creates and locks in a specific class, no way to swap it) <strong>concrete</strong> (the real, specific implementation class â€” not an interface) SDK clients. Integration tests require actual cloud accounts, incur real costs, and are slow (network I/O per test). Your CI pipeline fails if credentials expire. The junior's design makes the simplest test impossible without <strong>mocking at the HTTP level</strong> (intercepting and faking the actual network requests â€” extremely complex).<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Mockable Interface, Isolated Tests</div>In tests, <strong>inject</strong> (pass in via the constructor) a <strong>Mock</strong> (a fake stand-in object you control in tests) of <code>CloudStorageFactory</code> that returns a Mock of <code>ICloudStorageProvider</code>. Your entire test suite runs <strong>in-memory</strong> (entirely inside RAM â€” no network, no disk, no cloud) with zero cloud calls, zero cost, and millisecond speed. You can simulate upload failures, network timeouts, and <strong>presigned URL expiry</strong> (the moment a temporary download link stops working) â€” impossible with real cloud connections. <strong>Business logic</strong> (the rules specific to your app, e.g., attach user ID to filename) is tested in total isolation.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-5"></i> OCP Violation</div>Every new provider requires modifying <code>DocumentService</code> â€” a class that is already tested and deployed to <strong>production</strong>. Touching production code for a new provider risks introducing <strong>regressions</strong> (accidentally breaking things that were working before) in existing providers. The <strong>OCP</strong> (Open/Closed Principle â€” existing code should be untouchable; add new behavior by creating new files alongside it) exists precisely to protect this: you should be able to add MinIO without risking that your S3 or Azure paths break during <strong>code review</strong> (when a teammate reads your changes before merging).<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Extend Without Touching Production Code</div>The existing <code>S3StorageFactory</code>, <code>AzureBlobStorageFactory</code>, and <code>GcsStorageFactory</code> are never touched when MinIO is added. Existing <strong>test coverage</strong> (the range of your code that automated tests verify) remains valid. You deploy new files alongside existing files â€” this is a purely additive change. Code review for the new provider is scoped to exactly two new classes, making review faster and safer.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-6"></i> Knowledge Duplication</div>S3-specific logic (<strong>bucket</strong> â€” AWS's word for a storage folder â€” name, region, request format) <strong>leaks into</strong> (implementation details bleed through into a class that shouldn't know them) <code>DocumentService</code>. Azure-specific logic (container name, BlobClient setup) lives in the same class. Now <code>DocumentService</code> knows the internals of three cloud SDKs simultaneously. Any SDK version upgrade (AWS SDK v4, Azure SDK v12 <strong>breaking changes</strong> â€” a library update that makes existing code stop compiling or working) forces changes to a class that should know nothing about cloud internals.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Single Responsibility, Isolated Knowledge</div><code>DocumentUploadService</code> knows one thing: business upload logic. This is the <strong>Single Responsibility Principle</strong> (every class should have exactly one job and one reason to change) at work. AWS SDK internals live exclusively in <code>S3StorageProvider</code>. Azure SDK internals live exclusively in <code>AzureBlobStorageProvider</code>. AWS SDK v4 breaking changes? Touch only <code>S3StorageProvider</code>. The <strong>blast radius</strong> (the number of files affected when something changes) of any SDK change is one file, not a <strong>god class</strong> (a class that knows and does everything â€” too many responsibilities) that knows everything.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-7"></i> No Error Isolation</div>If the GCS credentials initialization throws in the constructor, <code>DocumentService</code> <strong>fails to construct</strong> (the <code>new ClassName()</code> call itself crashes) â€” meaning S3 uploads also fail even though S3 is completely fine. One broken provider poisons the entire service. In the junior's design, a bad Azure <strong>connection string</strong> (a single text value containing server address, account name, and access key) at startup takes down the whole document upload feature, including the S3 path that works perfectly.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Failure Isolation Per Provider</div>Each factory is registered independently in DI. If <code>GcsStorageFactory</code> fails during <strong>health checks</strong> (automated startup checks verifying each component works before accepting requests), it does not affect <code>S3StorageFactory</code> or <code>AzureBlobStorageFactory</code>. EU deployments that only use Azure never even load GCS credentials. Startup failures are scoped to the mis-configured provider â€” the system <strong>degrades gracefully</strong> (continues running at reduced capacity with working parts) rather than collapsing entirely.</div></div>
      </div>
    </div>

    <h3 class="sub">Comparison Matrix â€” Jr vs Sr Approach</h3>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Quality Dimension</th><th>Junior Approach</th><th>Senior Approach</th></tr></thead>
        <tbody>
          <tr><td><strong>Adding a 4th Provider</strong></td><td>Edit <code>DocumentService</code> in 4 methods</td><td>Create 2 new files, touch 0 existing files</td></tr>
          <tr><td><strong>Unit Test Coverage</strong></td><td>Requires real cloud accounts or HTTP mocking</td><td>In-memory mocks, zero cloud calls, milliseconds</td></tr>
          <tr><td><strong>Startup Time</strong></td><td>Initializes all 3 SDK clients regardless</td><td>Only the active provider's client initialized</td></tr>
          <tr><td><strong>Config Error Discovery</strong></td><td>Runtime, on first customer request</td><td>Startup / integration test, before any request</td></tr>
          <tr><td><strong>SDK Upgrade Impact</strong></td><td>Touch <code>DocumentService</code> (risk regressions)</td><td>Touch only the specific provider class</td></tr>
          <tr><td><strong>Code Review Scope</strong></td><td>Reviewer must understand 3 SDKs</td><td>Reviewer only sees 1 new provider class</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- SCENARIO B -->
  <div class="card">
    <div class="card-title"><i class="fa-solid fa-file-export" style="color:var(--accent-purple)"></i> Scenario B â€” Support Multiple Report Export Formats</div>
    <p class="body-text">Your analytics dashboard currently exports data as CSV. <strong>Product</strong> (the Product Manager â€” the person who defines what the software should do) says: "We need Excel for finance teams, HTML for email, and PowerPoint for executives. Oh, and PDF for <strong>compliance</strong> (legal rules requiring records in specific formats) â€” by next quarter." How you <strong>architect</strong> (design the code structure for) this determines whether your system thrives or collapses under every new format request.</p>

    <h3 class="sub">Context: The Requirement</h3>
    <p class="body-text">The <code>ReportService</code> produces a <code>ReportData</code> object containing rows, columns, charts, and <strong>metadata</strong> (descriptive data about the report itself â€” title, date, author). Export format is determined by the <strong>API caller</strong> (the browser or app making the HTTP request) via a <code>format</code> <strong>query parameter</strong> (a key=value pair in the URL, e.g., <code>/export?format=excel</code>). New formats will be added quarterly â€” the team does not want to touch <code>ReportService</code> for each addition.</p>

    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-circle-xmark"></i> Junior Approach â€” The God Method</div>
        <div class="macos-body" style="max-height:520px;"><pre><code class="language-csharp">// ReportService.cs â€” 500+ lines and growing
public class ReportService
{
    public async Task&lt;byte[]&gt; ExportReportAsync(
        string reportId, string format)
    {
        var data = await GetReportDataAsync(reportId);

        // God method â€” knows every format internally
        if (format == "csv")
        {
            var sb = new StringBuilder();
            // Write headers
            sb.AppendLine(string.Join(",", data.Columns));
            // Write rows
            foreach (var row in data.Rows)
                sb.AppendLine(string.Join(",", row));
            return Encoding.UTF8.GetBytes(sb.ToString());
        }
        else if (format == "excel")
        {
            using var package = new ExcelPackage();
            var ws = package.Workbook.Worksheets.Add("Report");
            // Write headers with styling
            for (int i = 0; i &lt; data.Columns.Count; i++)
            {
                ws.Cells[1, i + 1].Value = data.Columns[i];
                ws.Cells[1, i + 1].Style.Font.Bold = true;
                ws.Cells[1, i + 1].Style.Fill
                    .PatternType = ExcelFillStyle.Solid;
                ws.Cells[1, i + 1].Style.Fill
                    .BackgroundColor.SetColor(Color.Navy);
            }
            // Write data rows...
            return package.GetAsByteArray();
        }
        else if (format == "html")
        {
            var html = "&lt;html&gt;&lt;body&gt;&lt;table&gt;";
            html += "&lt;tr&gt;" +
                string.Join("", data.Columns
                    .Select(c =&gt; $"&lt;th&gt;{c}&lt;/th&gt;")) +
                "&lt;/tr&gt;";
            foreach (var row in data.Rows)
                html += "&lt;tr&gt;" +
                    string.Join("", row
                        .Select(v =&gt; $"&lt;td&gt;{v}&lt;/td&gt;")) +
                    "&lt;/tr&gt;";
            html += "&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;";
            return Encoding.UTF8.GetBytes(html);
        }
        else if (format == "powerpoint")
        {
            // 80 lines of OpenXml PowerPoint generation
            // ...
        }
        else if (format == "pdf")
        {
            // 60 lines of iTextSharp PDF logic
            // ...
        }
        throw new ArgumentException($"Unknown format: {format}");
    }
}</code></pre></div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-circle-check"></i> Senior Approach â€” Factory Method Architecture</div>
        <div class="macos-body" style="max-height:520px;"><pre><code class="language-csharp">// IReportExporter.cs â€” Product interface
public interface IReportExporter
{
    string Format { get; }       // "csv", "excel", etc.
    string ContentType { get; }  // MIME type for HTTP response
    string FileExtension { get; }
    Task&lt;byte[]&gt; ExportAsync(ReportData data);
}

// Concrete exporters â€” each in its own file
public class CsvReportExporter : IReportExporter
{
    public string Format =&gt; "csv";
    public string ContentType =&gt; "text/csv";
    public string FileExtension =&gt; ".csv";

    public Task&lt;byte[]&gt; ExportAsync(ReportData data)
    {
        var sb = new StringBuilder();
        sb.AppendLine(string.Join(",", data.Columns));
        foreach (var row in data.Rows)
            sb.AppendLine(string.Join(",", row));
        return Task.FromResult(
            Encoding.UTF8.GetBytes(sb.ToString()));
    }
}

public class ExcelReportExporter : IReportExporter
{
    public string Format =&gt; "excel";
    public string ContentType =&gt;
        "application/vnd.openxmlformats-officedocument" +
        ".spreadsheetml.sheet";
    public string FileExtension =&gt; ".xlsx";

    public Task&lt;byte[]&gt; ExportAsync(ReportData data)
    {
        using var package = new ExcelPackage();
        // All Excel-specific logic isolated here
        return Task.FromResult(package.GetAsByteArray());
    }
}

// IReportExporterFactory.cs â€” Creator
public interface IReportExporterFactory
{
    IReportExporter CreateExporter(string format);
    IEnumerable&lt;string&gt; GetSupportedFormats();
}

// ReportExporterFactory.cs â€” ConcreteCreator with registry
public class ReportExporterFactory : IReportExporterFactory
{
    private readonly Dictionary&lt;string, IReportExporter&gt;
        _exporters;

    // All exporters injected via DI â€” registry pattern
    public ReportExporterFactory(
        IEnumerable&lt;IReportExporter&gt; exporters)
    {
        _exporters = exporters.ToDictionary(
            e =&gt; e.Format.ToLowerInvariant());
    }

    public IReportExporter CreateExporter(string format)
    {
        var key = format.ToLowerInvariant();
        if (!_exporters.TryGetValue(key, out var exporter))
            throw new NotSupportedException(
                $"Export format '{format}' is not supported. " +
                $"Supported: {string.Join(", ", _exporters.Keys)}");
        return exporter;
    }

    public IEnumerable&lt;string&gt; GetSupportedFormats() =&gt;
        _exporters.Keys;
}

// ReportService.cs â€” clean consumer, never changes
public class ReportService
{
    private readonly IReportExporterFactory _factory;

    public ReportService(IReportExporterFactory factory)
        =&gt; _factory = factory;

    public async Task&lt;ExportResult&gt; ExportReportAsync(
        string reportId, string format)
    {
        var data = await GetReportDataAsync(reportId);
        var exporter = _factory.CreateExporter(format);
        var bytes = await exporter.ExportAsync(data);
        return new ExportResult(
            bytes, exporter.ContentType,
            exporter.FileExtension);
    }
}

// Program.cs â€” Adding PowerPoint? One line:
// builder.Services.AddScoped&lt;IReportExporter, PowerPointReportExporter&gt;();
// ReportService is NEVER touched.</code></pre></div>
      </div>
    </div>

    <h3 class="sub">Why the Senior Architecture Wins</h3>
    <div class="jr-sr-list">
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-bomb"></i> The God Method Grows Without Bound</div>Every new format adds 40-80 lines to <code>ReportService.ExportReportAsync()</code>. After five formats, the method is 350 lines. After ten formats, it crosses 700 lines and no one understands the whole thing. This is what a <strong>God Method</strong> (a single method that handles too many different responsibilities) looks like in the wild. Every <strong>PR</strong> (Pull Request â€” code submission sent for team review before merging) adding a new format touches production code, requires a full <strong>regression test</strong> (re-running existing tests to confirm nothing previously working is now broken) of all existing formats, and blocks <strong>parallel development</strong> (two engineers working on different features simultaneously) â€” only one engineer can work on exports at a time.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Linear Growth, Zero Interference</div><code>ReportService.ExportReportAsync()</code> stays at 8 lines forever. Each new format is a new class file. Multiple engineers can work on different exporters simultaneously â€” no <strong>merge conflicts</strong> (when two engineers edit the same file and Git can't combine their changes automatically). PowerPoint and PDF development happen in parallel. The <strong>registry pattern</strong> (a dictionary that stores objects by key so you can look them up at runtime) using <code>IEnumerable&lt;IReportExporter&gt;</code> injection <strong>auto-discovers</strong> (finds new registrations automatically without manual listing) new exporters registered in DI.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-vial-circle-check"></i> Testing the God Method Is a Nightmare</div>To test CSV export, you must run <code>ExportReportAsync(id, "csv")</code> â€” which means the test object also contains Excel, HTML, and PowerPoint code paths. A bug in PDF generation could theoretically affect your CSV test via <strong>shared state</strong> (variables that multiple code paths read and modify â€” changes in one can corrupt another). You cannot test exporters independently. The test file mirrors the god method's complexity: 500-line test class, all <strong>coupled</strong> (code so intertwined you can't change one without affecting the other) together.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Each Exporter Has Its Own Focused Test</div><code>CsvReportExporterTests</code> tests only CSV logic â€” zero Excel or PDF code runs. <code>ExcelReportExporterTests</code> is completely independent. Factory tests verify routing: <code>factory.CreateExporter("excel")</code> returns <code>ExcelReportExporter</code>. <code>ReportService</code> tests at the <strong>service layer</strong> (the part of the codebase containing business rules) use <code>Mock&lt;IReportExporterFactory&gt;</code> â€” zero real exporter code runs. Full isolation at every level.</div></div>
      </div>
      <div class="jr-sr-item">
        <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-circle-exclamation"></i> Error Message Quality Degrades</div>The junior's <code>throw new ArgumentException($"Unknown format: {format}")</code> tells the <strong>API caller</strong> nothing useful. What formats ARE supported? Are they case-sensitive? The caller must read source code or documentation to find out. As formats are added to the if/else if chain, this error message is never updated â€” it becomes permanently out of date.<button class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</button></div>
        <div class="sr-solution-wrap"><div class="callout callout-success sr-solution"><div class="callout-title"><i class="fa-solid fa-check"></i> Self-Describing Error Messages</div>The factory throws: <code>"Export format 'ppt' is not supported. Supported: csv, excel, html, powerpoint, pdf"</code> â€” automatically built from the registry. Add a new exporter? The error message updates itself. The factory also exposes <code>GetSupportedFormats()</code> which the API can return in a <strong>400 Bad Request</strong> (HTTP status code meaning "your request was invalid") response body, giving callers a <strong>machine-readable</strong> (structured so code can parse it automatically, e.g., JSON array) list without any extra maintenance.</div></div>
      </div>
    </div>
  </div>

</section>

<!-- END PHASE 1 -->

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- SECTION 6 â€” CORE IMPLEMENTATIONS                                   -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s6" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-code"></i></div>
    <div><div class="section-num">Section 6</div><h2 class="section-title">Core Implementations</h2></div>
  </div>

  <p class="body-text">The domain is a <strong>Payment Gateway Processing system</strong> â€” a real-world production scenario where a checkout service must route payments through Stripe, PayPal, Square, or Apple Pay without knowing which provider is active at compile time. The Factory Method pattern lets each provider encapsulate its own creation logic while exposing a unified <code>IPaymentProcessor</code> interface to the rest of the system.</p>

  <!-- Card 1: Domain Models -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-database" style="color:var(--accent-cyan)"></i> Domain Models: The Shared Language</div>
    <div class="card-body">
      <p class="body-text">Before any factory or processor exists, the entire system agrees on a common vocabulary â€” enums, records, and value objects that every participant speaks fluently. These models are provider-agnostic; they live at the core of the domain and never import a Stripe or PayPal SDK reference.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentProvider.cs â€” Provider Enum</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Each value maps to a registered DI key and a factory subclass.
// Adding a new provider means adding one value here + implementing
// two classes (processor + factory) â€” nothing else changes.
public enum PaymentProvider
{
    Stripe    = 1,
    PayPal    = 2,
    Square    = 3,
    ApplePay  = 4
}

// PaymentStatus covers the full lifecycle of a charge,
// including async flows (3D Secure, bank redirects, disputes).
public enum PaymentStatus
{
    Pending,
    Succeeded,
    Failed,
    RequiresAction,   // 3D Secure / SCA challenge required
    Cancelled,
    Refunded,
    PartiallyRefunded,
    Disputed          // chargeback filed by cardholder
}</code></pre></div>
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentRequest.cs â€” Immutable Command Record</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// C# record â€” value semantics, immutable, auto-equality.
// AmountInSmallestUnit: Stripe/Square require cents (int 1099 = $10.99).
// PayPal requires dollars with decimals â€” each processor converts internally.
public record PaymentRequest(
    string           IdempotencyKey,        // UUID â€” prevents double charges
    long             AmountInSmallestUnit,  // e.g. 1099 = $10.99 USD
    string           Currency,             // ISO 4217: "USD", "EUR", "GBP"
    string           PaymentMethodToken,   // provider-specific token
    string           CustomerId,
    string?          Description           = null,
    IDictionary&lt;string, string&gt;? Metadata = null
);

// PaymentResult is what CheckoutService records in the Order table.
// IsSuccess avoids string comparisons at the call site.
public record PaymentResult(
    bool            IsSuccess,
    PaymentStatus   Status,
    string          TransactionId,         // internal order reference
    string?         ProviderTransactionId, // e.g. "pi_3Abc..." from Stripe
    PaymentProvider Provider,
    long            AmountCharged,
    DateTimeOffset  ProcessedAt,
    string?         FailureCode    = null,
    string?         FailureMessage = null
);</code></pre></div>
      </div>

      <div class="callout callout-info">
        <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> Why AmountInSmallestUnit as long?</div>
        Floating-point arithmetic is unsafe for money. <code>0.1 + 0.2 == 0.30000000000000004</code> in IEEE 754. Storing $10.99 as <code>1099</code> (cents) is an integer operation â€” no rounding errors. Each processor converts to its required format internally: Stripe/Square receive <code>1099</code> directly; PayPal converts to <code>"10.99"</code> before the API call.
      </div>
    </div>
  </div>

  <!-- Card 2: Product Interface -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-shapes" style="color:var(--accent-blue)"></i> Product Interface: IPaymentProcessor</div>
    <div class="card-body">
      <p class="body-text">This is the <strong>Product</strong> in Factory Method terminology. Every concrete processor (Stripe, PayPal, Square, ApplePay) implements this contract. <code>CheckoutService</code> only ever touches this interface â€” it has zero knowledge of which provider is running beneath it.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">IPaymentProcessor.cs â€” The Product Interface</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public interface IPaymentProcessor
{
    // Identity â€” used by factory resolver and logging
    string          ProviderName { get; }
    PaymentProvider Provider     { get; }

    // Core charge flow â€” async to support network I/O
    Task&lt;PaymentResult&gt; ChargeAsync(
        PaymentRequest request,
        CancellationToken ct = default);

    // Full refund or partial refund (partialAmount = null = full)
    Task&lt;PaymentResult&gt; RefundAsync(
        string          providerTransactionId,
        long?           partialAmountInSmallestUnit = null,
        CancellationToken ct                        = default);

    // Poll provider for final status (useful after RequiresAction)
    Task&lt;PaymentStatus&gt; GetTransactionStatusAsync(
        string transactionId,
        CancellationToken ct = default);

    // Returns true if the HMAC/signature on the raw webhook body is valid.
    // Apple Pay returns false â€” it uses server-to-server callbacks instead.
    bool ValidateWebhookSignature(
        string rawBody,
        string signature,
        string secret);

    // Settlement timing displayed in checkout UI (e.g. "T+2 business days")
    string GetSettlementTimeline();

    // Health check â€” is this provider's API reachable right now?
    Task&lt;bool&gt; IsAvailableAsync(CancellationToken ct = default);
}</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-check"></i> Design Decisions Worth Noting</div>
        <ul style="margin:0.5rem 0 0 1.25rem;color:var(--text-secondary);font-size:0.95rem;line-height:1.8;">
          <li><code>CancellationToken</code> on every async method â€” critical for request timeouts and graceful shutdown</li>
          <li><code>ValidateWebhookSignature</code> is synchronous â€” webhook HMAC validation is pure CPU computation, no I/O</li>
          <li><code>GetSettlementTimeline()</code> returns a human-readable string shown in the checkout UI</li>
          <li><code>IsAvailableAsync</code> powers the health check endpoint and the circuit breaker warm-up</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Card 3: StripePaymentProcessor -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-stripe-s" style="color:#635bff"></i> Concrete Product: StripePaymentProcessor</div>
    <div class="card-body">
      <p class="body-text">The <strong>Concrete Product</strong> for Stripe. Key characteristics: uses Stripe.net SDK (<code>PaymentIntentService</code>), handles 3D Secure via <code>RequiresAction</code> status, uses idempotency keys to prevent duplicate charges, and includes a Polly retry policy for transient network failures.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">StripePaymentProcessor.cs â€” Key Sections</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public sealed class StripePaymentProcessor : IPaymentProcessor
{
    private readonly PaymentIntentService _intentService;
    private readonly ILogger&lt;StripePaymentProcessor&gt; _logger;
    private readonly IAsyncPolicy&lt;PaymentResult&gt; _retryPolicy;

    public string          ProviderName =&gt; "Stripe";
    public PaymentProvider Provider     =&gt; PaymentProvider.Stripe;

    public StripePaymentProcessor(
        StripeClient             client,
        ILogger&lt;StripePaymentProcessor&gt; logger)
    {
        _intentService = new PaymentIntentService(client);
        _logger        = logger;

        // Retry on transient network errors only â€” never on card declines
        _retryPolicy = Policy
            .Handle&lt;StripeException&gt;(ex =&gt;
                ex.HttpStatusCode is HttpStatusCode.ServiceUnavailable
                                  or HttpStatusCode.GatewayTimeout)
            .WaitAndRetryAsync(
                retryCount: 2,
                sleepDurationProvider: attempt =&gt;
                    TimeSpan.FromMilliseconds(200 * attempt));
    }

    public async Task&lt;PaymentResult&gt; ChargeAsync(
        PaymentRequest request, CancellationToken ct = default)
    {
        return await _retryPolicy.ExecuteAsync(async () =&gt;
        {
            var options = new PaymentIntentCreateOptions
            {
                Amount             = request.AmountInSmallestUnit,
                Currency           = request.Currency.ToLower(),
                PaymentMethod      = request.PaymentMethodToken,
                Confirm            = true,
                // 3D Secure: if bank requires challenge, status = requires_action
                ConfirmationMethod = "automatic",
                ReturnUrl          = "https://app.example.com/payment/return",
                Metadata           = request.Metadata
                    ?.ToDictionary(kv =&gt; kv.Key, kv =&gt; kv.Value)
                    ?? new Dictionary&lt;string, string&gt;()
            };

            var requestOptions = new RequestOptions
            {
                IdempotencyKey = request.IdempotencyKey  // prevents double-charge
            };

            try
            {
                var intent = await _intentService.CreateAsync(
                    options, requestOptions, ct);
                return MapToPaymentResult(intent, request.TransactionId);
            }
            catch (StripeException ex) when
                (ex.StripeError?.Type == "card_error")
            {
                // Card declines are NOT retried â€” they are deterministic
                _logger.LogWarning(
                    "Stripe card error {Code} for {IdempotencyKey}",
                    ex.StripeError.Code, request.IdempotencyKey);
                return new PaymentResult(
                    IsSuccess:             false,
                    Status:                PaymentStatus.Failed,
                    TransactionId:         request.IdempotencyKey,
                    ProviderTransactionId: null,
                    Provider:              Provider,
                    AmountCharged:         0,
                    ProcessedAt:           DateTimeOffset.UtcNow,
                    FailureCode:           ex.StripeError.Code,
                    FailureMessage:        ex.StripeError.Message);
            }
        });
    }

    private static PaymentResult MapToPaymentResult(
        PaymentIntent intent, string transactionId) =&gt; new(
        IsSuccess:             intent.Status is "succeeded",
        Status:                intent.Status switch
        {
            "succeeded"       =&gt; PaymentStatus.Succeeded,
            "requires_action" =&gt; PaymentStatus.RequiresAction,
            "canceled"        =&gt; PaymentStatus.Cancelled,
            _                 =&gt; PaymentStatus.Pending
        },
        TransactionId:         transactionId,
        ProviderTransactionId: intent.Id,   // "pi_3Abc123..."
        Provider:              PaymentProvider.Stripe,
        AmountCharged:         intent.Amount,
        ProcessedAt:           intent.Created.ToUniversalTime());

    public string GetSettlementTimeline() =&gt;
        "T+2 business days â€” 2.9% + $0.30 per transaction";

    // ... RefundAsync, GetTransactionStatusAsync, ValidateWebhookSignature,
    // IsAvailableAsync â€” full implementation in source
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- Card 4: PayPalPaymentProcessor -->
  <div class="card open">
    <div class="card-title"><i class="fa-brands fa-paypal" style="color:#003087"></i> Concrete Product: PayPalPaymentProcessor</div>
    <div class="card-body">
      <p class="body-text">PayPal's Orders API v2 uses a <strong>two-step flow</strong>: create an order (status CREATED), then capture it (status COMPLETED). Unlike Stripe, PayPal requires OAuth2 bearer tokens refreshed every hour. A <code>SemaphoreSlim</code> prevents concurrent token refreshes from hammering the OAuth endpoint.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PayPalPaymentProcessor.cs â€” Key Sections</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public sealed class PayPalPaymentProcessor : IPaymentProcessor
{
    private readonly HttpClient  _http;
    private readonly ILogger&lt;PayPalPaymentProcessor&gt; _logger;
    private readonly string      _clientId;
    private readonly string      _clientSecret;
    private readonly string      _baseUrl;

    // Token refresh guard: only one thread refreshes at a time
    private readonly SemaphoreSlim _tokenLock = new(1, 1);
    private string?         _accessToken;
    private DateTimeOffset  _tokenExpiry = DateTimeOffset.MinValue;

    public string          ProviderName =&gt; "PayPal";
    public PaymentProvider Provider     =&gt; PaymentProvider.PayPal;

    private async Task EnsureAccessTokenAsync(CancellationToken ct)
    {
        // Fast path: token is still valid (with 60s buffer)
        if (_accessToken != null
            &amp;&amp; DateTimeOffset.UtcNow &lt; _tokenExpiry.AddSeconds(-60))
            return;

        await _tokenLock.WaitAsync(ct);
        try
        {
            // Double-check inside the lock (another thread may have refreshed)
            if (_accessToken != null
                &amp;&amp; DateTimeOffset.UtcNow &lt; _tokenExpiry.AddSeconds(-60))
                return;

            var credentials = Convert.ToBase64String(
                Encoding.UTF8.GetBytes($"{_clientId}:{_clientSecret}"));
            var response = await _http.PostAsync(
                $"{_baseUrl}/v1/oauth2/token",
                new FormUrlEncodedContent(
                    new[] { new KeyValuePair&lt;string,string&gt;
                        ("grant_type","client_credentials") }),
                ct);
            response.EnsureSuccessStatusCode();
            var json      = await response.Content.ReadFromJsonAsync
                &lt;JsonElement&gt;(cancellationToken: ct);
            _accessToken  = json.GetProperty("access_token").GetString()!;
            var expiresIn = json.GetProperty("expires_in").GetInt32();
            _tokenExpiry  = DateTimeOffset.UtcNow.AddSeconds(expiresIn);
        }
        finally { _tokenLock.Release(); }
    }

    public async Task&lt;PaymentResult&gt; ChargeAsync(
        PaymentRequest request, CancellationToken ct = default)
    {
        await EnsureAccessTokenAsync(ct);

        // CRITICAL: PayPal Orders API v2 expects dollar amounts, NOT cents.
        // Convert: AmountInSmallestUnit=1099 â†’ "10.99"
        var dollarAmount = (request.AmountInSmallestUnit / 100m)
            .ToString("F2", CultureInfo.InvariantCulture);

        // Step 1: Create order
        var createBody = new
        {
            intent              = "CAPTURE",
            purchase_units      = new[]
            {
                new
                {
                    reference_id = request.IdempotencyKey,
                    amount       = new
                    {
                        currency_code = request.Currency.ToUpper(),
                        value         = dollarAmount
                    }
                }
            },
            payment_source = new
            {
                token = new
                {
                    id   = request.PaymentMethodToken,
                    type = "BILLING_AGREEMENT"
                }
            }
        };

        _http.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Bearer", _accessToken);
        _http.DefaultRequestHeaders.Add(
            "PayPal-Request-Id", request.IdempotencyKey);

        var createResp = await _http.PostAsJsonAsync(
            $"{_baseUrl}/v2/checkout/orders", createBody, ct);
        createResp.EnsureSuccessStatusCode();
        var order     = await createResp.Content
            .ReadFromJsonAsync&lt;JsonElement&gt;(cancellationToken: ct);
        var orderId   = order.GetProperty("id").GetString()!;

        // Step 2: Capture the created order
        var captureResp = await _http.PostAsync(
            $"{_baseUrl}/v2/checkout/orders/{orderId}/capture",
            new StringContent("{}", Encoding.UTF8, "application/json"), ct);
        captureResp.EnsureSuccessStatusCode();
        var captured = await captureResp.Content
            .ReadFromJsonAsync&lt;JsonElement&gt;(cancellationToken: ct);

        var status = captured.GetProperty("status").GetString();
        return new PaymentResult(
            IsSuccess:             status == "COMPLETED",
            Status:                status == "COMPLETED"
                                   ? PaymentStatus.Succeeded
                                   : PaymentStatus.Failed,
            TransactionId:         request.IdempotencyKey,
            ProviderTransactionId: orderId,
            Provider:              Provider,
            AmountCharged:         request.AmountInSmallestUnit,
            ProcessedAt:           DateTimeOffset.UtcNow);
    }

    public string GetSettlementTimeline() =&gt;
        "T+1 business day â€” 3.49% + $0.49 per transaction";

    // ... RefundAsync, GetTransactionStatusAsync, ValidateWebhookSignature,
    // IsAvailableAsync â€” full implementation in source
}</code></pre></div>
      </div>

      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> The Dollar vs Cents Trap</div>
        Stripe and Square accept <strong>integer cents</strong> (<code>1099</code> = $10.99). PayPal Orders API v2 requires a <strong>decimal string</strong> (<code>"10.99"</code>). If you pass <code>"1099"</code> to PayPal, you charge the customer <strong>$1,099</strong> â€” a 100x overcharge. This is why each Concrete Product owns its own conversion logic inside <code>ChargeAsync</code>, never in the shared caller.
      </div>
    </div>
  </div>

  <!-- Card 5: Abstract Creator -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-industry" style="color:var(--accent-yellow)"></i> Factory: PaymentProcessorFactory (Abstract Creator)</div>
    <div class="card-body">
      <p class="body-text">The <strong>Creator</strong> in Factory Method terminology. It declares the abstract factory method <code>CreateProcessor()</code> and implements the <strong>template method</strong> <code>ProcessPaymentAsync()</code> â€” the algorithm skeleton that all subclasses share. Subclasses override <em>only</em> which processor to create; the processing pipeline logic is inherited unchanged.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentProcessorFactory.cs â€” Abstract Creator</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Abstract Creator â€” defines the factory method and template method pattern.
// Subclasses must override CreateProcessor() only.
public abstract class PaymentProcessorFactory
{
    private readonly ILogger _logger;

    protected PaymentProcessorFactory(ILogger logger)
        =&gt; _logger = logger;

    // THE FACTORY METHOD â€” subclasses decide which processor to create.
    // protected: callers use ProcessPaymentAsync, never CreateProcessor directly.
    protected abstract IPaymentProcessor CreateProcessor();

    // TEMPLATE METHOD â€” shared pipeline. Validates, creates, charges, logs.
    // Subclasses cannot override this â€” it is the invariant algorithm.
    public async Task&lt;PaymentResult&gt; ProcessPaymentAsync(
        PaymentRequest    request,
        CancellationToken ct = default)
    {
        ValidateRequest(request);   // shared validation logic

        // Factory method called here â€” subclass decides which processor
        var processor = CreateProcessor();

        _logger.LogInformation(
            "Processing payment via {Provider} | IdempotencyKey={Key}",
            processor.ProviderName, request.IdempotencyKey);

        var result = await processor.ChargeAsync(request, ct);

        _logger.LogInformation(
            "Payment {Status} via {Provider} | TxId={TxId}",
            result.Status, processor.ProviderName,
            result.ProviderTransactionId);

        return result;
    }

    // Shared validation â€” runs before every payment, regardless of provider
    private static void ValidateRequest(PaymentRequest request)
    {
        if (string.IsNullOrWhiteSpace(request.IdempotencyKey))
            throw new ArgumentException(
                "IdempotencyKey is required to prevent double charges.",
                nameof(request));

        if (request.AmountInSmallestUnit &lt;= 0)
            throw new ArgumentOutOfRangeException(
                nameof(request),
                "AmountInSmallestUnit must be positive.");

        if (string.IsNullOrWhiteSpace(request.Currency)
            || request.Currency.Length != 3)
            throw new ArgumentException(
                "Currency must be a 3-character ISO 4217 code.",
                nameof(request));
    }
}

// Concrete Creator â€” Stripe
public sealed class StripeProcessorFactory : PaymentProcessorFactory
{
    private readonly StripePaymentProcessor _processor;

    public StripeProcessorFactory(
        StripePaymentProcessor processor,
        ILogger&lt;StripeProcessorFactory&gt; logger)
        : base(logger) =&gt; _processor = processor;

    // Factory method implementation: return the pre-built Stripe processor
    protected override IPaymentProcessor CreateProcessor() =&gt; _processor;
}

// Concrete Creator â€” PayPal (identical structure, different processor)
public sealed class PayPalProcessorFactory : PaymentProcessorFactory
{
    private readonly PayPalPaymentProcessor _processor;

    public PayPalProcessorFactory(
        PayPalPaymentProcessor processor,
        ILogger&lt;PayPalProcessorFactory&gt; logger)
        : base(logger) =&gt; _processor = processor;

    protected override IPaymentProcessor CreateProcessor() =&gt; _processor;
}

// Square and ApplePay follow the exact same pattern
// ... (SquareProcessorFactory, ApplePayProcessorFactory in source)</code></pre></div>
      </div>
    </div>
  </div>

  <!-- Card 6: DI Registration & Factory Resolver -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-plug" style="color:var(--accent-green)"></i> DI Registration &amp; Factory Resolver</div>
    <div class="card-body">
      <p class="body-text">.NET 8's <strong>keyed services</strong> let us register multiple implementations of the same interface under different keys. The <code>IPaymentProcessorFactoryResolver</code> resolves the correct factory at runtime based on a <code>PaymentProvider</code> enum value â€” zero switch statements, zero <code>if/else</code> chains.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs â€” .NET 8 Keyed Service Registration</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// â”€â”€ Processors (Singleton â€” stateless after construction) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
builder.Services.AddSingleton&lt;StripePaymentProcessor&gt;();
builder.Services.AddSingleton&lt;PayPalPaymentProcessor&gt;();
builder.Services.AddSingleton&lt;SquarePaymentProcessor&gt;();
builder.Services.AddSingleton&lt;ApplePayPaymentProcessor&gt;();

// â”€â”€ Factories keyed by PaymentProvider enum â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// .NET 8 AddKeyedSingleton: resolve with IKeyedServiceProvider.GetKeyedService()
builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    StripeProcessorFactory&gt;(PaymentProvider.Stripe);

builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    PayPalProcessorFactory&gt;(PaymentProvider.PayPal);

builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    SquareProcessorFactory&gt;(PaymentProvider.Square);

builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    ApplePayProcessorFactory&gt;(PaymentProvider.ApplePay);

// â”€â”€ Resolver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
builder.Services.AddSingleton&lt;IPaymentProcessorFactoryResolver,
    PaymentProcessorFactoryResolver&gt;();

// â”€â”€ Strongly-typed config (prevents provider mismatch bugs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
builder.Services
    .AddOptions&lt;StripeConfiguration&gt;()
    .BindConfiguration("Payment:Stripe")
    .ValidateDataAnnotations()
    .ValidateOnStart();

builder.Services
    .AddOptions&lt;PayPalConfiguration&gt;()
    .BindConfiguration("Payment:PayPal")
    .ValidateDataAnnotations()
    .ValidateOnStart();</code></pre></div>
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentProcessorFactoryResolver.cs â€” Runtime Dispatch</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public interface IPaymentProcessorFactoryResolver
{
    PaymentProcessorFactory Resolve(PaymentProvider provider);
}

public sealed class PaymentProcessorFactoryResolver
    : IPaymentProcessorFactoryResolver
{
    private readonly IKeyedServiceProvider _sp;

    public PaymentProcessorFactoryResolver(IKeyedServiceProvider sp)
        =&gt; _sp = sp;

    public PaymentProcessorFactory Resolve(PaymentProvider provider)
    {
        var factory = _sp.GetKeyedService&lt;PaymentProcessorFactory&gt;(provider);
        if (factory is null)
            throw new InvalidOperationException(
                $"No factory registered for provider '{provider}'. " +
                $"Register it with AddKeyedSingleton&lt;PaymentProcessorFactory," +
                $" XxxProcessorFactory&gt;(PaymentProvider.{provider}) in Program.cs.");
        return factory;
    }
}

// â”€â”€ Consumer: CheckoutService never knows which provider runs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class CheckoutService
{
    private readonly IPaymentProcessorFactoryResolver _resolver;

    public CheckoutService(IPaymentProcessorFactoryResolver resolver)
        =&gt; _resolver = resolver;

    public async Task&lt;PaymentResult&gt; ProcessCheckoutAsync(
        Cart              cart,
        PaymentProvider   provider,
        CancellationToken ct = default)
    {
        var request = new PaymentRequest(
            IdempotencyKey:       Guid.NewGuid().ToString(),
            AmountInSmallestUnit: cart.TotalInCents,
            Currency:             cart.Currency,
            PaymentMethodToken:   cart.PaymentMethodToken,
            CustomerId:           cart.CustomerId);

        var factory = _resolver.Resolve(provider);
        return await factory.ProcessPaymentAsync(request, ct);
        // That's it. Zero provider-specific code in CheckoutService.
    }
}</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-check"></i> Adding a Fifth Provider (e.g. Adyen) â€” Zero Existing Code Changes</div>
        <ol style="margin:0.5rem 0 0 1.25rem;color:var(--text-secondary);font-size:0.95rem;line-height:2;">
          <li>Add <code>Adyen = 5</code> to the <code>PaymentProvider</code> enum</li>
          <li>Create <code>AdyenPaymentProcessor : IPaymentProcessor</code></li>
          <li>Create <code>AdyenProcessorFactory : PaymentProcessorFactory</code></li>
          <li>Add one line to <code>Program.cs</code>: <code>builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory, AdyenProcessorFactory&gt;(PaymentProvider.Adyen)</code></li>
        </ol>
        <strong style="color:var(--accent-green);">CheckoutService is never touched. The existing four providers never run during Adyen development. Zero regression risk.</strong>
      </div>
    </div>
  </div>

</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- SECTION 10 â€” BUG CASE STUDIES                                      -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s10" class="section">
  <div class="section-header">
    <div class="section-icon red"><i class="fa-solid fa-bug"></i></div>
    <div><div class="section-num">Section 10</div><h2 class="section-title">Bug Case Studies</h2></div>
  </div>

  <p class="body-text">Three production bugs that hit real payment systems â€” each caused by a different Factory Method implementation mistake. Each cost real money. Each had an obvious fix in hindsight.</p>

  <!-- Bug 1 -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-1" style="color:var(--accent-red)"></i> Bug #1 â€” The Silent Provider Mismatch: Stripe Config in PayPal Factory</div>
    <div class="card-body">
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: $47,000 Charged to Wrong Merchant Account â€” PCI Investigation Triggered</div>
        The PayPal factory was registered in DI with the Stripe configuration object injected by mistake. Both configs were of type <code>IOptions&lt;ApiConfiguration&gt;</code> â€” a generic shared config class â€” so the DI container resolved the wrong one silently. PayPal charges were processed using the Stripe merchant's API key, routing real money to the wrong account. No runtime exception was thrown. The bug was discovered only when the Stripe merchant's reconciliation report showed unexpected PayPal-style charge descriptions.
      </div>

      <h3 class="sub">The Bug â€” Wrong Config Injected at Registration</h3>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs â€” BROKEN: Generic Config, Wrong Injection</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// WRONG: Both factories receive IOptions&lt;ApiConfiguration&gt;
// DI has no way to know WHICH provider's config goes WHERE.
// The developer registered them in the wrong order by mistake.

builder.Services.Configure&lt;ApiConfiguration&gt;(
    builder.Configuration.GetSection("Payment:Stripe"));   // Binds once globally

// PayPalProcessorFactory constructor also accepts IOptions&lt;ApiConfiguration&gt;
// DI resolves the SAME globally-registered ApiConfiguration for both.
// Result: PayPal factory gets Stripe's API key silently.
builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    StripeProcessorFactory&gt;(PaymentProvider.Stripe);
builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    PayPalProcessorFactory&gt;(PaymentProvider.PayPal);   // â† receives Stripe config!

// No test caught this because integration tests mocked the processors,
// never exercising real API key routing.</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-shield-halved"></i> Fix â€” Type-Safe Config Binding: One Config Class Per Provider</div>
        The fix eliminates the ambiguity completely by making each provider's config a unique type. The DI container can now never inject the wrong config because the types are incompatible.
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs â€” FIXED: Unique Config Types Per Provider</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Each provider has its own sealed config record â€” types are incompatible.
// DI cannot accidentally inject StripeConfiguration into PayPalProcessorFactory.

public sealed record StripeConfiguration
{
    [Required] public string SecretKey       { get; init; } = default!;
    [Required] public string PublishableKey  { get; init; } = default!;
    [Required] public string WebhookSecret   { get; init; } = default!;
}

public sealed record PayPalConfiguration
{
    [Required] public string ClientId     { get; init; } = default!;
    [Required] public string ClientSecret { get; init; } = default!;
    [Required] public string BaseUrl      { get; init; } = default!;
}

// --- Program.cs registration ---
builder.Services
    .AddOptions&lt;StripeConfiguration&gt;()
    .BindConfiguration("Payment:Stripe")
    .ValidateDataAnnotations()
    .ValidateOnStart();   // Crashes at startup if SecretKey is missing

builder.Services
    .AddOptions&lt;PayPalConfiguration&gt;()
    .BindConfiguration("Payment:PayPal")
    .ValidateDataAnnotations()
    .ValidateOnStart();

// Constructors now use the specific type â€” compiler enforces correctness:
// StripeProcessorFactory(IOptions&lt;StripeConfiguration&gt; config, ...)
// PayPalProcessorFactory(IOptions&lt;PayPalConfiguration&gt; config, ...)
// Injecting StripeConfiguration into PayPalProcessorFactory = compile error.</code></pre></div>
      </div>

      <h3 class="sub">Timeline of Failure</h3>
      <div class="table-wrapper">
        <table>
          <thead><tr><th>Time</th><th>Event</th><th>Consequence</th></tr></thead>
          <tbody>
            <tr><td>Day 0</td><td>Developer refactors config classes to share a generic <code>ApiConfiguration</code> type</td><td>Both factories receive same DI-registered config</td></tr>
            <tr><td>Day 1</td><td>Deploy to production. Stripe payments work (correct config). PayPal payments also "succeed"</td><td>PayPal charges routed through Stripe merchant key silently</td></tr>
            <tr><td>Day 3</td><td>Monthly reconciliation report reviewed</td><td>Stripe merchant reports unexpected $47K in unrecognised PayPal charges</td></tr>
            <tr><td>Day 3+2h</td><td>PCI compliance team opens investigation</td><td>Service suspended for 6 hours during audit</td></tr>
            <tr><td>Day 4</td><td>Fix deployed: unique config types, <code>ValidateOnStart()</code> added</td><td>Would have been caught at startup during initial deployment</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Bug 2 -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-2" style="color:var(--accent-red)"></i> Bug #2 â€” The Missing Factory Registration: Apple Pay Charges Vanish</div>
    <div class="card-body">
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: Apple Pay Customers Saw "Payment Failed" for 3 Hours</div>
        A new developer added <code>ApplePayPaymentProcessor</code> and <code>ApplePayProcessorFactory</code> but forgot to register the factory in <code>Program.cs</code>. The startup validation check had not yet been implemented. The <code>IKeyedServiceProvider</code> returned <code>null</code> at runtime for <code>PaymentProvider.ApplePay</code>, causing the resolver to throw <code>InvalidOperationException</code> on every Apple Pay checkout. The exception was swallowed by a top-level handler that returned HTTP 500 â€” which the frontend mapped to "Payment failed". The bug ran for 3 hours before an alert on elevated 500 rates fired.
      </div>

      <h3 class="sub">The Bug â€” DI Registration Omitted</h3>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs â€” BROKEN: ApplePay Factory Never Registered</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Developer added the new class files but forgot this line:
builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    ApplePayProcessorFactory&gt;(PaymentProvider.ApplePay);
// â†‘ This line is MISSING from Program.cs

// Result at runtime when ApplePay is selected:
// _sp.GetKeyedService&lt;PaymentProcessorFactory&gt;(PaymentProvider.ApplePay)
// returns null â†’ resolver throws InvalidOperationException
// â†’ HTTP 500 â†’ "Payment failed" in UI</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-shield-halved"></i> Fix â€” Startup Validation: Assert All Enum Values Are Registered</div>
        Add a <code>IHostedService</code> or startup validator that iterates every <code>PaymentProvider</code> value and asserts a factory is registered. This turns a silent runtime failure into a loud startup crash â€” caught in dev/staging, never reaching production.
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentFactoryStartupValidator.cs â€” FIXED</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Runs at application startup BEFORE accepting any requests.
// Crashes the host immediately if any provider has no registered factory.
public sealed class PaymentFactoryStartupValidator
    : IHostedService
{
    private readonly IKeyedServiceProvider _sp;
    private readonly ILogger&lt;PaymentFactoryStartupValidator&gt; _logger;

    public PaymentFactoryStartupValidator(
        IKeyedServiceProvider sp,
        ILogger&lt;PaymentFactoryStartupValidator&gt; logger)
    {
        _sp     = sp;
        _logger = logger;
    }

    public Task StartAsync(CancellationToken ct)
    {
        var missing = new List&lt;PaymentProvider&gt;();

        foreach (var provider in Enum.GetValues&lt;PaymentProvider&gt;())
        {
            var factory = _sp.GetKeyedService&lt;PaymentProcessorFactory&gt;(provider);
            if (factory is null)
            {
                missing.Add(provider);
                _logger.LogCritical(
                    "No PaymentProcessorFactory registered for {Provider}. " +
                    "Add AddKeyedSingleton&lt;PaymentProcessorFactory," +
                    " XxxProcessorFactory&gt;(PaymentProvider.{Provider})" +
                    " in Program.cs.",
                    provider, provider);
            }
        }

        if (missing.Count > 0)
            throw new InvalidOperationException(
                $"Missing factory registrations for: " +
                string.Join(", ", missing) +
                ". Application cannot start.");

        _logger.LogInformation(
            "All {Count} PaymentProcessorFactory registrations verified.",
            Enum.GetValues&lt;PaymentProvider&gt;().Length);
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken ct) =&gt; Task.CompletedTask;
}

// Register in Program.cs:
builder.Services.AddHostedService&lt;PaymentFactoryStartupValidator&gt;();</code></pre></div>
      </div>

      <div class="callout callout-info">
        <div class="callout-title"><i class="fa-solid fa-flask"></i> Architectural Fitness Test â€” Catches It Even Earlier</div>
        Add a unit test that reflects the <code>PaymentProvider</code> enum and asserts a factory exists in the DI container for each value. This catches the omission before the code even reaches a deployment pipeline â€” it fails in the developer's local test run within seconds.
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentFactoryRegistrationTests.cs â€” Fitness Test</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public class PaymentFactoryRegistrationTests
{
    [Theory]
    [MemberData(nameof(AllProviders))]
    public void AllProviders_HaveRegisteredFactory(PaymentProvider provider)
    {
        // Build the real DI container (uses Program.cs registrations)
        var host = Program.CreateHostBuilder(Array.Empty&lt;string&gt;()).Build();
        var sp   = host.Services.GetRequiredService&lt;IKeyedServiceProvider&gt;();

        var factory = sp.GetKeyedService&lt;PaymentProcessorFactory&gt;(provider);

        Assert.NotNull(factory);  // Fails immediately if registration is missing
    }

    public static IEnumerable&lt;object[]&gt; AllProviders() =&gt;
        Enum.GetValues&lt;PaymentProvider&gt;()
            .Select(p =&gt; new object[] { p });
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- Bug 3 -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-3" style="color:var(--accent-red)"></i> Bug #3 â€” The Disposed HttpClient Factory: Cascading Timeouts on Black Friday</div>
    <div class="card-body">
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull-crossbones"></i> Business Impact: ~4,800 Failed Checkouts â€” ~$180,000 Lost Revenue in 4 Minutes</div>
        Each <code>PayPalProcessorFactory.CreateProcessor()</code> call instantiated a brand-new <code>PayPalPaymentProcessor</code>, which in its constructor called <code>new HttpClient()</code>. Under Black Friday load (2,000 req/s), the system created 2,000 new <code>HttpClient</code> instances per second. Each instance opened new TCP connections. Within 2 minutes, the machine exhausted all ephemeral ports (TIME_WAIT state â€” default 4 minutes). New TCP connections started failing with <code>SocketException: Address already in use</code>. All payment calls timed out. Every checkout failed for 4 minutes until a load balancer rerouted traffic and the ports recovered.
      </div>

      <h3 class="sub">The Bug â€” new HttpClient() Per Processor Instance</h3>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PayPalProcessorFactory.cs â€” BROKEN: new HttpClient() Per Call</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// WRONG: Each CreateProcessor() call creates a new processor
// with a brand-new HttpClient â€” NOT reused between requests.
public sealed class PayPalProcessorFactory : PaymentProcessorFactory
{
    private readonly IOptions&lt;PayPalConfiguration&gt; _config;

    public PayPalProcessorFactory(
        IOptions&lt;PayPalConfiguration&gt; config,
        ILogger&lt;PayPalProcessorFactory&gt; logger) : base(logger)
        =&gt; _config = config;

    protected override IPaymentProcessor CreateProcessor()
    {
        // â† BUG: new HttpClient() opens a new TCP connection each time.
        // Under high concurrency, this exhausts ephemeral ports.
        var http = new HttpClient();
        return new PayPalPaymentProcessor(
            http, _config, Logger);
    }
}</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-shield-halved"></i> Fix â€” IHttpClientFactory: Connection Pooling via Shared HttpMessageHandler</div>
        <code>IHttpClientFactory</code> (from <code>Microsoft.Extensions.Http</code>) pools <code>HttpMessageHandler</code> instances. All <code>HttpClient</code> objects created by the factory share the same underlying connection pool. Ports are reused. DNS changes are respected via handler rotation. The fix requires zero changes to the processor itself â€” only the factory and DI registration change.
      </div>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PayPalProcessorFactory.cs â€” FIXED: IHttpClientFactory</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// CORRECT: IHttpClientFactory manages connection pooling.
// CreateClient() reuses an existing HttpMessageHandler from the pool.
// Ephemeral port exhaustion is impossible.

public sealed class PayPalProcessorFactory : PaymentProcessorFactory
{
    private readonly IHttpClientFactory            _httpFactory;
    private readonly IOptions&lt;PayPalConfiguration&gt; _config;
    private readonly ILogger&lt;PayPalPaymentProcessor&gt; _processorLogger;

    public PayPalProcessorFactory(
        IHttpClientFactory               httpFactory,
        IOptions&lt;PayPalConfiguration&gt;   config,
        ILogger&lt;PayPalProcessorFactory&gt; factoryLogger,
        ILogger&lt;PayPalPaymentProcessor&gt; processorLogger)
        : base(factoryLogger)
    {
        _httpFactory      = httpFactory;
        _config           = config;
        _processorLogger  = processorLogger;
    }

    protected override IPaymentProcessor CreateProcessor()
    {
        // CreateClient("paypal") returns an HttpClient backed by
        // a shared, pooled HttpMessageHandler â€” zero new TCP connections.
        var http = _httpFactory.CreateClient("paypal");
        return new PayPalPaymentProcessor(
            http, _config, _processorLogger);
    }
}

// Program.cs â€” name the client for per-provider policy config:
builder.Services.AddHttpClient("paypal", client =&gt;
{
    client.BaseAddress = new Uri(
        builder.Configuration["Payment:PayPal:BaseUrl"]!);
    client.Timeout = TimeSpan.FromSeconds(30);
})
.AddPolicyHandler(GetRetryPolicy())     // Polly retry
.AddPolicyHandler(GetCircuitBreaker()); // Polly circuit breaker</code></pre></div>
      </div>

      <h3 class="sub">Why This Is a Factory Method Concern</h3>
      <div class="callout callout-info">
        <div class="callout-title"><i class="fa-solid fa-info-circle"></i> Resource Lifecycle Is a Factory Responsibility</div>
        The factory method controls <em>how</em> an object is created â€” and that includes which dependencies it receives. A factory that passes <code>new HttpClient()</code> is making a lifecycle decision: "this object owns its connection pool." A factory that passes <code>_httpFactory.CreateClient("paypal")</code> is making a different decision: "this object shares a connection pool managed by the infrastructure." The processor itself never needs to know the difference. The factory is the right place to encode this infrastructure concern.
      </div>
    </div>
  </div>

</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<!-- SECTION 12 â€” SOLID PRINCIPLES MAPPING                              -->
<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s12" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-cubes"></i></div>
    <div><div class="section-num">Section 12</div><h2 class="section-title">SOLID Principles Mapping</h2></div>
  </div>

  <p class="body-text">Factory Method is one of the patterns that naturally enforces SOLID. Each principle maps directly to a concrete structural feature of the Payment Gateway implementation â€” not as theory but as observable code architecture.</p>

  <!-- S -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-s" style="color:var(--accent-blue)"></i> S â€” Single Responsibility Principle</div>
    <div class="card-body">
      <p class="body-text"><strong>Each factory creates exactly one product type.</strong> <code>StripeProcessorFactory</code> creates <code>StripePaymentProcessor</code>. <code>PayPalProcessorFactory</code> creates <code>PayPalPaymentProcessor</code>. No factory knows about multiple providers. If Stripe's API changes, only <code>StripePaymentProcessor</code> and <code>StripeProcessorFactory</code> change â€” the word "PayPal" does not appear anywhere in those files.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SRP_Comparison.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// âœ— BEFORE â€” One factory, all providers (SRP violation)
// This class changes when Stripe changes, PayPal changes, Square changes,
// AND when new providers are added. Four reasons to change.
public class PaymentProcessorFactory
{
    public IPaymentProcessor Create(PaymentProvider provider) =&gt; provider switch
    {
        PaymentProvider.Stripe  =&gt; new StripePaymentProcessor(stripeKey),
        PaymentProvider.PayPal  =&gt; new PayPalPaymentProcessor(paypalId, secret),
        PaymentProvider.Square  =&gt; new SquarePaymentProcessor(squareToken),
        _                       =&gt; throw new NotSupportedException()
    };
    // Changes when Stripe SDK updates, PayPal OAuth flow changes,
    // Square API version bumps â€” all unrelated concerns in one class.
}

// âœ“ AFTER â€” One factory per provider (SRP enforced)
// StripeProcessorFactory has ONE reason to change: Stripe-specific creation
public sealed class StripeProcessorFactory : PaymentProcessorFactory
{
    private readonly StripePaymentProcessor _processor;
    protected override IPaymentProcessor CreateProcessor() =&gt; _processor;
    // Only changes when Stripe processor construction changes.
    // PayPal changes never touch this file.
}

// PayPalProcessorFactory has ONE reason to change: PayPal-specific creation
public sealed class PayPalProcessorFactory : PaymentProcessorFactory
{
    private readonly PayPalPaymentProcessor _processor;
    protected override IPaymentProcessor CreateProcessor() =&gt; _processor;
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- O -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-o" style="color:var(--accent-purple)"></i> O â€” Open/Closed Principle</div>
    <div class="card-body">
      <p class="body-text"><strong>New provider = new factory class + new processor class.</strong> Zero changes to existing factories, the resolver, or <code>CheckoutService</code>. The system is open to extension (add Adyen) and closed to modification (Stripe/PayPal/Square code never changes). This is the Factory Method pattern's primary value proposition.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OCP_AddingAdyen.cs â€” Zero Existing Code Modified</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Step 1: Add to enum â€” the only change to existing code
public enum PaymentProvider
{
    Stripe   = 1,
    PayPal   = 2,
    Square   = 3,
    ApplePay = 4,
    Adyen    = 5   // â† NEW: only change in existing codebase
}

// Step 2: New processor class (new file â€” existing code untouched)
public sealed class AdyenPaymentProcessor : IPaymentProcessor
{
    public string          ProviderName =&gt; "Adyen";
    public PaymentProvider Provider     =&gt; PaymentProvider.Adyen;

    public async Task&lt;PaymentResult&gt; ChargeAsync(
        PaymentRequest request, CancellationToken ct = default)
    {
        // Adyen-specific HPP or API integration
        // ... Adyen SDK calls ...
        return new PaymentResult(/* ... */);
    }

    public string GetSettlementTimeline() =&gt;
        "T+2 business days â€” Interchange++ pricing";
    // ... other interface members ...
}

// Step 3: New factory class (new file â€” existing code untouched)
public sealed class AdyenProcessorFactory : PaymentProcessorFactory
{
    private readonly AdyenPaymentProcessor _processor;

    public AdyenProcessorFactory(
        AdyenPaymentProcessor processor,
        ILogger&lt;AdyenProcessorFactory&gt; logger)
        : base(logger) =&gt; _processor = processor;

    protected override IPaymentProcessor CreateProcessor() =&gt; _processor;
}

// Step 4: One line in Program.cs â€” the ONLY addition to existing code
builder.Services.AddKeyedSingleton&lt;PaymentProcessorFactory,
    AdyenProcessorFactory&gt;(PaymentProvider.Adyen);

// CheckoutService: NEVER MODIFIED
// StripeProcessorFactory: NEVER MODIFIED
// PayPalProcessorFactory: NEVER MODIFIED
// PaymentProcessorFactoryResolver: NEVER MODIFIED</code></pre></div>
      </div>
    </div>
  </div>

  <!-- L -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-l" style="color:var(--accent-green)"></i> L â€” Liskov Substitution Principle</div>
    <div class="card-body">
      <p class="body-text"><strong>All processors are substitutable through <code>IPaymentProcessor</code>.</strong> <code>CheckoutService</code> calls <code>processor.ChargeAsync(request)</code> â€” the result behaves identically whether the processor is Stripe, PayPal, Square, or ApplePay. No caller checks <code>if (processor is StripePaymentProcessor)</code>. The postcondition â€” a valid <code>PaymentResult</code> with a populated <code>Status</code> field â€” is guaranteed by every implementation.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LSP_Substitutability.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// âœ— BEFORE â€” LSP violation: caller does type checks
public async Task ProcessAsync(IPaymentProcessor processor,
                               PaymentRequest request)
{
    if (processor is StripePaymentProcessor stripe)
    {
        // Stripe-specific: check 3D Secure status
        var intent = await stripe.GetPaymentIntentAsync(request.IdempotencyKey);
        if (intent.Status == "requires_action") { /* special handling */ }
    }
    else if (processor is PayPalPaymentProcessor paypal)
    {
        // PayPal-specific: two-step create + capture handled manually
        await paypal.CreateOrderAsync(request);
        await paypal.CaptureOrderAsync(request.IdempotencyKey);
    }
    // else... more type checks as providers grow
    // This method violates LSP AND OCP simultaneously.
}

// âœ“ AFTER â€” LSP enforced: all processors substitutable
public async Task ProcessAsync(IPaymentProcessor processor,
                               PaymentRequest request)
{
    // Works correctly for Stripe, PayPal, Square, ApplePay, Adyen.
    // No type checking. No provider-specific branches.
    // Each processor internally handles its own multi-step flows.
    var result = await processor.ChargeAsync(request);

    // Result is always a valid PaymentResult â€” LSP guarantees this.
    if (result.IsSuccess)
        await SaveTransactionAsync(result);
    else
        await HandleFailureAsync(result);
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- I -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-i" style="color:var(--accent-yellow)"></i> I â€” Interface Segregation Principle</div>
    <div class="card-body">
      <p class="body-text"><code>IPaymentProcessor</code> defines only what <strong>consumers</strong> need. No provider-specific methods leak through the interface. When a provider doesn't support a feature (e.g. Apple Pay does not issue traditional webhooks), the implementation returns a safe default â€” it does not expose an irrelevant method that callers must work around.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ISP_Comparison.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// âœ— BEFORE â€” Fat interface exposing provider-specific methods
public interface IPaymentProcessor
{
    Task&lt;PaymentResult&gt; ChargeAsync(PaymentRequest request);
    // Stripe-only methods exposed on the interface:
    Task&lt;PaymentIntent&gt; GetPaymentIntentAsync(string id);
    Task SetupFutureUsageAsync(string intentId, string usage);
    // PayPal-only methods exposed on the interface:
    Task&lt;string&gt; CreateOrderAsync(PaymentRequest request);
    Task&lt;PaymentResult&gt; CaptureOrderAsync(string orderId);
}
// ApplePayPaymentProcessor MUST implement GetPaymentIntentAsync,
// SetupFutureUsageAsync, CreateOrderAsync, CaptureOrderAsync
// â€” all throwing NotImplementedException. Callers must guard against it.

// âœ“ AFTER â€” Segregated interface: only cross-provider concerns
public interface IPaymentProcessor
{
    // These make sense for ALL providers â€” no exceptions:
    Task&lt;PaymentResult&gt;  ChargeAsync(...);
    Task&lt;PaymentResult&gt;  RefundAsync(...);
    Task&lt;PaymentStatus&gt;  GetTransactionStatusAsync(...);
    bool                 ValidateWebhookSignature(...);
    string               GetSettlementTimeline();
    Task&lt;bool&gt;           IsAvailableAsync(...);
}

// Apple Pay â€” ValidateWebhookSignature returns false (doesn't use webhooks).
// The interface contract is still satisfied. No NotImplementedException.
public sealed class ApplePayPaymentProcessor : IPaymentProcessor
{
    public bool ValidateWebhookSignature(
        string rawBody, string signature, string secret)
        =&gt; false; // Apple Pay uses server-to-server callbacks, not webhooks.
                   // Callers check the bool return â€” no exception thrown.
}</code></pre></div>
      </div>
    </div>
  </div>

  <!-- D -->
  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-d" style="color:var(--accent-red)"></i> D â€” Dependency Inversion Principle</div>
    <div class="card-body">
      <p class="body-text"><strong>High-level modules depend on abstractions, not concretions.</strong> <code>CheckoutService</code> (high-level policy) depends on <code>IPaymentProcessorFactoryResolver</code> and <code>PaymentProcessorFactory</code> (abstractions). <code>StripePaymentProcessor</code> (low-level detail) depends on nothing from the business layer. The dependency arrows point inward â€” toward abstractions â€” never outward toward infrastructure details.</p>

      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DIP_Comparison.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// âœ— BEFORE â€” High-level depends on low-level concretions (DIP violation)
public sealed class CheckoutService
{
    // Depends directly on concrete processors â€” tight coupling
    private readonly StripePaymentProcessor  _stripe;
    private readonly PayPalPaymentProcessor  _paypal;

    public CheckoutService(
        StripePaymentProcessor stripe,
        PayPalPaymentProcessor paypal)
    {
        _stripe = stripe;
        _paypal = paypal;
    }

    public Task&lt;PaymentResult&gt; ProcessAsync(
        Cart cart, PaymentProvider provider) =&gt; provider switch
    {
        PaymentProvider.Stripe =&gt; _stripe.ChargeAsync(/* ... */),
        PaymentProvider.PayPal =&gt; _paypal.ChargeAsync(/* ... */),
        // Adding Adyen: must modify CheckoutService â€” DIP violation!
        _ =&gt; throw new NotSupportedException()
    };
}

// âœ“ AFTER â€” High-level depends on abstractions (DIP enforced)
public sealed class CheckoutService
{
    // Depends only on abstractions â€” never on Stripe or PayPal classes
    private readonly IPaymentProcessorFactoryResolver _resolver;

    public CheckoutService(IPaymentProcessorFactoryResolver resolver)
        =&gt; _resolver = resolver;

    public async Task&lt;PaymentResult&gt; ProcessAsync(
        Cart cart, PaymentProvider provider, CancellationToken ct = default)
    {
        var request = new PaymentRequest(
            IdempotencyKey:       Guid.NewGuid().ToString(),
            AmountInSmallestUnit: cart.TotalInCents,
            Currency:             cart.Currency,
            PaymentMethodToken:   cart.PaymentMethodToken,
            CustomerId:           cart.CustomerId);

        // Depends on abstraction â€” resolver is also an abstraction
        var factory = _resolver.Resolve(provider);   // â† abstract
        return await factory.ProcessPaymentAsync(request, ct);  // â† abstract
        // StripePaymentProcessor? PayPalPaymentProcessor?
        // CheckoutService has NO IDEA. DIP achieved.
    }
}

// Dependency arrows (high â†’ low, all pointing at abstractions):
// CheckoutService â†’ IPaymentProcessorFactoryResolver (abstraction)
// CheckoutService â†’ PaymentProcessorFactory (abstraction)
// CheckoutService â†’ IPaymentProcessor (abstraction)
//
// StripePaymentProcessor â† IPaymentProcessor (implements)
// StripeProcessorFactory â† PaymentProcessorFactory (extends)
// The arrows never go from CheckoutService â†’ StripePaymentProcessor directly.</code></pre></div>
      </div>

      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-check"></i> What DIP Enables in Testing</div>
        Because <code>CheckoutService</code> depends only on <code>IPaymentProcessorFactoryResolver</code>, unit tests pass a <code>Mock&lt;IPaymentProcessorFactoryResolver&gt;</code> that returns a <code>Mock&lt;PaymentProcessorFactory&gt;</code>. No real HTTP calls. No API keys. No Stripe sandbox. Tests run in milliseconds with full control over every edge case â€” declined cards, network timeouts, 3D Secure triggers â€” all without touching a real payment API.
      </div>
    </div>
  </div>

</section>

<!-- END PHASE 2 -->
<!-- ============================================================ SECTION 13 -->
<section id="s13" class="section">
  <div class="section-header">
    <div class="section-icon cyan"><i class="fa-solid fa-scale-balanced"></i></div>
    <div><div class="section-num">Section 13</div><h2 class="section-title">Pattern Comparisons</h2></div>
  </div>

  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-table-columns" style="color:var(--accent-cyan)"></i> Factory Method vs Related Patterns</div>
    <div class="card-body">
      <p class="body-text">Understanding how Factory Method relates to its neighbours â€” Abstract Factory, Simple Factory, Builder, and Prototype â€” is a critical interview skill. The table below maps each dimension so you can make a precise, confident choice in any design scenario.</p>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>Dimension</th>
              <th style="color:#06b6d4;">Factory Method</th>
              <th style="color:#8b5cf6;">Abstract Factory</th>
              <th style="color:#94a3b8;">Simple Factory</th>
              <th style="color:#f59e0b;">Builder</th>
              <th style="color:#10b981;">Prototype</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Intent</strong></td>
              <td>Define interface for creating one product; subclasses decide type</td>
              <td>Create families of related products without specifying concrete classes</td>
              <td>Centralise <code>switch/if</code> object creation in one static method</td>
              <td>Construct complex object step-by-step, separating construction from representation</td>
              <td>Clone an existing object instead of constructing from scratch</td>
            </tr>
            <tr>
              <td><strong>Mechanism</strong></td>
              <td>Inheritance â€” override a factory method in subclass</td>
              <td>Composition â€” inject/swap an entire factory object</td>
              <td>Static method with conditional logic (not a real GoF pattern)</td>
              <td>Fluent method chain; separate Director + Builder classes</td>
              <td><code>ICloneable</code> / deep-copy method on the product itself</td>
            </tr>
            <tr>
              <td><strong>Who decides type</strong></td>
              <td>Concrete Creator subclass (at compile-time or DI registration)</td>
              <td>Client chooses which concrete factory; factory decides products</td>
              <td>A <code>switch</code> statement in a static class</td>
              <td>Director + concrete Builder; no type switching</td>
              <td>The prototype registry or the cloning caller</td>
            </tr>
            <tr>
              <td><strong>Runtime vs Compile-time</strong></td>
              <td>Runtime â€” inject different Creator via DI</td>
              <td>Runtime â€” swap entire factory family</td>
              <td>Runtime â€” but adding a case requires modifying source</td>
              <td>Runtime â€” builder steps compose different representations</td>
              <td>Runtime â€” different prototypes registered in registry</td>
            </tr>
            <tr>
              <td><strong>Product complexity</strong></td>
              <td>Simple to moderately complex; single product per factory</td>
              <td>Families of related products (e.g., Button + Checkbox + Dialog for same theme)</td>
              <td>Simple products; logic lives entirely in the factory</td>
              <td>High complexity â€” many optional parts, multi-step construction</td>
              <td>Any complexity â€” you copy whatever already exists</td>
            </tr>
            <tr>
              <td><strong>Extension mechanism</strong></td>
              <td>Add new Creator subclass; zero modification to existing code</td>
              <td>Add new concrete factory class implementing the abstract factory interface</td>
              <td>Modify the static method â€” violates OCP</td>
              <td>Add new concrete Builder class; Director unchanged</td>
              <td>Register new prototype in registry; no class changes</td>
            </tr>
            <tr>
              <td><strong>OCP compliance</strong></td>
              <td>Yes â€” new variants via new subclass</td>
              <td>Yes â€” new family via new factory class</td>
              <td>No â€” must edit the switch/if</td>
              <td>Yes â€” new Builder for new representation</td>
              <td>Yes â€” register new prototype without changing existing code</td>
            </tr>
            <tr>
              <td><strong>Number of classes</strong></td>
              <td>Medium â€” 1 interface + N Creators + N Products</td>
              <td>High â€” 1 abstract factory + N concrete factories + M product interfaces + NÃ—M products</td>
              <td>Very Low â€” 1 static class</td>
              <td>Medium â€” 1 interface + N Builders + 1 Director + 1 Product</td>
              <td>Low â€” product must implement <code>Clone()</code>; registry is optional</td>
            </tr>
            <tr>
              <td><strong>Best for</strong></td>
              <td>Plugin systems, payment gateways, multi-tenant SaaS, provider switching</td>
              <td>UI theme kits, cross-platform widget libraries, database dialect families</td>
              <td>Small, stable sets of types (2-3 variants, no growth expected)</td>
              <td>HTTP request pipelines, query builders, email composers, report generators</td>
              <td>Game object spawning, document templating, configuration presets</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="grid-2" style="margin-top:1.5rem;">
        <div class="callout callout-info">
          <div class="callout-title"><i class="fa-solid fa-arrows-split-up-and-left"></i> Factory Method vs Abstract Factory â€” The Fractal Relationship</div>
          <p style="color:var(--text-secondary);font-size:0.95rem;">Abstract Factory is often implemented using Factory Methods. Each product creation method in an Abstract Factory <em>is</em> a Factory Method. The difference is scope: Factory Method focuses on one product type, Abstract Factory coordinates a family. When you find yourself needing multiple Factory Methods that must be consistent with each other (e.g., <code>CreateButton()</code> and <code>CreateDialog()</code> must match the same theme), that is the signal to upgrade to Abstract Factory.</p>
        </div>
        <div class="callout callout-warning">
          <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> Simple Factory â€” Not a GoF Pattern</div>
          <p style="color:var(--text-secondary);font-size:0.95rem;">Simple Factory is a refactoring move, not a design pattern. It centralises type-decision logic but does not achieve OCP compliance. Use it only when the set of variants is small, stable, and entirely under your control. The moment a third team needs to add a variant without editing your code, upgrade to Factory Method. Simple Factory is a step on the road â€” not the destination.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-diagram-project" style="color:var(--accent-cyan)"></i> Senior Decision Tree â€” Which Creation Pattern to Use</div>
    <div class="card-body">
      <p class="body-text">When a senior engineer faces an object creation problem, they run through a mental decision tree. Here is that tree made explicit â€” use it in design discussions and system design interviews to demonstrate architectural thinking.</p>
      <div class="mermaid-container">
        <span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
        <div class="mermaid">
flowchart TD
    A["Need to create objects whose concrete type varies?"] -->|"NO"| B["Just use new â€” no pattern needed"]
    A -->|"YES"| C["Need a FAMILY of related objects that must stay consistent?"]
    C -->|"YES"| D["Abstract Factory"]
    C -->|"NO"| E["Construction complex â€” 5+ params, optional parts, multi-step?"]
    E -->|"YES"| F["Builder"]
    E -->|"NO"| G["Construction expensive â€” DB load, ML model, deep copy?"]
    G -->|"YES"| H["Prototype â€” clone from cached instance"]
    G -->|"NO"| I["How many variants do you have or expect?"]
    I -->|"2-3, stable, never growing"| J["Simple Factory â€” centralise the switch"]
    I -->|"4 or more, or expect growth"| K["Factory Method â€” subclass per variant"]
    K --> L["Will different teams own different variants?"]
    L -->|"YES"| M["Factory Method via DI registration â€” each team registers their Creator"]
    L -->|"NO"| N["Factory Method via inheritance or interface â€” single-codebase solution"]

    style B fill:#1e3a2a,stroke:#10b981,color:#6ee7b7
    style D fill:#2d1b4e,stroke:#8b5cf6,color:#c4b5fd
    style F fill:#3a2a00,stroke:#f59e0b,color:#fcd34d
    style H fill:#1a3a2a,stroke:#10b981,color:#6ee7b7
    style J fill:#1e2a3a,stroke:#3b82f6,color:#93c5fd
    style K fill:#1e1b4b,stroke:#6366f1,color:#a5b4fc
    style M fill:#1e1b4b,stroke:#6366f1,color:#a5b4fc
    style N fill:#1e1b4b,stroke:#6366f1,color:#a5b4fc
        </div>
      </div>

      <div class="callout callout-success" style="margin-top:1.5rem;">
        <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> How to Use This Tree in an Interview</div>
        <p style="color:var(--text-secondary);font-size:0.95rem;">When given a design question involving object creation, narrate your traversal of this tree out loud. "I see we have multiple payment providers that will grow â€” so I rule out Simple Factory. The construction is straightforward, no 5-step pipeline â€” so not Builder. I don't need a family of related objects â€” so not Abstract Factory. I'm going with Factory Method." This demonstrates that you considered alternatives, not just that you knew one pattern.</p>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 14 -->
<section id="s14" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-comments"></i></div>
    <div><div class="section-num">Section 14</div><h2 class="section-title">Interview Q&amp;As</h2></div>
  </div>

  <div class="callout callout-info" style="margin-bottom:1.5rem;">
    <div class="callout-title"><i class="fa-solid fa-circle-info"></i> How to Use This Section</div>
    <p style="color:var(--text-secondary);font-size:0.95rem;">25 interview questions spanning Beginner through Principal level. Each entry includes a plain-English thinking guide, a complete answer with code, and a "what separates good from great" insight. All jargon terms are explained in simple language right where they appear. Click any question to expand it. The first question opens by default.</p>
  </div>

  <!-- Q1 -->
  <div class="qa-item active" id="qa1">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q1. What is the Factory Method pattern and why does it exist? <span class="badge badge-green">Beginner</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Conceptual</span> &nbsp; Follow-up: How does it differ from simply calling <code>new</code>?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> Don't start with the textbook definition. Start with a real problem: "Right now my code creates a Stripe payment processor directly with <code>new StripeProcessor()</code>. But what happens when my boss says 'we also need PayPal'? I'd have to find every single place in the code where I wrote <code>new StripeProcessor()</code> and add an if-else check. That gets messy fast, and it's easy to miss spots." That's the exact problem Factory Method solves.<br><br>
        Think of it as three problems getting worse over time: (1) your main code knows too much about which specific class to create, (2) adding a new payment provider means digging through old code and editing it â€” you could break something, (3) you can't easily swap providers at runtime (e.g., based on a feature flag or customer preference). Factory Method solves all three by putting the "which class to create" decision in one dedicated place.
      </div>
      <p class="body-text">The Factory Method pattern is like a recipe that says "make a payment processor" without specifying which one. The base class (the recipe) says "I need a processor to do my work" but doesn't decide whether it's Stripe, PayPal, or Square. That decision is left to the <strong>subclasses</strong> (child classes that extend the base class) â€” each one fills in the blank with its own specific processor. This way, the main code never needs to know or care which payment provider is being used.</p>
      <p class="body-text">It exists because the alternative â€” writing <code>new StripeProcessor()</code> directly all over your code â€” creates <strong>tight coupling</strong> (your code is glued to one specific class and can't work with anything else). When you add a third provider, you have to hunt down every place in the codebase that hardcodes a provider and update it. Miss one spot and you have a bug. The Factory Method puts that decision in exactly one place, so the rest of the system doesn't need to change at all when you add a new provider.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PaymentFactory.cs â€” core concept</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// The creator defines the contract
public abstract class PaymentProcessorFactory
{
    // The factory method â€” subclasses decide the type
    protected abstract IPaymentProcessor CreateProcessor();

    public PaymentResult Process(PaymentRequest req)
    {
        var processor = CreateProcessor(); // type is unknown here
        return processor.Process(req);
    }
}

// Concrete creators supply the type
public class StripeFactory : PaymentProcessorFactory
{
    protected override IPaymentProcessor CreateProcessor()
        => new StripeProcessor(_config.StripeKey);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer explains this insight: the base creator class is fully working and useful even though it has no idea what specific object it's creating. The factory method is like a blank slot that subclasses fill in. This is actually the <strong>Template Method pattern</strong> (a pattern where a base class defines the steps of a process, but lets subclasses fill in certain steps) applied to object creation. Great candidates also contrast this with a simple static factory method: "Both put creation code in one place, but only Factory Method lets you add a new provider by adding a new subclass â€” you never need to edit the existing factory code. That's called the Open/Closed Principle: open for adding new things, closed for changing existing things."</div>
    </div></div>
  </div>

  <!-- Q2 -->
  <div class="qa-item" id="qa2">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q2. Why is the factory method abstract/virtual rather than concrete? <span class="badge badge-green">Beginner</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Conceptual</span> &nbsp; Follow-up: What happens if you give it a default implementation?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> Think about what <code>abstract</code> vs <code>virtual</code> are saying to developers. <code>abstract</code> says "you MUST provide this â€” there's no default." <code>virtual</code> says "you CAN override this â€” here's a sensible starting point if you don't." The choice reveals what the designer intended.<br><br>
        Then ask: what would a default implementation mean? It means "if no subclass overrides this method, use Stripe (or whatever the default is)." That's totally fine â€” it just means Stripe is the fallback. The <code>abstract</code> version says there IS no fallback; every subclass must make an explicit choice. If you forget to override an abstract method, the code won't even compile â€” which is a great safety net.
      </div>
      <p class="body-text">The factory method is <code>abstract</code> when there is no sensible default â€” every subclass MUST pick a specific processor. This is like a job application form with a required field: you literally cannot submit it blank. It prevents accidents â€” you cannot accidentally create a subclass that returns <code>null</code> or a broken stub because it forgot to specify a processor. It is <code>virtual</code> when a reasonable default exists but can be overridden. For example, a factory might default to Stripe but let a subclass choose PayPal instead.</p>
      <p class="body-text">In practice, <code>virtual</code> with a default is common in framework design where you need backwards compatibility â€” old subclasses that don't override still get a working product. <code>abstract</code> is preferred in your own application code where every variant must be deliberate and explicit. Making it abstract also acts as built-in documentation: anyone creating a new subclass is forced by the compiler to think about what it creates.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">AbstractVsVirtual.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Abstract â€” MUST override; no default type
public abstract class ProcessorFactory
{
    protected abstract IPaymentProcessor CreateProcessor(); // required
}

// Virtual â€” CAN override; Stripe is the default
public class DefaultProcessorFactory
{
    protected virtual IPaymentProcessor CreateProcessor()
        => new StripeProcessor(); // default, overridable

    // Subclass only overrides for non-Stripe providers
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mention the <strong>Liskov Substitution Principle</strong> (LSP â€” a rule that says subclasses should behave correctly when used in place of their parent class) angle here: a <code>virtual</code> factory method with a default creates a silent risk. A developer creates a new subclass, forgets to override the factory method, and accidentally gets Stripe when they meant PayPal. No compiler error, no runtime error â€” just wrong behaviour that's hard to track down. Using <code>abstract</code> prevents this silent failure entirely. Great candidates also mention a simpler alternative: instead of an abstract class, use an interface like <code>IPaymentProcessorFactory</code> with a single <code>CreateProcessor()</code> method. An interface is even cleaner â€” it just defines the contract with zero implementation code.</div>
    </div></div>
  </div>

  <!-- Q3 -->
  <div class="qa-item" id="qa3">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q3. What is the relationship between Factory Method and Template Method? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Conceptual</span> &nbsp; Follow-up: Can you have a Factory Method that is NOT a Template Method?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> The <strong>Template Method pattern</strong> is when a base class says "here are the steps of the process in order â€” validate, create, execute, log â€” but I'll leave one or more of those steps blank for subclasses to fill in." Factory Method is exactly that, but the blank step is specifically the "create an object" step. So Factory Method IS a Template Method where the deferred step happens to be object creation.<br><br>
        The distinction: Template Method is about controlling the structure of a process (what steps happen and in what order). Factory Method is about one specific kind of step â€” creating an object. Factory Method is like a specialised version of Template Method that only cares about the creation step.
      </div>
      <p class="body-text">The Factory Method is structurally a case of the Template Method pattern. The base creator class lays out the full process â€” validate input, create a processor, execute the transaction, log the result â€” and the <code>CreateProcessor()</code> step is left blank (abstract). Each subclass fills in just that one step differently. This is the Template Method: a fixed sequence of steps with one or more steps that subclasses customize.</p>
      <p class="body-text">You CAN have a Factory Method that is not part of a Template Method â€” when the client calls the factory method directly rather than it being buried inside a base class process. In that case it's purely a creation mechanism. But in the classic textbook usage from the Gang of Four book (GoF â€” the original 1994 design patterns book that named these patterns), the factory method is always called from within the creator's own algorithm, making it simultaneously a Factory Method and a Template Method step.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">TemplateMethod_FactoryMethod.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public abstract class PaymentProcessorFactory // Template Method host
{
    // Algorithm skeleton (Template Method)
    public PaymentResult Process(PaymentRequest req)
    {
        Validate(req);
        var processor = CreateProcessor(); // Factory Method step
        var result = processor.Process(req);
        Log(result);
        return result;
    }

    protected abstract IPaymentProcessor CreateProcessor(); // Factory Method
    private void Validate(PaymentRequest r) { /* ... */ }
    private void Log(PaymentResult r) { /* ... */ }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer references the GoF book directly: it literally says "Factory Method is often called from within template methods." Mentioning this shows you've read the original source, not just blog summaries. Also point out that despite looking similar, these two patterns are categorised differently: Template Method is a <strong>behavioural pattern</strong> (about how things do their work â€” the process structure), while Factory Method is a <strong>creational pattern</strong> (about how objects get created). Same structure, different intent. That distinction â€” same mechanism, different purpose â€” is what interviewers are really testing when they ask this question.</div>
    </div></div>
  </div>

  <!-- Q4 -->
  <div class="qa-item" id="qa4">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q4. How does Factory Method interact with DI containers? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Conceptual</span> &nbsp; Follow-up: What is a keyed service and when would you use it?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> A <strong>DI container</strong> (Dependency Injection container â€” a framework feature that automatically creates and provides objects your code needs) is basically a fancy factory registry. When you write <code>services.AddTransient&lt;IPaymentProcessor, StripeProcessor&gt;()</code> (<code>AddTransient</code> tells the framework to create a brand-new instance every time it's asked â€” as opposed to reusing one shared instance), you're saying "whenever someone asks for an IPaymentProcessor, create a StripeProcessor." That IS a factory method â€” the container IS the factory. You just didn't write the factory class yourself; the framework does it for you.<br><br>
        The interesting problem: what if you need MULTIPLE implementations of the same interface in the same app? Like, sometimes you want Stripe and sometimes PayPal, depending on the situation. That's where <strong>keyed services</strong> (a .NET 8 feature that lets you register multiple implementations under different names/keys) come in.
      </div>
      <p class="body-text">In ASP.NET Core, <strong>DI registration</strong> (telling the framework which class to create for which interface) is the modern, practical replacement for the classic Factory Method subclass approach. Instead of creating a <code>StripePaymentProcessorFactory</code> subclass, you register <code>StripeProcessor</code> for the <code>IPaymentProcessor</code> interface. The DI container becomes the factory â€” the decision of which class to create happens at registration time in <code>Program.cs</code>. The Factory Method pattern is still there, just implicit and handled by the framework instead of your own code.</p>
      <p class="body-text">.NET 8 added keyed services, which directly solve the "multiple implementations of the same interface" problem: register multiple implementations under different string keys (like "stripe", "paypal"), then resolve by key at runtime. This lets you pick the right provider based on tenant config or feature flags without writing explicit factory classes. For older .NET versions, the common workaround is registering all implementations and injecting <code>IEnumerable&lt;IPaymentProcessor&gt;</code>, then picking the right one by checking a property on each.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Program.cs â€” keyed services (.NET 8)</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Registration â€” keyed by provider name
builder.Services.AddKeyedTransient&lt;IPaymentProcessor, StripeProcessor&gt;("stripe");
builder.Services.AddKeyedTransient&lt;IPaymentProcessor, PayPalProcessor&gt;("paypal");

// Explicit factory delegate â€” resolve at runtime by tenant config
builder.Services.AddTransient&lt;IPaymentProcessorFactory, PaymentProcessorFactory&gt;();

// Resolution inside factory
public class PaymentProcessorFactory(IServiceProvider sp, ITenantConfig cfg)
    : IPaymentProcessorFactory
{
    public IPaymentProcessor Create()
        => sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(cfg.Provider);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mention the <strong>lifetime mismatch trap</strong> â€” this is a common bug. In ASP.NET Core, objects have different lifetimes: <strong>Singleton</strong> (created once, lives forever), <strong>Scoped</strong> (created once per web request), and <strong>Transient</strong> (created fresh every time). If your factory is a Singleton but it grabs a Scoped service (like a database context) directly in its constructor, that Scoped service gets trapped in the Singleton and lives forever â€” never refreshed, never cleaned up. In practice this means stale database data â€” the same database snapshot from when the app first started is used forever, even as rows are inserted and updated. This is called a <strong>captive dependency</strong>. The fix is to inject <code>IServiceProvider</code> into the factory and only resolve the Scoped service inside the <code>Create()</code> method (at the moment it's needed, not at construction time). Great candidates also separate two concepts: what dependencies the factory itself needs (inject those in the constructor) vs what dependencies the created product needs (resolve those at creation time).</div>
    </div></div>
  </div>

  <!-- Q5 -->
  <div class="qa-item" id="qa5">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q5. When would Factory Method be over-engineering? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Conceptual</span> &nbsp; Follow-up: What is the YAGNI principle and how does it apply here?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> A pattern is over-engineering when it adds more complexity than it removes. Ask yourself honestly: "What's the actual cost of NOT using Factory Method here?" If the answer is "nothing â€” there's only one payment provider and that's not going to change," then you're paying the full cost of extra classes and extra indirection without getting any of the benefits.<br><br>
        <strong>YAGNI</strong> â€” "You Aren't Gonna Need It" â€” is a programming principle that says: don't build infrastructure for imaginary future requirements. If you have one payment provider and no concrete plans for a second, creating a whole factory hierarchy is building for a future that may never come.
      </div>
      <p class="body-text">Factory Method is over-engineering when: (1) there is exactly one implementation today and no realistic path to a second one, (2) the codebase is a short-lived script or a simple command-line tool where long-term maintainability isn't the goal, (3) what you're calling "variation" is actually just a different constructor argument â€” if you just pass a different config value, you don't need a whole factory hierarchy, or (4) the DI container already handles it through configuration, making a hand-written factory class pointless duplication.</p>
      <p class="body-text">The practical rule of thumb: if you can't name two concrete implementations that will actually exist in production, don't create the factory abstraction yet. Build it when the second implementation actually arrives â€” at that point you have real evidence of how things vary and you can design the right abstraction for both cases instead of guessing. This refactoring is cheap and low-risk when the code has good tests.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OverEngineering.cs â€” before / after</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// OVER-ENGINEERED â€” only one implementation exists
public abstract class NotificationFactory
{
    protected abstract INotifier CreateNotifier();
}
public class EmailNotificationFactory : NotificationFactory
{
    protected override INotifier CreateNotifier() => new EmailNotifier();
}

// APPROPRIATE â€” just use the class directly
public class OrderService(INotifier notifier) // DI injects it
{
    public void PlaceOrder(Order o) => notifier.Notify(o);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Great candidates give the "rule of three" rule of thumb: tolerate one implementation, do a quick refactor when the second appears, and create a proper abstraction when you're adding the third. Why the third? Because with two implementations you might think you understand the pattern of variation, but the third one confirms it and tells you exactly how the abstraction should be designed. Also mention the hidden cost of premature abstraction: once your team builds code that depends on a factory hierarchy, removing that abstraction is painful â€” everyone is coupled to it. Wrong abstractions are actually more expensive than missing ones, because you have to live with them or do a painful refactor later.</div>
    </div></div>
  </div>

  <!-- Q6 -->
  <div class="qa-item" id="qa6">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q6. Design a payment processor factory with runtime provider switching. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-yellow" style="font-size:0.7rem;">Design Challenge</span> &nbsp; Follow-up: How do you switch providers per-request without redeploying?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <strong>Runtime switching</strong> means the factory can't decide which provider to use when the app starts up â€” it has to wait and check a live signal on every request. That signal could be: a <strong>feature flag</strong> (a setting you can change without redeploying, like a toggle in a dashboard), a tenant config (each customer has their own preference), a request header, or a value from the database.<br><br>
        Break the design into four parts: (1) a lookup table (dictionary/registry) mapping provider names to creation functions, (2) the live signal reader that checks "which provider should I use right now?", (3) the factory method that combines these two â€” look up and call the right creation function, (4) what to do when the provider name is unknown or invalid â€” fail loudly with a useful error message.
      </div>
      <p class="body-text">The key insight for runtime switching is swapping the class hierarchy for a simple lookup table. Instead of creating a subclass for every provider, you register creation functions â€” <code>Func&lt;IPaymentProcessor&gt;</code> <strong>delegates</strong> (a delegate is basically a stored function â€” a variable that holds a method you can call later) â€” keyed by provider name. The factory's <code>CreateProcessor()</code> reads the current context (feature flag, tenant config, HTTP header), looks up the right creation function in the table, and calls it. Adding a new provider means adding one entry to the table â€” you never need to change the factory class itself.</p>
      <p class="body-text">For true per-request switching without redeploying the app, combine the registry approach with a feature flag service. The flag service checks a remote configuration store (a database or a service like Azure App Configuration where flag values are saved) every 30 seconds or so. The factory reads the current flag value fresh on every single call, meaning a flag change takes effect on the very next request â€” no code deployment needed, full rollback in under a minute by just flipping the flag back.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RuntimeSwitchingFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public class PaymentProcessorFactory : IPaymentProcessorFactory
{
    private readonly Dictionary&lt;string, Func&lt;IPaymentProcessor&gt;&gt; _registry;
    private readonly IFeatureFlagService _flags;

    public PaymentProcessorFactory(IServiceProvider sp, IFeatureFlagService flags)
    {
        _flags = flags;
        _registry = new()
        {
            ["stripe"]  = () =&gt; sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;("stripe"),
            ["paypal"]  = () =&gt; sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;("paypal"),
            ["square"]  = () =&gt; sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;("square"),
        };
    }

    public IPaymentProcessor Create()
    {
        var provider = _flags.GetString("payment_provider", defaultValue: "stripe");
        return _registry.TryGetValue(provider, out var factory)
            ? factory()
            : throw new InvalidOperationException($"Unknown provider: {provider}");
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mention <strong>circuit breaker integration</strong> â€” a circuit breaker is like a safety switch: if a service fails too many times in a row, the circuit "opens" and stops sending requests to it for a while (to avoid hammering a broken service). If the runtime-selected provider starts failing, the circuit breaker opens and you automatically fall back to a default provider â€” not through the factory itself, but through a separate resilience layer that wraps the processor call. This separation is important: the factory's only job is deciding which provider to create; the resilience layer's job is deciding what to do when that provider fails. Keep those two jobs separate. Also discuss observability: on every request, log which provider was selected as a structured field (like a JSON property) in your logs, so that if something goes wrong in production you can easily filter logs by provider and trace the issue.</div>
    </div></div>
  </div>

  <!-- Q7 -->
  <div class="qa-item" id="qa7">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q7. Design a factory system resilient to provider outages. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-yellow" style="font-size:0.7rem;">Design Challenge</span> &nbsp; Follow-up: How does your factory know when the primary provider recovers?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> This is really a <strong>resilience design question</strong> wearing factory clothes. The factory's job is picking a provider. Resilience is about what happens when that provider breaks. Think of these as three separate levels of protection, each handling a different failure scenario:<br><br>
        (1) <strong>Request-level retry</strong>: the provider had a blip â€” try the same provider 1-2 more times. (2) <strong>Provider-level fallback</strong>: the provider is truly down â€” switch to a backup provider. (3) <strong>Recovery detection</strong>: the primary provider comes back online â€” switch back to it. Each level has different latency costs (retries slow down individual requests; fallbacks switch the whole system).
      </div>
      <p class="body-text">A resilient factory keeps a priority-ordered list of providers (Stripe first, PayPal second, Square third) and tracks the health status of each. On each <code>Create()</code> call, it picks the highest-priority provider that is currently healthy. When a provider starts throwing errors, it gets marked unhealthy and the next provider in line takes over. A background timer (running every 30 seconds or so) pings unhealthy providers and marks them healthy again when they start responding successfully â€” so your primary provider gets its spot back automatically once it recovers.</p>
      <p class="body-text">The critical design decision: where does the health state live? Option A: inside the factory itself â€” you have full control but you have to write all the state tracking logic yourself. Option B: use <strong>Polly</strong> (a popular .NET resilience library) â€” you get battle-tested state machine logic, a <strong>half-open state</strong> (a state where the circuit breaker allows one test request through to check if the service recovered), and built-in monitoring hooks for free. In production, always use Polly and have the factory check the circuit breaker state to decide which provider to use.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ResilientFactory.cs â€” simplified</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public class ResilientPaymentFactory : IPaymentProcessorFactory
{
    private readonly IReadOnlyList&lt;ProviderEntry&gt; _providers; // priority-ordered

    public IPaymentProcessor Create()
    {
        foreach (var entry in _providers)
        {
            if (entry.CircuitBreaker.State != CircuitState.Open)
                return entry.Factory();
        }
        throw new AllProvidersUnavailableException("All payment providers are unavailable");
    }
}

record ProviderEntry(Func&lt;IPaymentProcessor&gt; Factory, ICircuitBreaker CircuitBreaker);
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mention the <strong>half-open state</strong> â€” when a circuit breaker is half-open, it allows exactly one test request through to the broken provider. If it succeeds, the circuit closes and that provider is back in normal rotation. If it fails, the circuit reopens and waits longer before trying again. The factory must not try to implement its own version of this logic â€” it must respect the circuit breaker's built-in state machine. Also discuss the real-world business cost of silent fallback: Stripe's fees are different from PayPal's fees. If the factory silently switches from Stripe to PayPal under load and no one notices, your company might be paying higher processing fees for days. Always fire an alert or metric on every fallback event so the ops team is immediately aware and can investigate.</div>
    </div></div>
  </div>

  <!-- Q8 -->
  <div class="qa-item" id="qa8">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q8. Your factory creates processors, but each needs different dependencies. How do you handle this? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Debugging</span> &nbsp; Follow-up: What if one processor needs a scoped DbContext?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> Each processor needing different dependencies is completely normal â€” Stripe needs a Stripe API client, PayPal needs a different HTTP client and a currency converter, etc. The real question is: whose job is it to gather all those different dependencies?<br><br>
        Three options: (A) Pass all possible dependencies to the factory and let each processor take what it needs â€” this gets messy and the factory ends up needing to know about every dependency of every processor. (B) Let the DI container handle it â€” the factory just asks "give me a StripeProcessor" and the container figures out all its dependencies automatically. (C) Create separate factory subclasses per provider, each injecting only their own deps â€” clean but verbose. Option B is the standard, practical answer.
      </div>
      <p class="body-text">When the different processors need different dependencies, the cleanest solution is to delegate that problem to the DI container. The factory gets an <code>IServiceProvider</code> (the container) and just asks it: "give me a payment processor with this key." The container already knows what each processor needs (because you registered them with <code>services.AddKeyedTransient</code>), so it handles all their dependencies automatically. The factory doesn't need to know or care what <code>StripeProcessor</code> needs vs what <code>PayPalProcessor</code> needs â€” it just asks for them by name.</p>
      <p class="body-text">For <strong>Scoped dependencies</strong> (like a database context â€” <code>DbContext</code> â€” which is designed to last for the duration of one web request), the factory must NOT grab them from the root container. Why? Because the root container is a Singleton â€” it lives forever. If you grab a Scoped service from there, it gets stuck living forever too, never refreshed. Instead, inject <code>IServiceScopeFactory</code> and create a fresh scope each time a processor needs one. The caller owns disposing that scope when they're done with the processor.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DependencyFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Each processor has its own constructor with its own deps
public class StripeProcessor(StripeClient client, ILogger&lt;StripeProcessor&gt; log)
    : IPaymentProcessor { /* ... */ }
public class PayPalProcessor(PayPalHttpClient client, ICurrencyConverter fx)
    : IPaymentProcessor { /* ... */ }

// Factory delegates to DI â€” zero knowledge of deps
public class PaymentProcessorFactory(IServiceProvider sp) : IPaymentProcessorFactory
{
    public IPaymentProcessor Create(string key)
        => sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(key);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The scope management detail is the key differentiator here. If any processor needs a Scoped dependency (like a DbContext or a per-request cache), resolving it from the root <code>IServiceProvider</code> creates a <strong>captive dependency</strong> â€” the Scoped service gets "captured" by the Singleton factory and ends up living forever, which is wrong and causes subtle bugs (stale data, memory leaks). The correct answer is always <code>IServiceScopeFactory.CreateScope()</code> to create a proper short-lived scope. Also mention that .NET 8's keyed services don't change this rule at all â€” the "key" just tells you which service to pick, but the scope and lifetime rules are exactly the same.</div>
    </div></div>
  </div>

  <!-- Q9 -->
  <div class="qa-item" id="qa9">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q9. The factory works in dev but throws in production. What went wrong? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Debugging</span> &nbsp; Follow-up: How do you prevent environment-specific DI bugs?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> "Works in dev, fails in prod" is the classic environment mismatch bug. Before panicking, work through the most common causes one by one: (1) a provider is registered in dev but not in prod (maybe using a fake/stub for local testing), (2) a config value is different in prod and points to a provider that doesn't exist in the prod DI registrations, (3) scope validation was accidentally turned off in dev, so a bug that would have thrown an error in dev was silently hiding â€” and it only surfaces in prod where the validation is properly enabled.
      </div>
      <p class="body-text">The three most common root causes: (A) The factory reads a provider name from configuration (like an environment variable or appsettings.json) â€” the config value is different in prod, and it asks for a provider that was never registered. (B) The DI registration is wrapped in an <code>if (env.IsDevelopment())</code> block â€” a mock or stub processor exists in dev but not prod. (C) <strong>Scope validation</strong> (a DI container safety feature that checks you're not doing the captive dependency bug) is disabled in dev but enabled in prod. The bug was silently hiding all along in dev, and the first time the validation runs is in production â€” where it throws an error.</p>
      <p class="body-text">Prevention: turn on <code>ValidateScopes = true</code> in all environments including dev and staging â€” you want to catch these bugs locally, not in production. Write integration tests that start the real DI container with production-like configuration and try to resolve every factory-created type. Add a health check endpoint that calls the factory for each supported provider â€” if any provider can't be created, the endpoint reports unhealthy and your deployment pipeline can catch it before traffic starts flowing.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">StartupValidation.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Validate all providers are resolvable at startup
app.MapGet("/health/factory", (IPaymentProcessorFactory factory, IConfiguration cfg) =>
{
    var providers = cfg.GetSection("EnabledProviders").Get&lt;string[]&gt;();
    var results = providers.Select(p =>
    {
        try { factory.Create(p); return (p, ok: true, error: (string?)null); }
        catch (Exception ex) { return (p, ok: false, error: ex.Message); }
    });
    return results.All(r =&gt; r.ok) ? Results.Ok(results) : Results.Problem(...);
});
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mentioning <code>ValidateOnBuild = true</code> (available in .NET 6+) is a great answer. This tells the DI container to validate that all registered services can actually be constructed â€” checking for missing dependencies, wrong lifetimes, etc. â€” right at startup when you call <code>app.Build()</code>. If there's a problem, the app crashes immediately at startup with a clear error, instead of crashing on the first real request from a real user. Also mention the health check endpoint approach: your load balancer monitors health check endpoints to decide whether to send traffic to a server pod. If the health check exercises the factory and it fails, the load balancer stops sending traffic to that pod automatically â€” protecting users before a single real request fails.</div>
    </div></div>
  </div>

  <!-- Q10 -->
  <div class="qa-item" id="qa10">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q10. Factory Method vs Abstract Factory â€” when do you choose which? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Comparison</span> &nbsp; Follow-up: Can Factory Method evolve into Abstract Factory?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> The single most important distinction is "one thing vs a family of related things." Factory Method creates ONE type of object. <strong>Abstract Factory</strong> creates MULTIPLE related objects that must all be from the same "family" to work together correctly.<br><br>
        Ask yourself this question: "If I swap the provider, do I need to swap MULTIPLE related objects together to keep everything consistent?" YES â†’ Abstract Factory. "Do I just need one object that varies?" YES â†’ Factory Method. That's the whole decision.
      </div>
      <p class="body-text">Choose Factory Method when you need to create a single thing that varies by context. Payment gateway example: you create ONE processor, and that processor handles everything. Choose <strong>Abstract Factory</strong> (a pattern that creates a whole family of related objects together) when you need multiple related objects that MUST all match each other â€” like a payment suite that includes a processor, a refund handler, AND a fraud detector, all from the same payment provider. Using Stripe's processor with PayPal's fraud detector would be incorrect â€” they're not designed to work together. Abstract Factory enforces that all objects in the family come from the same provider.</p>
      <p class="body-text">Factory Method can naturally grow into Abstract Factory. You start simple: just a Factory Method for a single processor. Over time, you discover the processor always needs a matching refund handler and webhook validator from the same provider â€” they form a family. You've just identified the need for Abstract Factory. You expand the factory interface to include all three creation methods. This is a natural evolution, not a design mistake â€” you built the simpler thing first and expanded when the real need appeared.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FM_vs_AF.cs â€” evolution</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Factory Method â€” single product
public interface IPaymentProcessorFactory
{
    IPaymentProcessor CreateProcessor();
}

// Abstract Factory â€” consistent family
public interface IPaymentSuiteFactory
{
    IPaymentProcessor  CreateProcessor();
    IRefundHandler     CreateRefundHandler();
    IFraudDetector     CreateFraudDetector();
    IWebhookValidator  CreateWebhookValidator();
    // All four MUST be from the same provider
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The "consistency constraint" insight is the key. Abstract Factory is NOT just "Factory Method with more methods" â€” it's specifically about ensuring that multiple created objects are compatible with each other because they're from the same family. If you can freely mix and match objects from different providers without any problems, then you don't have a family relationship at all â€” you just need several independent Factory Methods. The family constraint is what makes Abstract Factory different. Great candidates give a concrete counter-example: "If Stripe's processor can safely be used alongside PayPal's fraud detector with no issues, there's no family relationship â€” use separate Factory Methods. Only use Abstract Factory when mixing providers would actually break something."</div>
    </div></div>
  </div>

  <!-- Q11 -->
  <div class="qa-item" id="qa11">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q11. How does ILoggerFactory in ASP.NET Core use Factory Method? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Framework</span> &nbsp; Follow-up: How would you replicate this pattern in your own framework code?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <code>ILoggerFactory</code> is a real-world Factory Method built right into the ASP.NET Core framework. You use it every time you log something. The caller asks for a logger by category name (usually the class name). The factory decides which logging backend handles it â€” Console, Serilog, Application Insights, etc. The caller has no idea and doesn't care.<br><br>
        Walk through the concrete mechanism step by step: <code>ILoggerFactory.CreateLogger(categoryName)</code> is the factory method. The different logging backends (Serilog, NLog, Console provider) each implement their own version of this method, returning their specific <code>ILogger</code> implementation. The caller always gets back an <code>ILogger</code> interface and calls <code>.LogInformation()</code> â€” same code regardless of which backend is actually writing the logs.
      </div>
      <p class="body-text"><code>ILoggerFactory</code> is a <strong>Singleton</strong>-registered factory (registered once, shared across the whole app) that produces <code>ILogger</code> instances identified by a category name â€” typically the class name, like "OrderService". The factory method is <code>CreateLogger(string categoryName)</code>. At startup, you configure which logging providers are active (Serilog writes to files, Application Insights sends to Azure, Console prints to terminal). When <code>OrderService</code> calls <code>CreateLogger&lt;OrderService&gt;()</code>, it gets back a working logger without knowing anything about where logs are actually going.</p>
      <p class="body-text">To replicate this pattern in your own code: define an <code>IXxxFactory</code> interface with a <code>Create(string key)</code> method, register it as Singleton in DI, and have the constructor receive all registered providers via <code>IEnumerable&lt;IProvider&gt;</code> (a way for the DI container to give you ALL registered implementations of an interface at once). The factory's <code>Create</code> method picks the right provider by key. This is exactly how <code>LoggerFactory</code> internally works â€” it loops through all registered <code>ILoggerProvider</code> instances and calls each one's <code>CreateLogger()</code>.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ILoggerFactory_Pattern.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// How Microsoft implements it (simplified)
public class LoggerFactory : ILoggerFactory
{
    private readonly ILoggerProvider[] _providers; // Serilog, NLog, Console...

    public ILogger CreateLogger(string categoryName)
    {
        // Each provider creates its logger; composite fans out to all
        var loggers = _providers.Select(p =&gt; p.CreateLogger(categoryName)).ToArray();
        return new CompositeLogger(loggers);
    }
}

// Usage â€” caller is decoupled from all providers
public class OrderService(ILogger&lt;OrderService&gt; log)
{
    public void PlaceOrder() =&gt; log.LogInformation("Order placed");
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Notice what LoggerFactory actually does â€” it doesn't pick ONE logging provider. It creates a logger from EVERY registered provider and wraps them all in a <strong>CompositeLogger</strong> (a Composite pattern â€” a wrapper that looks like a single logger but internally fans out to multiple loggers). This means every single log entry goes to ALL sinks at the same time â€” Console AND Serilog AND Application Insights. It's a Factory Method combined with the Composite pattern working together. Great candidates also note the extension model: you add a new logging provider by implementing <code>ILoggerProvider</code> and calling <code>AddProvider()</code> â€” the factory never needs to change. That's the <strong>Open/Closed Principle</strong> (OCP â€” open for adding new things without modifying existing code) demonstrated in the framework itself.</div>
    </div></div>
  </div>

  <!-- Q12 -->
  <div class="qa-item" id="qa12">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q12. How would you unit test a factory that depends on IServiceProvider? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Testing</span> &nbsp; Follow-up: What makes a factory hard to test, and how do you fix it?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <code>IServiceProvider</code> inside a factory is essentially a <strong>Service Locator</strong> (a pattern where you ask a central registry "give me an object of this type" â€” it's like a lookup table for objects). Testing a factory that uses it means choosing one of three approaches: (A) <strong>mock</strong> (fake) the <code>IServiceProvider</code> to return stub processors â€” you control what it returns, (B) build a real DI container in the test and register real or stub implementations, or (C) refactor the factory to accept specific delegates instead of the whole container â€” then testing is trivial.<br><br>
        Option C is cleanest for unit tests (no mocking framework needed). Option B is best for integration tests that verify your registrations are correct. You need both.
      </div>
      <p class="body-text">The cleanest way to unit test a factory that uses <code>IServiceProvider</code>: mock the container using a library like NSubstitute or Moq (popular C# testing libraries that let you create fake versions of interfaces without writing a real class). Tell the mock "when someone calls <code>GetKeyedService&lt;IPaymentProcessor&gt;("stripe")</code>, return this stub processor." This tests the factory's routing logic â€” does key "stripe" map to the right type? â€” in complete isolation from the real DI container. An even better approach: refactor the factory to accept <code>Func&lt;IPaymentProcessor&gt;</code> <strong>delegates</strong> (stored functions) in its constructor instead of the full <code>IServiceProvider</code>. Delegates can be tested with simple lambdas â€” no mocking library needed at all.</p>
      <p class="body-text">For testing that your DI registrations are correct (all expected providers are registered and can be resolved), write <strong>integration tests</strong> that start the real <code>WebApplication</code> and resolve each provider by key. This catches bugs that unit tests can't catch â€” like forgetting to add <code>services.AddKeyedTransient</code> for a provider. Both test types are needed: unit tests check the routing logic, integration tests check the wiring.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FactoryTests.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">[Fact]
public void Create_ReturnsStripeProcessor_WhenFlagIsStripe()
{
    var stripe = Substitute.For&lt;IPaymentProcessor&gt;();
    var sp = Substitute.For&lt;IServiceProvider&gt;();
    sp.GetKeyedService&lt;IPaymentProcessor&gt;("stripe").Returns(stripe);
    var flags = Substitute.For&lt;IFeatureFlagService&gt;();
    flags.GetString("payment_provider", Arg.Any&lt;string&gt;()).Returns("stripe");

    var factory = new PaymentProcessorFactory(sp, flags);
    var result = factory.Create();

    Assert.Same(stripe, result);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer describes the delegate-injection refactor in detail: instead of injecting the entire <code>IServiceProvider</code> (which hides what the factory actually needs), inject a dictionary mapping string keys to processor factory delegates. Now the factory has zero dependency on the DI container at all â€” it's a plain class that maps keys to creation functions. You can unit test it with simple lambdas like <code>{ "stripe", () => new FakeStripeProcessor() }</code> â€” no mocking library, no container setup. The constructor signature also becomes self-documenting: you can see exactly which providers are supported just by looking at what the factory accepts. The tradeoff to acknowledge: registering everything in <code>Program.cs</code> becomes more verbose since you build the dictionary manually.</div>
    </div></div>
  </div>

  <!-- Q13 -->
  <div class="qa-item" id="qa13">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q13. Your factory-created processors leak memory under load. Debug it. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Production</span> &nbsp; Follow-up: How do you detect the leak before it hits production?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> A <strong>memory leak</strong> is when objects stay alive in memory long after you're done with them, slowly eating up RAM until the app crashes or gets slow. Factory-related leaks usually come from one of three sources: (1) the factory creates objects that hold unmanaged resources (things the .NET garbage collector does NOT automatically clean up â€” like file handles or raw network connections opened at the operating system level, which must be explicitly closed by your code) that are never properly closed, (2) factory-created objects get stored in a Singleton collection (a list that lives forever) and the list grows forever, (3) factory-created objects subscribe to events on a long-lived object, and that subscription keeps them alive even after you think they're gone.<br><br>
        The debugging workflow: use a memory profiling tool (like dotMemory or PerfView), take a snapshot of what's in memory before and after running the app under load, compare what's alive, and trace backwards to find what's keeping objects alive.
      </div>
      <p class="body-text">The most common factory-related memory leak: the factory creates a new processor on each call, the processor subscribes to an event on a Singleton object (like "config changed â€” reload settings"), but the processor is never explicitly disposed and nobody removes the event subscription. The Singleton holds a reference to the event handler, which holds a reference to the processor. The processor can't be garbage collected because something is still pointing at it. Every call to the factory creates one more processor that's quietly stuck in memory forever. It's especially sneaky with factories because you don't have a variable holding the processor â€” you think the factory "let it go" but the event source is secretly keeping it alive.</p>
      <p class="body-text">How to catch this before production: write a load test that creates and throws away N processors, then force a <strong>garbage collection</strong> (the automatic process that cleans up objects no longer in use) with <code>GC.GetTotalMemory(true)</code> and measure how much memory is left. If memory grows proportionally with N (create 100 processors, memory goes up by X; create 1000 processors, memory goes up by 10X), you have a leak. Use the <code>dotnet-counters</code> monitoring tool during load tests to watch the GC heap size â€” if it keeps climbing with no plateau or drops, that's a red flag worth stopping a deployment for.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LeakDetection.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Leak scenario â€” event subscription never removed
public class StripeProcessor : IPaymentProcessor
{
    public StripeProcessor(IConfigService cfg)
    {
        cfg.OnChanged += Reload; // LEAK: cfg is Singleton; holds strong ref
    }
    private void Reload(object? s, EventArgs e) { /* ... */ }
    // Missing: IDisposable + cfg.OnChanged -= Reload in Dispose()
}

// Fix â€” implement IDisposable
public void Dispose() =&gt; _cfg.OnChanged -= Reload;
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mentioning <strong>weak event patterns</strong> shows advanced knowledge. A normal event subscription holds a "strong reference" â€” the event source keeps the subscriber alive. A weak reference is like holding a piece of string attached to a helium balloon â€” if nothing else holds the balloon, it flies away even though your string is still there. WeakEventManager (a WPF utility) implements this so processors can subscribe to events without staying alive just because of the subscription. Also mention the ownership question: if the factory creates objects that implement <code>IDisposable</code> (an interface that signals "this object needs cleanup when you're done"), document clearly in the API whether the factory or the caller is responsible for calling <code>Dispose()</code>. Great candidates also mention adding a guard in <code>Dispose()</code> so calling it twice doesn't throw an exception â€” a simple <code>if (_disposed) return;</code> check.</div>
    </div></div>
  </div>

  <!-- Q14 -->
  <div class="qa-item" id="qa14">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q14. How do you version factory-created products when APIs change? <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Architecture</span> &nbsp; Follow-up: How do you run v1 and v2 processors simultaneously during migration?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> Versioning factory products is fundamentally an interface evolution problem â€” how do you change what the factory creates without breaking the code that uses it? You have three options: (1) create a new versioned interface name (like <code>IPaymentProcessorV2</code>), (2) add a version parameter to the factory method, (3) use an <strong>Adapter pattern</strong> (a wrapper that makes the new version look like the old interface to callers who haven't updated yet).<br><br>
        The one non-negotiable constraint: you cannot break existing callers. Everything that currently uses <code>IPaymentProcessor</code> must keep working while you're transitioning.
      </div>
      <p class="body-text">The recommended approach: never rename the interface. Instead, keep <code>IPaymentProcessor</code> the same interface name â€” the version is an internal implementation detail that callers never see. When Stripe releases a new API, create <code>StripeProcessorV2</code> that implements the same <code>IPaymentProcessor</code> interface but uses the new Stripe API under the hood. Register it alongside the old <code>StripeProcessor</code> and use a feature flag to gradually route traffic to v2. Use the <strong>Adapter pattern</strong> (a wrapper class that makes a new incompatible API look like the old familiar interface) when the new Stripe SDK has a completely different API shape â€” the adapter translates between them.</p>
      <p class="body-text">Running v1 and v2 simultaneously is the <strong>canary/shadow pattern</strong> (<strong>canary</strong> â€” named after 'canary in a coal mine' â€” you send a small amount of real traffic to the new version first; if something goes wrong, only a tiny fraction of users are affected): start with 0% of traffic going to v2. Gradually increase to 5%, 25%, 50%, 100% over days or weeks. In "shadow mode," both versions process the same requests, but only v1's response goes back to the customer. You compare v2's result against v1's in the background â€” if they match, v2 is working correctly. Only increase the percentage when you're confident. This is how you migrate a live system to a new API with zero downtime and zero risk to customers.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">VersionedFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public IPaymentProcessor Create(string provider)
{
    var version = _flags.GetInt($"{provider}_api_version", defaultValue: 1);
    var key = $"{provider}_v{version}"; // e.g., "stripe_v2"
    return _sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(key);
}

// Both registered; flag controls which is active
services.AddKeyedTransient&lt;IPaymentProcessor, StripeProcessorV1&gt;("stripe_v1");
services.AddKeyedTransient&lt;IPaymentProcessor, StripeProcessorV2&gt;("stripe_v2");
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The Adapter pattern angle is underappreciated in interviews. When <code>StripeProcessorV2</code> has a completely different method signature that doesn't match <code>IPaymentProcessor</code>, you create a <code>StripeV2Adapter</code> class that implements <code>IPaymentProcessor</code> but internally uses the new <code>StripeProcessorV2</code>. The adapter is a translator â€” it speaks "old interface" on the outside and "new API" on the inside. The factory returns the adapter; every caller continues working unchanged. This is actually the <strong>Strangler Fig pattern</strong> (named after a vine that grows around a tree and gradually replaces it) applied at the class level. Great candidates also emphasize that the interface is the most important thing to protect â€” it's the contract that ALL parties (all callers, all providers) must honour, and changing it later becomes exponentially harder as more code builds against it.</div>
    </div></div>
  </div>

  <!-- Q15 -->
  <div class="qa-item" id="qa15">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q15. Design a factory that supports A/B testing between providers. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-yellow" style="font-size:0.7rem;">Design Challenge</span> &nbsp; Follow-up: How do you ensure a user always gets the same provider for consistency?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <strong>A/B testing</strong> in a factory is a routing problem with one critical requirement: the same user must always go to the same provider. If you randomly pick a provider on every request, the same user might pay with Stripe for their first purchase and PayPal for their second â€” different UX, different receipts, potentially breaking refunds (you'd need to refund on the right provider). Consistency is everything.<br><br>
        The solution: <strong>deterministic hashing</strong>. Take the user's ID (a stable, permanent identifier â€” NOT a session ID, those expire), put it through a hash function, and take it modulo 100. The result is a bucket number from 0-99. Users in buckets 0-49 always get Provider A. Users in buckets 50-99 always get Provider B. Same user ID always produces the same bucket number, so the same user always gets the same provider.
      </div>
      <p class="body-text">The factory needs the current user's stable identifier (user ID or account ID â€” NOT session ID, because sessions expire and create a different ID each time). Use a deterministic hash: <code>Math.Abs(userId.GetHashCode()) % 100</code> gives a stable number from 0-99. Map that number to a provider based on your A/B split configuration (first 50 buckets â†’ Stripe, last 50 â†’ PayPal). This guarantees every request from the same user hits the same provider â€” enabling meaningful A/B analysis AND preventing confusing situations like charging on Stripe but then trying to refund on PayPal (which would fail since the original charge isn't there).</p>
      <p class="body-text">Save the user's assigned bucket to the database on their first request. Why? Because if you later change the hash function or adjust the bucket boundaries (e.g., shifting from 50/50 to 70/30), users who were already in the experiment would suddenly switch groups â€” contaminating your data and making the results meaningless. By persisting the assignment, users already enrolled stay in their original group no matter what changes you make to the algorithm. Also emit telemetry (structured log or metric event) with the bucket number and provider name on every transaction so your data team can analyze the A/B results.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ABTestingFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public IPaymentProcessor Create(Guid userId)
{
    var bucket = Math.Abs(userId.GetHashCode()) % 100;
    var provider = bucket &lt; 50 ? "stripe" : "paypal"; // 50/50 split
    _telemetry.TrackEvent("ProviderSelected",
        new { userId, bucket, provider });
    return _sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(provider);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The persistent assignment detail is critical for valid A/B test results. If a user can switch groups mid-experiment, the groups are contaminated â€” you can't tell if your results are real or just noise from users switching. Storing the assignment in the database makes the experiment results trustworthy. Also mention the <strong>holdout group</strong>: set aside 5% of users who receive NEITHER variant â€” they just get the old existing behaviour. This holdout group lets you measure the baseline over time and control for seasonal effects (e.g., people naturally spend more in December â€” without a holdout, you might incorrectly attribute that to your new provider being better).</div>
    </div></div>
  </div>

  <!-- Q16 -->
  <div class="qa-item" id="qa16">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q16. How do you handle cross-cutting concerns (logging, metrics) in factories? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Architecture</span> &nbsp; Follow-up: Should the factory or the product handle observability?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <strong>Cross-cutting concerns</strong> are things like logging, metrics, and error tracking that need to happen everywhere but don't belong to any single feature. The key insight is that factory-level concerns and product-level concerns are different in scope:<br><br>
        Factory-level: "which provider was picked, how long did selection take." Only the factory knows the routing decision â€” so this belongs in the factory. Product-level: "how long did the actual payment take, did it succeed or fail." This belongs outside the concrete processors â€” you don't want to duplicate logging code in every processor class. The solution: wrap the processor in a <strong>Decorator</strong> (a wrapper class that adds behaviour before/after delegating to the real class) right before returning it from the factory.
      </div>
      <p class="body-text">Factory-level observability: when the factory picks a provider, log which one was selected, record how long the selection took as a metric, and emit a trace span (a timing record used by distributed tracing tools). Only the factory knows the routing decision, so this logging belongs here. Product-level observability: when the processor actually runs, measure latency, count errors, record success/failure. This belongs in a Decorator â€” an <code>InstrumentedPaymentProcessor</code> wrapper that calls the real processor but records metrics around every call.</p>
      <p class="body-text">The Decorator approach keeps your factory and your concrete processor classes completely clean â€” no telemetry code anywhere except the one decorator. The factory wraps the processor right before returning it: <code>return new InstrumentedPaymentProcessor(realProcessor, _metrics, _logger)</code>. This is the <strong>Open/Closed Principle</strong> (adding new behaviour without modifying existing code) in practice. Best part: every new processor you add in the future automatically gets full instrumentation for free, because the factory always wraps before returning.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">InstrumentedFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public IPaymentProcessor Create(string key)
{
    using var activity = _tracer.StartActivity("Factory.Create");
    activity?.SetTag("provider", key);

    var processor = _sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(key);

    // Wrap in decorator â€” all processors get instrumentation automatically
    return new InstrumentedPaymentProcessor(processor, _metrics, _logger);
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The Decorator-at-the-factory-boundary idea is the key insight. Think about the alternative: if you put telemetry code inside each concrete processor, you're copying the same logging/metrics code into every single class. When you want to change how metrics are recorded, you edit every processor. By putting the Decorator in the factory's <code>Create()</code> method, you write the instrumentation code exactly once â€” and it automatically applies to every processor, past and future. This is exactly how ASP.NET Core's middleware pipeline works (every request passes through the same logging middleware) and how Polly wraps your code in retry/circuit-breaker policies without you adding retry logic to every method.</div>
    </div></div>
  </div>

  <!-- Q17 -->
  <div class="qa-item" id="qa17">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q17. Your factory needs to create objects from plugins loaded at runtime. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Architecture</span> &nbsp; Follow-up: How do you handle isolation between plugins?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> A <strong>plugin system</strong> means the factory must find and load implementations that didn't exist when the code was compiled â€” they come from external DLL files added later. Instead of hardcoding which processors exist, the factory discovers them at runtime. This uses <strong>reflection</strong> (a way to inspect and load code at runtime, after the program has started) and assembly scanning (searching for DLL files that match a pattern).<br><br>
        Think through four problems to solve: (1) <strong>discovery</strong> â€” how does the factory find plugin files? (scan a folder for DLLs), (2) <strong>loading</strong> â€” how do you load them safely? (use <code>AssemblyLoadContext</code> for isolation), (3) <strong>registration</strong> â€” how does each plugin tell the factory what it provides? (each plugin implements a standard interface with a <code>Register()</code> method), (4) <strong>creation</strong> â€” how does the factory create them? (exactly the same as always â€” by key).
      </div>
      <p class="body-text">A plugin-aware factory builds its registry at startup by scanning a plugins folder. Each plugin DLL exports a class implementing <code>IPaymentProcessorPlugin</code> with a <code>Register(IServiceCollection services)</code> method. A discovery service finds these DLLs, loads them using reflection, finds the plugin class, calls its <code>Register()</code> method to add processors to the DI container, and that's it. The factory then resolves by provider key exactly as normal â€” it doesn't know or care whether a processor came from the core app or was loaded from a plugin.</p>
      <p class="body-text">Isolation between plugins is critical: if one plugin has a buggy dependency (say it uses an old version of a library that conflicts with another plugin), it should not crash the other plugins or the main app. Use <strong><code>AssemblyLoadContext</code></strong> (a .NET feature that loads each assembly into its own isolated memory context) for each plugin. One critical detail: the shared contract interface (<code>IPaymentProcessor</code>) must be loaded from the HOST app's assembly, not copied into each plugin. If every plugin has its own copy, the type identities don't match â€” the factory tries to cast the plugin's processor to the host's <code>IPaymentProcessor</code> and gets an error even though they look identical.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PluginLoader.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public void LoadPlugins(IServiceCollection services, string pluginDir)
{
    foreach (var dll in Directory.GetFiles(pluginDir, "*.Plugin.dll"))
    {
        var ctx = new PluginLoadContext(dll); // isolated AssemblyLoadContext
        var asm = ctx.LoadFromAssemblyPath(dll);
        var pluginType = asm.GetTypes()
            .FirstOrDefault(t =&gt; typeof(IPaymentPlugin).IsAssignableFrom(t));
        if (pluginType is null) continue;
        var plugin = (IPaymentPlugin)Activator.CreateInstance(pluginType)!;
        plugin.Register(services); // plugin registers its own processors
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The shared-contract assembly rule is the production detail that trips up developers who haven't done plugin systems before. Even if the host's <code>IPaymentProcessor</code> and the plugin's <code>IPaymentProcessor</code> have identical code, the <strong>CLR</strong> (Common Language Runtime â€” the engine that runs .NET code) treats them as different types if they were loaded from different DLLs. The cast fails with a confusing error. The fix: configure the <code>AssemblyLoadContext</code> resolver to always resolve the contracts assembly from the host, never from the plugin's own copy. Great candidates also think ahead to versioning: if you ever change the <code>IPaymentProcessor</code> interface, ALL old plugins break immediately. Solution: use versioned interface names (<code>IPaymentProcessorV2</code>) or adapter wrappers to maintain backwards compatibility â€” give plugin authors a clear deprecation window.</div>
    </div></div>
  </div>

  <!-- Q18 -->
  <div class="qa-item" id="qa18">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q18. Factory Method vs Func delegate factories â€” when do you use which? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Comparison</span> &nbsp; Follow-up: What does a Func delegate factory lose compared to a class-based factory?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> A <code>Func&lt;IPaymentProcessor&gt;</code> IS a factory method â€” it's just an anonymous function with no class wrapping it. The real question is whether you need the extra structure a class gives you: a named type, an interface contract, multiple methods, and easy substitution in tests.<br><br>
        Simple rule of thumb: use <code>Func</code> for simple, local, one-off factory needs. Use a class-based factory when the factory is shared across multiple services, has complex routing logic, has multiple creation methods, or needs to be replaced with a test double (a fake object used in tests).
      </div>
      <p class="body-text">A <code>Func&lt;IPaymentProcessor&gt;</code> <strong>delegate</strong> (a stored function â€” think of it as a variable holding a method) is appropriate for short-lived, local, simple scenarios â€” test setup, creating a processor for one method, or a simple lambda registered in the DI container. A class-based <code>IPaymentProcessorFactory</code> is better when: the factory is injected into multiple services across the codebase, it has complex routing logic (read feature flags, check health, select from registry), needs multiple creation methods (like <code>Create(string key)</code> and <code>CreateWithFallback(string primary, string fallback)</code>), or needs to be replaced with a fake in tests.</p>
      <p class="body-text">What <code>Func</code> loses compared to a class: (1) <strong>discoverability</strong> â€” a method parameter like <code>Func&lt;string, IPaymentProcessor&gt;</code> tells you nothing useful; you have to read documentation. <code>IPaymentProcessorFactory</code> is completely self-documenting, (2) <strong>testability</strong> â€” to "mock" a <code>Func</code> you just pass a lambda, which is easy, but you can't verify HOW it was called as easily as with a mock object, (3) <strong>extensibility</strong> â€” if you need to add a second factory method later, every injection site that currently takes a <code>Func</code> needs to change. Adding a method to an interface is non-breaking.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FuncVsClass.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Func â€” fine for simple, local, single-use
services.AddTransient&lt;Func&lt;IPaymentProcessor&gt;&gt;(sp =&gt;
    () =&gt; sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;("stripe"));

// Class â€” better when shared, complex, or testable
public interface IPaymentProcessorFactory
{
    IPaymentProcessor Create(string provider);
    IPaymentProcessor CreateWithFallback(string primary, string fallback);
    // Can be mocked, substituted, recorded in tests
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Mention the middle-ground option that most developers overlook: a <strong>named delegate type</strong>. In C#, you can declare <code>delegate IPaymentProcessor PaymentProcessorFactory(string provider)</code>. This is one line of code that creates a named type â€” now your method parameters say <code>PaymentProcessorFactory factory</code> instead of <code>Func&lt;string, IPaymentProcessor&gt; factory</code>. It's self-documenting (what does that string represent? "provider" tells you), it's still as easy to create as a lambda, but it carries semantic meaning. It's the best of both worlds: the lightness of a delegate with the readability of a named type, without the full overhead of a class and interface.</div>
    </div></div>
  </div>

  <!-- Q19 -->
  <div class="qa-item" id="qa19">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q19. How would you implement a factory that pools expensive processor instances? <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Performance</span> &nbsp; Follow-up: How do you handle a processor that becomes invalid while in the pool?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <strong>Object pooling</strong> is like a library of laptops for employees: instead of buying a new laptop for each new employee, you have a shared pool. When someone needs one, they check one out. When they're done, they return it for the next person. It's expensive to create a new laptop (processor) from scratch every time â€” so you reuse them.<br><br>
        Object pooling changes the factory's contract: <code>Create()</code> becomes <code>Rent()</code> (borrow one), and you need a matching <code>Return()</code> (give it back). The .NET framework has built-in support for this: <code>Microsoft.Extensions.ObjectPool</code>. Think about what "expensive" means here: the processor has a slow initialization, an authenticated session that took seconds to establish, or a warm connection state that's costly to rebuild.
      </div>
      <p class="body-text">Use .NET's <code>Microsoft.Extensions.ObjectPool</code> library. Create a pooling factory that maintains one <code>ObjectPool&lt;IPaymentProcessor&gt;</code> per provider key. You define a "pool policy" that has two methods: <code>Create()</code> (what to do when the pool is empty and needs a new processor), and <code>Return(processor)</code> (what to do when a processor comes back â€” validate it's still usable and reset any state). For processors with authenticated sessions, the <code>Return</code> method checks if the session is still valid â€” if it expired while sitting idle in the pool, dispose it and the pool will create a fresh one on the next rent.</p>
      <p class="body-text">The caller pattern uses a <strong><code>ProcessorLease</code></strong> object â€” a wrapper that borrows the processor from the pool and automatically returns it when you're done, using C#'s <code>await using</code> syntax (<code>IAsyncDisposable</code> â€” an interface for async cleanup). This is like borrowing a library book with an automatic return slot: you never forget to return it because the slot activates automatically when you're done. This prevents "pool exhaustion" (all processors are borrowed and nobody is returning them) even when exceptions occur.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PoolingFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public class PoolingPaymentFactory : IPaymentProcessorFactory
{
    private readonly ConcurrentDictionary&lt;string, ObjectPool&lt;IPaymentProcessor&gt;&gt; _pools = new();

    public ProcessorLease Rent(string provider)
    {
        var pool = _pools.GetOrAdd(provider, key =&gt; CreatePool(key));
        var processor = pool.Get();
        return new ProcessorLease(processor, () =&gt; pool.Return(processor));
    }
}

public sealed class ProcessorLease(IPaymentProcessor p, Action returnFn) : IAsyncDisposable
{
    public IPaymentProcessor Processor =&gt; p;
    public ValueTask DisposeAsync() { returnFn(); return ValueTask.CompletedTask; }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The "processor goes stale in the pool" scenario is a real production gotcha. A processor with an authenticated session sits unused in the pool for 30 minutes. The session token expires. The next caller rents it, tries to process a payment, and immediately gets an "unauthorized" error â€” even though the processor looks healthy from the outside. The fix: in the pool policy's <code>Return()</code> method, call a lightweight <code>IsHealthy()</code> check on the processor before accepting it back into the pool. If it's unhealthy, dispose it right there. The pool will automatically create a fresh, re-authenticated processor on the next rent. Also mention pool sizing: a pool that's too small causes callers to wait/block under heavy load; a pool that's too large wastes memory and keeps many idle sessions open, which can hit provider <strong>rate limits</strong> (a cap on how many connections or requests a service allows).</div>
    </div></div>
  </div>

  <!-- Q20 -->
  <div class="qa-item" id="qa20">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q20. Design a multi-tenant factory where each tenant has different providers. <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">System Design</span> &nbsp; Follow-up: How do you manage tenant configuration changes without restart?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> <strong>Multi-tenant</strong> means the same app serves many different companies (tenants) at once â€” think Slack, where your company and 10,000 other companies all use the same software but with different data and settings. In this context, different tenants use different payment providers. The factory can't use a single global config value â€” it needs to figure out which tenant is making the current request, then look up that tenant's preferred provider.<br><br>
        Think about where tenant config lives: NOT in the app's config files (those are the same for all tenants and change only when you redeploy). Instead: in a database (per-tenant settings), cached in memory with a time limit so the app doesn't hit the database on every single request. The factory reads the cache on each request.
      </div>
      <p class="body-text">The multi-tenant factory injects <code>ITenantContext</code> (a service that reads the current tenant ID from the HTTP request â€” from the subdomain, a JWT token claim, or a request header) and a tenant configuration cache (backed by a database, refreshed every 5 minutes or when a change event comes in). On each call, the factory reads the current tenant ID, looks up that tenant's preferred payment provider, and resolves the right processor from the DI container. Important: the factory itself is a Singleton (created once), but the tenant lookup happens fresh on every request â€” the factory must NEVER cache the resolved processor and reuse it across requests. Why? Because each request may come from a different tenant â€” reusing a processor resolved for Tenant A would mean Tenant B accidentally uses Tenant A's payment provider and credentials.</p>
      <p class="body-text">For zero-downtime tenant configuration changes: store tenant configs in <strong>Redis</strong> (a fast in-memory data store often used for caching and pub/sub messaging). Subscribe the app's in-process cache to Redis <strong>pub/sub</strong> (a messaging system where you publish a message and all subscribers receive it instantly). When an admin changes a tenant's provider in the dashboard, publish an invalidation message to Redis. All running app servers receive it within milliseconds and clear that tenant's cached config. The next request for that tenant gets the new provider â€” no deployment, no downtime.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MultiTenantFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public class MultiTenantPaymentFactory(
    ITenantContext tenant,
    ITenantConfigCache configs,
    IServiceProvider sp) : IPaymentProcessorFactory
{
    public IPaymentProcessor Create()
    {
        var tenantId = tenant.CurrentTenantId;
        var config   = configs.Get(tenantId);         // cached, backed by DB
        var provider = config.PaymentProvider;         // "stripe" or "paypal"
        return sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(provider);
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> Cache invalidation strategy separates junior from senior thinking. A junior developer caches configs with a 5-minute <strong>TTL</strong> (Time To Live â€” how long the cached data is considered fresh before re-fetching) â€” it's "eventually consistent" (gets correct within 5 minutes), good enough for most changes. A senior developer adds event-driven invalidation on top: when an admin changes a tenant's provider, immediately publish an event to a message bus, and all running server instances clear that one tenant's cache entry right away. The config change takes effect in seconds, not minutes. Also mention the <strong>blast radius</strong> (how much damage a single failure can cause â€” the bigger the blast radius, the more users are hurt by one bug) concern: if there's a bug in the factory's routing logic, it could accidentally route ALL tenants to the wrong provider simultaneously. Use tenant-specific integration tests and canary-deploy config changes to one tenant first before rolling out broadly â€” limit how bad a mistake can get.</div>
    </div></div>
  </div>

  <!-- Q21 -->
  <div class="qa-item" id="qa21">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q21. How does Factory Method support the Strangler Fig migration pattern? <span class="badge badge-purple">Advanced</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Architecture</span> &nbsp; Follow-up: What is the rollback strategy if the new implementation has bugs?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> The <strong>Strangler Fig pattern</strong> is named after a type of vine that grows around a tree, slowly replacing it while the tree continues to stand until eventually the vine completely takes over. In software, it means: instead of doing a big-bang replacement of a legacy system (risky and scary), you build the new system alongside the old one and gradually shift traffic from old to new, a little bit at a time.<br><br>
        Factory Method is the routing mechanism that makes this possible. The factory decides what percentage of requests go to the old system vs the new system. It's like a traffic cop gradually waving more and more cars to the new road while keeping the old road open until you're confident the new road works perfectly.
      </div>
      <p class="body-text">The migration sequence: (1) Define <code>IPaymentProcessor</code> as an abstraction â€” if the legacy system doesn't implement it already, wrap it in a <code>LegacyPaymentProcessorAdapter</code>. (2) Build the new processor implementing the same interface. (3) Register both in DI â€” they can both live side by side. (4) The factory uses a feature flag percentage: start at 0% new (all legacy), gradually increase to 5%, 25%, 50%, 100% over days or weeks (this gradual rollout process, described in detail in Q14, applies here too). (5) Once at 100%, remove the legacy adapter. The callers never change a single line throughout this entire migration â€” they just call the factory and get whatever processor the factory decides to give them.</p>
      <p class="body-text">Rollback: the feature flag percentage IS the rollback mechanism. If the new implementation has bugs, set the flag to 0% â€” all traffic immediately returns to the legacy processor. No code deployment needed, no waiting for a build pipeline. This is much faster and safer than a traditional code rollback. The factory acts as the control switch: flip it to 0% and you're fully back to legacy within seconds. This ability to rollback instantly is why the Strangler Fig pattern with Factory Method routing is considered a gold standard for safe migrations.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">StranglerFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public IPaymentProcessor Create()
{
    // Feature flag controls migration progress: 0 to 100 over weeks
    var newPct  = _flags.GetInt("new_processor_traffic_pct", defaultValue: 0);
    var bucket  = Math.Abs(Guid.NewGuid().GetHashCode()) % 100;
    var useNew  = bucket &lt; newPct;
    return _sp.GetRequiredKeyedService&lt;IPaymentProcessor&gt;(useNew ? "new" : "legacy");
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The <strong>dual-write / shadow mode</strong> enhancement is the senior-level insight. During migration, route every request to BOTH the old and new processor simultaneously. But only return the legacy result to the customer â€” the new processor's result is compared in the background and any differences are logged. You discover bugs in the new implementation before any real customer sees them. Only start increasing the traffic percentage after the discrepancy rate (how often new and old give different results) has been at zero for long enough to be confident. This technique â€” running the new system in shadow alongside the old â€” is exactly how Google and Netflix perform large backend migrations. Zero user impact, complete confidence before switching.</div>
    </div></div>
  </div>

  <!-- Q22 -->
  <div class="qa-item" id="qa22">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q22. What happens when a factory method throws? How should errors propagate? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">Error Handling</span> &nbsp; Follow-up: Should the factory swallow exceptions or let them propagate?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> When the factory fails, it should tell the caller exactly what went wrong and what they can do about it. Throwing a generic <code>Exception</code> with "something went wrong" is useless â€” it doesn't tell the caller whether to retry, give up, or alert the ops team. Use specific exception types for specific problems.<br><br>
        Sort factory errors into categories: (1) <strong>configuration errors</strong> (someone asked for an unknown provider key "bitcoin" that was never registered) â€” throw a specific exception immediately, or better, fail at startup, (2) <strong>resource errors</strong> (the pool is exhausted, the circuit breaker is open) â€” throw with information about when to retry, (3) <strong>validation errors</strong> (the key format is wrong, null was passed) â€” throw <code>ArgumentException</code>.
      </div>
      <p class="body-text">The factory should NEVER swallow exceptions (catch them silently without doing anything) or return <code>null</code>. If a factory silently returns <code>null</code> when it can't create a processor, the caller thinks it has a working processor and happily calls <code>processor.Process(paymentRequest)</code> â€” which throws a <code>NullReferenceException</code> that has nothing to do with the real problem. Fail loudly and specifically: throw an exception that names exactly which provider key was requested and why it failed. This makes the error immediately actionable in logs â€” you see "Provider 'bitcoin' not registered" and know exactly what to fix.</p>
      <p class="body-text">Create a small <strong>exception hierarchy</strong> (a family of related exception types): <code>PaymentProviderNotFoundException</code> (provider key doesn't exist in the registry) and <code>PaymentProviderUnavailableException</code> (circuit breaker is open â€” provider is down) both extend a shared <code>PaymentFactoryException</code> base. This lets callers catch at the right level: your payment controller catches <code>PaymentFactoryException</code> and returns an HTTP 503 "Service Unavailable" response, while generic error-handling middleware catches any other <code>Exception</code> and returns HTTP 500 for unexpected errors.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FactoryExceptions.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public IPaymentProcessor Create(string key)
{
    if (!_registry.ContainsKey(key))
        throw new PaymentProviderNotFoundException(
            $"Provider '{key}' not registered. Known: {string.Join(", ", _registry.Keys)}");

    if (_circuitBreakers[key].State == CircuitState.Open)
        throw new PaymentProviderUnavailableException(key)
            { RetryAfter = _circuitBreakers[key].NextAttemptTime };

    return _registry[key]();
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The <code>RetryAfter</code> property in the exception is the senior-level detail. <code>PaymentProviderUnavailableException</code> should include the timestamp of when the circuit breaker will attempt to recover (the "half-open" state probe). The calling middleware reads this property and sets a <code>Retry-After</code> HTTP response header in the HTTP 503 response â€” giving clients a concrete time when they should try again. Without this, clients immediately retry on every 503, hammering the already-struggling server and making recovery slower. With this, clients wait the right amount of time. This follows <strong>RFC 7231</strong> (the standard that defines how HTTP status codes should work) and shows that you think about the full picture â€” from how exceptions are designed, all the way to what the client receives over the network.</div>
    </div></div>
  </div>

  <!-- Q23 -->
  <div class="qa-item" id="qa23">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q23. How do you ensure all factory subclasses are registered in DI? <span class="badge badge-blue">Intermediate</span></div>
        <div class="qa-meta"><span class="badge badge-blue" style="font-size:0.7rem;">Testing</span> &nbsp; Follow-up: What happens when a new developer adds a factory subclass but forgets to register it?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> "Ensuring registration" is a <strong>CI problem</strong> (CI = Continuous Integration â€” the automated system that runs tests every time someone pushes code), NOT a runtime problem. You want to catch "forgot to register the new provider" in the automated test pipeline, not when a real customer's payment fails at 2am on a Friday night.<br><br>
        Three layers of defence, each catching different failure modes: (1) <strong>auto-registration</strong> â€” scan the codebase at startup and register everything automatically, so there's nothing to forget, (2) <strong>startup validation</strong> â€” at app startup, try to resolve every expected provider and fail immediately if anything is missing, (3) <strong>integration tests</strong> â€” an automated test that boots the real DI container and checks every provider can be resolved, run on every pull request.
      </div>
      <p class="body-text">The most reliable approach is <strong>assembly scanning</strong> â€” a technique where the app scans its own code at startup to find all classes implementing <code>IPaymentProcessor</code> and registers them automatically. Use the Scrutor library or write a custom scanner. The key ingredient: some way for each class to advertise its own key. Use either a naming convention (the class name contains the key, like "StripeProcessor" â†’ key "stripe") or an attribute like <code>[PaymentProvider("stripe")]</code> on the class. Now a new developer just creates the class with the attribute â€” it's automatically discovered. There's no separate registration step to forget.</p>
      <p class="body-text">As a safety net on top of auto-registration, write an <strong>integration test</strong> (a test that starts the real app, not fakes) that: (1) boots the real <code>WebApplication</code>, (2) reads the list of expected provider keys from configuration, and (3) tries to resolve each one from the DI container. If any key is missing, the test fails with a clear message like "Provider 'square' not registered." This test runs on every pull request in your CI pipeline, meaning a developer cannot merge a PR that would cause a missing registration in production.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RegistrationTest.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">[Fact]
public void AllConfiguredProviders_AreRegisteredInDI()
{
    var app = WebApplication.CreateBuilder().Build();
    var expectedKeys = app.Configuration
        .GetSection("SupportedPaymentProviders")
        .Get&lt;string[]&gt;() ?? [];

    foreach (var key in expectedKeys)
    {
        var processor = app.Services.GetKeyedService&lt;IPaymentProcessor&gt;(key);
        Assert.NotNull(processor); // fails loudly with the missing key name
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The attribute-based discovery approach is the elegant solution that makes the problem disappear. You put <code>[PaymentProvider("stripe")]</code> on the <code>StripeProcessor</code> class. The startup scanner finds all classes with this attribute and registers them automatically under their specified key. A developer literally cannot forget to register â€” because there's nothing to register separately. The class itself carries all the information needed for registration. This is exactly how ASP.NET Core discovers controllers (via <code>[ApiController]</code>) and how MediatR finds your request handlers automatically. Bonus: because the attribute stores the valid keys, the factory can discover all supported provider keys at startup and use them to generate a complete health check list â€” the factory can self-document what providers it supports.</div>
    </div></div>
  </div>

  <!-- Q24 -->
  <div class="qa-item" id="qa24">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q24. Design a factory system for 25+ teams each owning their own provider. <span class="badge badge-red">Principal</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">System Design</span> &nbsp; Follow-up: How do you prevent one team's broken provider from affecting other teams?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> At 25+ teams, this has grown beyond a design pattern question â€” it's a <strong>platform engineering problem</strong>. Platform engineering is about building the tools and infrastructure that other development teams use to do their work. The factory itself becomes a shared platform that 25 teams plug into. Each team must be able to: build their own provider independently, deploy it without asking the platform team, and know immediately when their provider breaks â€” without breaking anyone else's.<br><br>
        Four problems to solve: (1) the shared contract everyone must implement, (2) a self-service registration mechanism (no central gatekeeper), (3) isolation so one team's bug can't take down everyone, (4) observability so both platform team and owning team can see what's happening with each provider.
      </div>
      <p class="body-text">The architecture: publish a shared <strong>NuGet package</strong> (a package manager package, like npm for .NET) containing the <code>IPaymentProcessor</code> interface, the <code>[PaymentProvider]</code> attribute, and the base test suite. Each of the 25 teams owns a separate code repository and assembly for their processor. They deploy their DLL to a shared plugins directory independently. The host app uses assembly scanning to discover all providers automatically at startup â€” onboarding a new team is just "drop your DLL in the folder." The core factory code never changes when a new team onboards. A central platform team owns the factory infrastructure; each product team owns their processor implementation.</p>
      <p class="body-text"><strong>Blast radius containment</strong> (blast radius = how much damage a failure can cause) is critical: wrap each provider's registration in a try/catch. If Team A's processor throws an exception during startup, that provider gets marked as unhealthy and excluded from the registry. All other 24 providers continue working normally. Fire a structured alert immediately so Team A gets paged. No single team's bad code can take down all 25 providers.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PlatformFactory.cs â€” isolation envelope</span></div>
        <div class="macos-body"><pre><code class="language-csharp">public PlatformPaymentFactory(IEnumerable&lt;IPaymentProcessorPlugin&gt; plugins)
{
    foreach (var plugin in plugins)
    {
        try { _healthy[plugin.Key] = plugin.CreateFactory(); }
        catch (Exception ex)
        {
            _degraded[plugin.Key] = ex;
            _alerts.Send($"Provider '{plugin.Key}' failed to initialise: {ex.Message}");
        }
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The <strong>governance model</strong> is the principal-level insight â€” this is what separates someone who can implement a factory from someone who can build a platform that 25 teams can build on safely. With 25 teams you need: (1) a <strong>contract versioning policy</strong> â€” when does <code>IPaymentProcessor</code> get a new version, how long do teams get to migrate before the old version is removed, (2) a <strong>provider certification pipeline</strong> â€” new providers must pass a standard automated test suite before they're allowed into production (like an app store review process), (3) a <strong>SLA dashboard</strong> (<strong>SLA</strong> = Service Level Agreement â€” a commitment about uptime and performance) showing per-provider latency, error rate, and circuit-breaker state, visible to both the platform team and each owning team. This transforms a design pattern into a self-service engineering platform. Great principal-level candidates think in terms of developer experience, governance, and team autonomy â€” not just code.</div>
    </div></div>
  </div>

  <!-- Q25 -->
  <div class="qa-item" id="qa25">
    <div class="qa-header" onclick="toggleQA(this)">
      <div>
        <div class="qa-question">Q25. Migrating from monolithic factory to microservices â€” how does Factory Method change? <span class="badge badge-red">Principal</span></div>
        <div class="qa-meta"><span class="badge badge-red" style="font-size:0.7rem;">System Design</span> &nbsp; Follow-up: What replaces the in-process factory in a distributed system?</div>
      </div>
      <i class="fa-solid fa-chevron-down qa-chevron"></i>
    </div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think">
        <strong>How to think about it:</strong> In a monolith (a single large app where everything runs in the same process), Factory Method creates an object in the same computer memory. In a <strong>microservices</strong> architecture (where each service runs as a separate app, often on different servers), "creating" a payment processor means finding the right microservice and sending an HTTP request to it. The concept of Factory Method survives the change â€” but the mechanism shifts completely.<br><br>
        What stays the same: the caller has no idea which concrete provider handles the request. What changes: the factory doesn't instantiate an in-memory object â€” it configures and returns an HTTP client (a helper object for making HTTP calls) pointed at the right server. The "product" (what the factory creates) goes from a C# class instance to an HTTP client configured for a specific endpoint.
      </div>
      <p class="body-text">In a microservices architecture, the Factory Method becomes a routing layer. Instead of <code>CreateProcessor()</code> returning an in-memory C# object, it returns a pre-configured HTTP client pointed at the correct payment microservice's URL. The factory consults a <strong>service registry</strong> (like Consul or Kubernetes service discovery â€” a live database of "which service is running at which address") to find the current endpoint for the requested provider. The caller code looks identical to before â€” it calls <code>factory.Create(provider)</code> and calls <code>.Process(request)</code>. The fact that it's now making an HTTP call to another server is completely hidden inside the client object.</p>
      <p class="body-text">In a more distributed design, the factory itself becomes a separate service â€” an <strong>API gateway</strong> (a service that acts as the front door for multiple backend services, routing requests to the right one) or a payments orchestration service. Clients call this gateway service with a provider name, and the gateway routes to the correct downstream payment microservice. The local "factory" in the client app becomes a thin wrapper that calls the gateway. The advantage: routing logic and the provider registry now live in one centralised place across ALL client apps â€” if you add a new provider, you update the gateway, and every client (regardless of what programming language they use) automatically gets it.</p>
      <div class="macos-window">
        <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DistributedFactory.cs</span></div>
        <div class="macos-body"><pre><code class="language-csharp">// Factory returns an HTTP client wrapping the correct microservice
public class DistributedPaymentFactory(IServiceRegistry registry, IHttpClientFactory http)
    : IPaymentProcessorFactory
{
    public IPaymentProcessor Create(string provider)
    {
        var endpoint = registry.Resolve($"payment-{provider}"); // service discovery
        var client   = http.CreateClient(provider);              // named client: retry + timeout
        client.BaseAddress = endpoint;
        return new HttpPaymentProcessorAdapter(client);          // same IPaymentProcessor interface
    }
}
</code></pre></div>
      </div>
      <div class="qa-great"><strong>What separates good from great:</strong> The key insight is that the <code>IPaymentProcessor</code> interface is the <strong>durable abstraction</strong> â€” the one thing that doesn't change during the entire migration from monolith to microservices. The interface you defined in the monolith becomes the contract for the distributed system too. The caller code doesn't change a single line â€” it still calls <code>processor.Process(request)</code>. Only the implementation behind the interface changes from "in-memory C# object" to "HTTP call to a remote server." This is Factory Method at its most powerful: it insulates callers from the implementation mechanism (how the work is done), not just the implementation type (which class does the work). Great principal-level candidates frame this as: "We're migrating the transport layer, not the application model." That one sentence â€” migrating the transport, not the model â€” demonstrates architectural thinking that goes far beyond just knowing design patterns. It shows you understand that abstractions protect you from exactly this kind of change.</div>
    </div></div>
  </div>

</section>

<!-- ============================================================ SECTION 15 -->
<section id="s15" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-compass-drafting"></i></div>
    <div><div class="section-num">Section 15</div><h2 class="section-title">When to Use / Anti-Patterns</h2></div>
  </div>

  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-circle-check" style="color:var(--accent-green)"></i> When to Use Factory Method</div>
    <div class="card-body">
      <p class="body-text">Factory Method is the right tool when you have a genuine variation axis in object creation that needs to be open for extension without modification. The eight scenarios below are the canonical use cases where Factory Method pays for its complexity cost.</p>
      <div class="grid-2">
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-circle-plus"></i> Multiple providers growing over time</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">You start with Stripe and know PayPal, Square, and Apple Pay are on the roadmap. The variation axis is clear and will grow. Factory Method ensures each new provider is a new class, not a new branch in existing code. Adding provider #5 is the same effort as adding provider #2.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-plug"></i> Plugin / extension systems</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Third-party developers need to add implementations you have not seen yet. The factory interface is the extension point. Plugins implement the product interface and register with the factory. The core system never changes to accommodate new plugins â€” this is the definition of OCP at the architectural level.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-building"></i> Multi-tenant SaaS</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Each tenant has a different configured provider. The factory reads the current tenant's config and routes to the correct implementation. Adding a new tenant that uses a new provider requires zero changes to application code â€” only configuration and DI registration.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-flask"></i> Testing / environment-specific behaviour</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Production uses the real Stripe processor; tests use an in-memory stub. The factory selects based on environment or DI registration. Tests never hit real payment APIs and never need credit card numbers. The same test code runs against any implementation without modification.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-layer-group"></i> Framework / library design</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">You are building a framework that others will extend. Factory Method defines the extension point â€” your framework calls the factory method; users implement the concrete creator. ILoggerFactory, IHttpClientFactory, and IHostedServiceFactory are all examples of this in the BCL.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-gears"></i> Complex construction with cross-cutting</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Each provider needs different resilience policies, retry configurations, circuit breakers, and observability decorators. The factory encapsulates all this construction complexity in one place. Callers receive a fully-configured, production-ready processor without knowing about the resilience infrastructure behind it.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-rotate"></i> Runtime provider switching</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Feature flags, A/B tests, or operator commands need to change the active provider without a deployment. The factory reads the current configuration on each invocation. Switching providers is a configuration change, not a code change. Rollback is immediate â€” change the flag, not the code.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(16,185,129,0.25);border-radius:0.75rem;background:rgba(16,185,129,0.04);">
          <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-shield-halved"></i> Compliance / audit requirements</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">PCI-DSS, GDPR, or SOC 2 require that the payment processor used for each transaction is logged and auditable. The factory is the single choke point where every processor creation is recorded. All audit events flow through one place â€” the factory's Create() call â€” making compliance reporting straightforward.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-circle-xmark" style="color:var(--accent-red)"></i> When NOT to Use Factory Method</div>
    <div class="card-body">
      <p class="body-text">Factory Method is a cost â€” extra classes, extra indirection, extra abstraction to understand. These eight scenarios are where the pattern's costs exceed its benefits and simpler alternatives are preferable.</p>
      <div class="grid-2">
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Only one implementation</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">If there is exactly one concrete type and no credible roadmap for a second, the factory adds four classes (interface, abstract creator, concrete creator, product) to model a variation that does not exist. Just use <code>new StripeProcessor()</code> or inject it directly via DI. Extract a factory later when the second implementation arrives.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Two simple variants</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Two variants that will never grow can be handled with a simple if/else or a ternary. The overhead of an abstract class hierarchy for two cases is disproportionate. A Simple Factory (static method with a conditional) is the appropriate tool. Upgrade to Factory Method when the third case appears.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Short-lived scripts or CLIs</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">A one-off migration script or a CLI tool that runs once and is discarded does not need the maintainability infrastructure that Factory Method provides. The code will never be extended, tested in isolation, or injected with a different implementation. Optimise for writing speed and readability, not extensibility.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Consumer always knows the type</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">If the calling code explicitly selects the type â€” "if user chose Stripe use Stripe" â€” then the type decision is already at the call site. The factory would be a thin wrapper around a switch statement. The indirection adds no value; it only obscures the branching logic that the reader needs to see to understand the flow.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Same constructor signatures</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">If all variants can be constructed identically and the only difference is the class name, DI's built-in registration handles the variation: <code>services.AddTransient&lt;IProcessor, StripeProcessor&gt;()</code>. No factory class needed. The DI container already IS the factory method in this case.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> DI already provides the behaviour</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">ASP.NET Core's keyed services, environment-specific registrations, and IOptions-based configuration already handle most provider-switching scenarios without explicit factory classes. Creating a factory class that just wraps a DI resolution call adds a class with no logic of its own â€” evaluate whether the DI container's built-in features are sufficient first.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Premature abstraction (YAGNI)</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">Building a factory because "we might need multiple providers someday" is speculative complexity. YAGNI â€” You Aren't Gonna Need It. The future requirement may never materialise, or when it does, it may look completely different from what you imagined. Abstractions based on speculation are more often wrong than right. Abstract when you have the second concrete case in hand.</p>
        </div>
        <div style="padding:1rem;border:1px solid rgba(239,68,68,0.25);border-radius:0.75rem;background:rgba(239,68,68,0.04);">
          <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;"><i class="fa-solid fa-ban"></i> Hot path performance</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);">If the factory is called millions of times per second (e.g., per-message creation in a high-throughput pipeline), the virtual dispatch, DI resolution, and reflection-based discovery add measurable latency. In these scenarios, use a pre-resolved delegate or a direct object reference cached at startup. Profile first â€” most applications are not in this category.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="card open">
    <div class="card-title"><i class="fa-solid fa-ruler-combined" style="color:var(--accent-green)"></i> The 2-Algorithm Rule â€” Your Quick Decision Heuristic</div>
    <div class="card-body">
      <div class="callout callout-success">
        <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> The 2-Algorithm Rule</div>
        <p style="color:var(--text-secondary);font-size:0.95rem;margin-bottom:0.75rem;">This heuristic comes from the principle of not over-generalising until you have multiple concrete examples. Applied to Factory Method:</p>
        <ul class="styled green" style="margin-top:0.5rem;">
          <li><strong>1 variant</strong> â€” No factory needed. Use <code>new</code> directly or a simple DI registration. Adding factory infrastructure for one implementation is pure overhead with zero benefit.</li>
          <li><strong>2 variants</strong> â€” Evaluate carefully. If the variants are stable and will never grow (e.g., test stub vs real implementation), a simple if/else or conditional DI registration is sufficient. If growth is likely or the variants have genuinely different construction logic, introduce the factory now.</li>
          <li><strong>3+ variants</strong> â€” Factory Method is required. At three or more variants, the pattern pays for itself in the first week. Every subsequent variant takes minutes to add rather than hours to find and update all call sites. The OCP benefit is fully realised.</li>
        </ul>
      </div>
      <div class="grid-2" style="margin-top:1.5rem;">
        <div class="callout callout-info">
          <div class="callout-title"><i class="fa-solid fa-clock-rotate-left"></i> The Refactoring Path</div>
          <p style="color:var(--text-secondary);font-size:0.9rem;">Start simple. When the second variant appears, consider refactoring. When the third appears, refactor unconditionally. This approach ensures your abstraction is designed to fit real cases â€” not imagined future ones. The cost of adding a factory when you have two concrete examples is low; the cost of designing around the wrong abstraction is high.</p>
        </div>
        <div class="callout callout-warning">
          <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> The Exception to the Rule</div>
          <p style="color:var(--text-secondary);font-size:0.9rem;">If you are building a framework, library, or platform that OTHERS will extend, introduce the factory immediately â€” even with one variant. Your users need the extension point available before they have their own concrete implementation. The "1 variant" rule applies to application code, not to infrastructure or framework code designed for extensibility.</p>
        </div>
      </div>
      <div class="callout callout-info" style="margin-top:1rem;">
        <div class="callout-title"><i class="fa-solid fa-quote-left"></i> The Senior Litmus Test</div>
        <p style="color:var(--text-secondary);font-size:0.95rem;font-style:italic;">"Can you name two concrete implementations that exist TODAY, not someday? Can you write a meaningful unit test for the factory that uses a different implementation than production uses? If yes to both â€” use Factory Method. If you are guessing at future requirements â€” don't."</p>
        <p style="color:var(--text-muted);font-size:0.875rem;margin-top:0.5rem;">Engineering principle: abstract what you know, not what you imagine.</p>
      </div>
    </div>
  </div>
</section>

<!-- END PHASE 3 -->
<!-- ============================================================ SECTION 16 -->
<section id="s16" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-triangle-exclamation"></i></div>
    <div><div class="section-num">Section 16</div><h2 class="section-title">Pitfalls &amp; Anti-Patterns</h2></div>
  </div>

  <!-- Pitfall 1 -->
  <div class="collapsible active">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">1</span> The God Factory &mdash; Business Logic in CreateProcessor()</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">The factory method becomes a catch-all for orchestration logic. It makes database calls to verify account status, validates business rules like MFA requirements, checks rate limits, and fires analytics events â€” all before constructing the object. The factory is now a service in disguise, coupled to the entire application layer.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Why This Is Bad</div>
        <ul class="styled red">
          <li><strong>SRP violation</strong> â€” the factory now owns creation AND business rules AND persistence reads</li>
          <li><strong>Reduced testability</strong> â€” to test processor creation you need a live database, MFA service, and analytics client</li>
          <li><strong>Deployment risk</strong> â€” a DB schema change can break the factory and prevent any processor from being constructed</li>
          <li><strong>Hidden coupling</strong> â€” callers believe they are only asking for an object but a full business workflow executes</li>
        </ul>
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Logic Inside Factory</div></div>
          <pre><code class="language-csharp">public override IPaymentProcessor CreateProcessor()
{
    // DB call inside factory â€” wrong
    var account = _db.Accounts.Find(_accountId);
    if (!account.MfaVerified)
        throw new SecurityException("MFA required");
    // Business rule inside factory â€” wrong
    if (account.Balance &lt; MinimumBalance)
        throw new BusinessException("Insufficient balance");
    return new StripePaymentProcessor(_apiKey);
}</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” Factory Only Creates</div></div>
          <pre><code class="language-csharp">// Factory: pure creation, no business rules
public override IPaymentProcessor CreateProcessor()
    => new StripePaymentProcessor(_apiKey, _logger);

// Service layer: business rules before calling factory
public async Task ProcessAsync(PaymentRequest req)
{
    await _mfaService.VerifyAsync(req.AccountId);
    await _balanceGuard.EnforceAsync(req.AccountId);
    var processor = _factory.CreateProcessor();
    await processor.ProcessAsync(req);
}</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 2 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">2</span> The Leaky Factory &mdash; Exposing Concrete Types</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">The factory declares its return type as a concrete class (<code>StripePaymentProcessor</code>) instead of the interface (<code>IPaymentProcessor</code>), or exposes provider-specific methods like <code>SetStripeApiKey()</code> on the factory interface itself. Callers begin to depend on the concrete type, defeating the entire purpose of abstraction.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Why This Is Bad</div>
        <ul class="styled red">
          <li><strong>Violates DIP</strong> â€” high-level modules now depend on the Stripe SDK, not an abstraction</li>
          <li><strong>Violates ISP</strong> â€” the factory interface is polluted with provider-specific methods all other implementations must ignore</li>
          <li><strong>Refactoring cost</strong> â€” replacing Stripe requires changing every callsite that uses the concrete return type</li>
        </ul>
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Returns Concrete Type</div></div>
          <pre><code class="language-csharp">public interface IPaymentFactory
{
    // Leaks concrete type + Stripe-specific method
    StripePaymentProcessor CreateProcessor();
    void SetStripeApiKey(string key);
}
// Caller now depends on StripePaymentProcessor directly
var processor = factory.CreateProcessor();
processor.EnableIdempotencyKeys(); // Stripe-only API</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” Returns Interface</div></div>
          <pre><code class="language-csharp">public interface IPaymentFactory
{
    // Returns abstraction only
    IPaymentProcessor CreateProcessor();
}
// Caller depends only on IPaymentProcessor
IPaymentProcessor processor = factory.CreateProcessor();
await processor.ProcessAsync(request); // Only interface methods</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 3 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">3</span> The Switch Factory &mdash; Switch Statement Inside the Factory Method</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A single factory class contains a switch or if-else chain on a provider type enum to decide which concrete product to create. Every time a new provider is added, this single file must be modified. This is the procedural approach mistaken for the Factory Method pattern â€” it offers no polymorphism benefit.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Why This Is Bad</div>
        <ul class="styled red">
          <li><strong>Violates OCP</strong> â€” adding a new provider requires modifying existing code, risking regressions in all other branches</li>
          <li><strong>Violates SRP</strong> â€” one class is responsible for knowing how to create every concrete product</li>
          <li><strong>Merge conflicts</strong> â€” every team adding a new provider touches the same switch file</li>
        </ul>
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Switch Inside Factory</div></div>
          <pre><code class="language-csharp">public IPaymentProcessor CreateProcessor(string provider)
{
    return provider switch
    {
        "Stripe"  => new StripePaymentProcessor(_cfg),
        "PayPal"  => new PayPalPaymentProcessor(_cfg),
        "Square"  => new SquarePaymentProcessor(_cfg),
        _ => throw new ArgumentException("Unknown provider")
    };
    // Adding ApplePay means editing this file
}</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” One Subclass Per Provider</div></div>
          <pre><code class="language-csharp">// Each provider gets its own factory subclass
public class StripePaymentFactory : PaymentFactory
{
    public override IPaymentProcessor CreateProcessor()
        => new StripePaymentProcessor(_stripeConfig);
}
// New provider = new file, no existing code modified
public class ApplePayFactory : PaymentFactory
{
    public override IPaymentProcessor CreateProcessor()
        => new ApplePayProcessor(_appleConfig);
}</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 4 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">4</span> The Captive Dependency &mdash; Singleton Factory Captures Scoped DbContext</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A factory registered as Singleton accepts a Scoped service (such as <code>DbContext</code>) in its constructor. The Scoped service is captured for the Singleton's lifetime â€” effectively becoming a de-facto Singleton. Under sustained load, the captured DbContext accumulates stale change tracker state and eventually throws <code>ObjectDisposedException</code> when the original scope is disposed.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Production Failure Mode</div>
        Singleton factory holds reference to a Scoped DbContext from request #1. By request #10,000 the change tracker contains thousands of stale entities. Connection pool is exhausted. <code>ObjectDisposedException</code> cascades to every new request.
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Captured Scoped Service</div></div>
          <pre><code class="language-csharp">// Singleton factory captures Scoped DbContext
public class PaymentFactory : IPaymentFactory
{
    private readonly AppDbContext _db; // captured!
    public PaymentFactory(AppDbContext db) { _db = db; }
    public IPaymentProcessor CreateProcessor() { ... }
}
services.AddSingleton&lt;IPaymentFactory, PaymentFactory&gt;();</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” IServiceScopeFactory</div></div>
          <pre><code class="language-csharp">public class PaymentFactory : IPaymentFactory
{
    private readonly IServiceScopeFactory _scopeFactory;
    public PaymentFactory(IServiceScopeFactory sf) { _scopeFactory = sf; }
    public IPaymentProcessor CreateProcessor()
    {
        using var scope = _scopeFactory.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;();
        return new StripePaymentProcessor(db.Settings.ApiKey);
    }
}</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 5 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">5</span> The Reflection Factory &mdash; Using Activator.CreateInstance</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">The factory uses <code>Activator.CreateInstance</code> or <code>Type.GetType()</code> to construct objects by type name string. This approach sacrifices compile-time safety entirely. Constructor signature changes, renamed classes, or missing assemblies all become silent runtime failures that surface only in production under specific conditions.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Why This Is Bad</div>
        <ul class="styled red">
          <li>Constructor parameter changes compile fine but throw <code>MissingMethodException</code> at runtime</li>
          <li>Renamed types become <code>null</code> from <code>Type.GetType()</code> with no compiler warning</li>
          <li>Refactoring tools (rename/move class) do not update string-based type names</li>
          <li>AOT compilation and trimming break entirely â€” types are removed as "unused"</li>
        </ul>
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Reflection-Based Creation</div></div>
          <pre><code class="language-csharp">public IPaymentProcessor CreateProcessor(string typeName)
{
    // Loses compile-time safety entirely
    var type = Type.GetType(typeName); // null if renamed
    return (IPaymentProcessor)Activator.CreateInstance(
        type, _config); // MissingMethodException risk
}</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” Explicit Subclasses</div></div>
          <pre><code class="language-csharp">// Strongly-typed, refactoring-safe, AOT-compatible
public class StripePaymentFactory : PaymentFactory
{
    private readonly StripeConfig _cfg;
    public StripePaymentFactory(StripeConfig cfg) { _cfg = cfg; }
    public override IPaymentProcessor CreateProcessor()
        => new StripePaymentProcessor(_cfg); // compile-time verified
}</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 6 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">6</span> The Chatty Factory &mdash; Logging Inside Every Factory Method</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">Each concrete factory subclass independently logs "Creating StripeProcessor...", "Creating PayPalProcessor...", etc. in its <code>CreateProcessor()</code> override. Under high-throughput systems where processors are created per-request, factory log lines dominate log volume, drowning out meaningful operational signals and inflating log storage costs.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Production Impact</div>
        At 5,000 req/s with one log line per factory creation: 432 million log entries per day. Log aggregation pipeline backs up. Alert latency increases from 5s to 4 minutes. Real errors are buried in creation noise.
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” Logging in Every Subclass</div></div>
          <pre><code class="language-csharp">public class StripePaymentFactory : PaymentFactory
{
    public override IPaymentProcessor CreateProcessor()
    {
        _logger.LogInformation("Creating StripeProcessor"); // noise
        return new StripePaymentProcessor(_cfg);
    }
}
// Repeated verbatim in PayPalFactory, SquareFactory, etc.</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” Log in Base Template Method</div></div>
          <pre><code class="language-csharp">public abstract class PaymentFactory : IPaymentFactory
{
    // Template method: log once in base, override in subclass
    public IPaymentProcessor GetProcessor()
    {
        var processor = CreateProcessor(); // subclass override
        _logger.LogDebug("Created {Type}", processor.GetType().Name);
        return processor;
    }
    protected abstract IPaymentProcessor CreateProcessor();
}</code></pre>
        </div>
      </div>
    </div></div>
  </div>

  <!-- Pitfall 7 -->
  <div class="collapsible">
    <div class="collapsible-header">
      <div style="font-weight:700;display:flex;align-items:center;gap:0.75rem;"><span style="color:var(--accent-yellow);font-size:1.25rem;">7</span> The Coupled Factory &mdash; Factory Depends on All Concrete Products</div>
      <i class="fa-solid fa-chevron-down collapsible-chevron"></i>
    </div>
    <div class="collapsible-content"><div class="collapsible-body">
      <p class="body-text">A single factory class imports and references every concrete processor type. The Stripe SDK, PayPal SDK, Square SDK, and Apple Pay SDK are all direct dependencies of one file. Upgrading the Stripe SDK forces recompilation of the entire factory â€” even code that only uses PayPal. Any SDK breaking change forces all processor implementations to be retested simultaneously.</p>
      <div class="callout callout-danger">
        <div class="callout-title"><i class="fa-solid fa-skull"></i> Why This Is Bad</div>
        <ul class="styled red">
          <li>Adding a new SDK to one factory assembly forces all existing SDK tests to re-run</li>
          <li>A breaking change in one SDK's NuGet package blocks deployment of all other processors</li>
          <li>Assembly grows with every new provider â€” binary size and cold-start time increase</li>
        </ul>
      </div>
      <div class="two-col">
        <div>
          <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-xmark"></i> BAD â€” One Factory Knows All Products</div></div>
          <pre><code class="language-csharp">// One class references all SDK types
using Stripe;     // StripePaymentProcessor
using PayPalSDK;  // PayPalPaymentProcessor
using SquareSDK;  // SquarePaymentProcessor
public class AllPaymentFactory
{
    public IPaymentProcessor Create(string p) { /* switch */ }
}</code></pre>
        </div>
        <div>
          <div class="callout callout-success"><div class="callout-title"><i class="fa-solid fa-check"></i> GOOD â€” Each Factory References Only Its Own Product</div></div>
          <pre><code class="language-csharp">// Stripe assembly â€” only knows Stripe
using Stripe;
public class StripePaymentFactory : PaymentFactory
{
    public override IPaymentProcessor CreateProcessor()
        => new StripePaymentProcessor(_stripeCfg);
}
// PayPal assembly â€” independent, only knows PayPal
using PayPalSDK;
public class PayPalPaymentFactory : PaymentFactory { ... }</code></pre>
        </div>
      </div>
    </div></div>
  </div>

</section>

<!-- ============================================================ SECTION 18 -->
<section id="s18" class="section">
  <div class="section-header">
    <div class="section-icon cyan"><i class="fa-solid fa-bolt"></i></div>
    <div><div class="section-num">Section 18</div><h2 class="section-title">Cheat Sheet</h2></div>
  </div>

  <div class="grid-2">

    <!-- Card 1: Intent -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-bullseye" style="color:var(--accent-cyan)"></i> Intent</div>
      <p class="body-text">"Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses."</p>
      <div class="callout callout-info" style="margin-top:0.75rem;">
        <div class="callout-title"><i class="fa-solid fa-circle-info"></i> GoF Creational Pattern</div>
        Encapsulates the <em>how</em> of object creation. The creator works with abstractions; the subclass supplies the concrete type.
      </div>
    </div>

    <!-- Card 2: Structure -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-sitemap" style="color:var(--accent-purple)"></i> Structure</div>
      <div style="font-size:0.75rem;line-height:1.7;background:rgba(0,0,0,0.3);border-radius:0.5rem;padding:1rem;font-family:'JetBrains Mono',monospace;color:#a5f3fc;">
        <div style="color:#c678dd;">Â«abstractÂ» Creator</div>
        <div style="padding-left:0.75rem;">+ <span style="color:#61afef;">FactoryMethod</span>(): IProduct</div>
        <div style="padding-left:0.75rem;">+ <span style="color:#61afef;">SomeOperation</span>()</div>
        <div style="color:var(--text-muted);padding:0.25rem 0 0.25rem 1rem;">â–² extends</div>
        <div style="color:#c678dd;">ConcreteCreator</div>
        <div style="padding-left:0.75rem;">+ <span style="color:#61afef;">FactoryMethod</span>(): IProduct</div>
        <div style="border-top:1px solid rgba(255,255,255,0.1);margin:0.5rem 0;"></div>
        <div style="color:#c678dd;">Â«interfaceÂ» IProduct</div>
        <div style="padding-left:0.75rem;">+ <span style="color:#61afef;">Use</span>()</div>
        <div style="color:var(--text-muted);padding:0.25rem 0 0.25rem 1rem;">â–² implements</div>
        <div style="color:#c678dd;">ConcreteProduct</div>
        <div style="padding-left:0.75rem;">+ <span style="color:#61afef;">Use</span>()</div>
      </div>
    </div>

    <!-- Card 3: Key Mechanism -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-gears" style="color:var(--accent-green)"></i> Key Mechanism</div>
      <p class="body-text">Polymorphic creation via subclass override. The <code>new</code> keyword is pushed into the subclass â€” the base class never directly instantiates a concrete product.</p>
      <ul class="styled green" style="margin-top:0.75rem;">
        <li>Base class calls <code>CreateProcessor()</code> â€” abstract or virtual</li>
        <li>Subclass overrides it and calls <code>new ConcreteProduct()</code></li>
        <li>Base class only sees <code>IProduct</code> â€” zero coupling to concrete type</li>
      </ul>
    </div>

    <!-- Card 4: C# Idiom -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-brands fa-microsoft" style="color:var(--accent-blue)"></i> C# Idiom</div>
      <pre><code class="language-csharp">// Abstract factory
public abstract class PaymentFactory
{
    public abstract IPaymentProcessor CreateProcessor();
}
// Concrete factory
public class StripePaymentFactory : PaymentFactory
{
    public override IPaymentProcessor CreateProcessor()
        => new StripePaymentProcessor(_cfg);
}
// DI registration
services.AddScoped&lt;IPaymentFactory, StripePaymentFactory&gt;();</code></pre>
    </div>

    <!-- Card 5: SOLID Impact -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-shield-halved" style="color:var(--accent-yellow)"></i> SOLID Impact</div>
      <ul class="styled yellow" style="margin-top:0.5rem;">
        <li><strong>S</strong> â€” Each factory class has one responsibility: creating one product type</li>
        <li><strong>O</strong> â€” New product variant = new subclass. Zero modification of existing code</li>
        <li><strong>L</strong> â€” All products are substitutable via the shared <code>IProduct</code> interface</li>
        <li><strong>I</strong> â€” Factory interface exposes only creation methods; no provider-specific leaks</li>
        <li><strong>D</strong> â€” High-level modules depend on <code>IPaymentFactory</code> and <code>IPaymentProcessor</code>, never on concrete types</li>
      </ul>
    </div>

    <!-- Card 6: Thread Safety -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-lock" style="color:var(--accent-red)"></i> Thread Safety</div>
      <ul class="styled red" style="margin-top:0.5rem;">
        <li><strong>Factory</strong> â€” Register as <strong>Singleton</strong> if stateless (no mutable fields). Stateless factories are inherently thread-safe.</li>
        <li><strong>Product</strong> â€” Register as <strong>Transient</strong> (per-use). A new instance per call eliminates shared-state races.</li>
        <li><strong>Beware captive dependencies</strong> â€” Singleton factory + Scoped DbContext = <code>ObjectDisposedException</code> under load. Use <code>IServiceScopeFactory</code>.</li>
      </ul>
    </div>

    <!-- Card 7: Testing -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-flask" style="color:var(--accent-green)"></i> Testing Strategy</div>
      <ul class="styled green" style="margin-top:0.5rem;">
        <li><strong>Unit test services</strong> â€” Mock <code>IPaymentFactory</code> (not the product). Service tests should not spin up real processors.</li>
        <li><strong>Unit test factories</strong> â€” Assert <code>CreateProcessor()</code> returns the correct concrete type with correct config.</li>
        <li><strong>Use NullLoggerFactory</strong> â€” <code>NullLoggerFactory.Instance</code> eliminates logger noise in factory unit tests.</li>
        <li><strong>Integration tests</strong> â€” <code>WebApplicationFactory&lt;T&gt;</code> with real DI. Override factory registrations via <code>ConfigureTestServices</code>.</li>
      </ul>
    </div>

    <!-- Card 8: When to Use -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-calendar-check" style="color:var(--accent-cyan)"></i> When to Use</div>
      <ul class="styled cyan" style="margin-top:0.5rem;">
        <li>You have <strong>3 or more variants</strong> of a product, or expect growth beyond 2 variants</li>
        <li>Each variant requires <strong>complex, provider-specific setup</strong> in its constructor</li>
        <li><strong>Runtime selection</strong> is needed â€” provider determined by config, user preference, or feature flag</li>
        <li>You are writing a <strong>framework extension point</strong> â€” consumers plug in their own implementations without modifying your code</li>
      </ul>
    </div>

    <!-- Card 9: .NET Examples -->
    <div class="cheat-card">
      <div class="cheat-card-title"><i class="fa-solid fa-cube" style="color:var(--accent-purple)"></i> .NET Built-In Examples</div>
      <ul class="styled purple" style="margin-top:0.5rem;">
        <li><code>ILoggerFactory</code> â€” creates <code>ILogger&lt;T&gt;</code> instances per category name</li>
        <li><code>IHttpClientFactory</code> â€” creates configured <code>HttpClient</code> instances per named client</li>
        <li><code>IServiceScopeFactory</code> â€” creates <code>IServiceScope</code> instances for manual scoping</li>
        <li><code>IDbContextFactory&lt;T&gt;</code> â€” creates fresh <code>DbContext</code> instances in Singleton/background services</li>
        <li><code>WebApplicationFactory&lt;T&gt;</code> â€” creates <code>TestServer</code> instances for integration testing</li>
      </ul>
    </div>

  </div>

  <!-- Decision Tree Diagram -->
  <div class="card" style="margin-top:2rem;">
    <div class="card-title"><i class="fa-solid fa-code-branch" style="color:var(--accent-cyan)"></i> Adding a New Provider â€” Decision Flowchart</div>
    <div class="mermaid-container"><span class="diagram-hint"><i class="fa-solid fa-up-down-left-right"></i> Scroll &amp; pinch to zoom</span>
      <div class="mermaid">
flowchart TD
    START(["Need a new payment provider?"]) --> A["Create ConcreteProduct\nimplementing IPaymentProcessor\n(e.g. ApplePayProcessor.cs)"]
    A --> B["Create ConcreteFactory\nextending PaymentFactory\n(e.g. ApplePayFactory.cs)"]
    B --> C["Register in DI\nservices.AddScoped&lt;IPaymentFactory,\nApplePayFactory&gt;()"]
    C --> D["Write unit test\nfor ApplePayFactory.CreateProcessor()"]
    D --> DONE(["Done âœ“\nZero existing files modified"])

    style START fill:#0f3460,stroke:#3b82f6,color:#f1f5f9
    style A fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style B fill:#064e3b,stroke:#10b981,color:#f1f5f9
    style C fill:#1e1b4b,stroke:#8b5cf6,color:#f1f5f9
    style D fill:#1a2e1a,stroke:#22c55e,color:#f1f5f9
    style DONE fill:#0c4a6e,stroke:#06b6d4,color:#f1f5f9
      </div>
    </div>
  </div>

</section>

<div class="footer">
  <p>&copy; 2026 Rafikul Alam &mdash; Pattern Playbook</p>
  <p style="font-size:0.75rem;margin-top:0.5rem;">Factory Method Design Pattern &mdash; Complete Wiki Reference</p>
</div>

</div><!-- /.wiki-container -->

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Wrap card content into collapsible card-body divs
  document.querySelectorAll('.card').forEach(function(card) {
    var title = card.querySelector('.card-title');
    if (!title) return;
    var body = document.createElement('div');
    body.className = 'card-body';
    while (title.nextSibling) {
      body.appendChild(title.nextSibling);
    }
    card.appendChild(body);
    title.addEventListener('click', function() {
      card.classList.toggle('open');
    });
  });

  // Jr â†’ Sr toggle: close others, toggle current
  window.toggleSrSolution = function(btn) {
    var item = btn.closest('.jr-sr-item');
    var wrap = item.querySelector('.sr-solution-wrap');
    var isOpen = wrap.classList.contains('show');
    // Close all open solutions
    document.querySelectorAll('.sr-solution-wrap.show').forEach(function(w) {
      w.classList.remove('show');
    });
    // Toggle current (if it was closed, open it)
    if (!isOpen) {
      wrap.classList.add('show');
    }
  };

  // Make mermaid diagrams collapsible (start collapsed)
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var label = 'Show Diagram';
    var prev = container.previousElementSibling;
    if (prev && prev.tagName === 'H3') {
      label = prev.textContent.trim();
      prev.style.display = 'none';
    }
    var toggle = document.createElement('div');
    toggle.className = 'diagram-toggle';
    toggle.innerHTML = '<i class="fa-solid fa-diagram-project"></i> ' + label + ' <i class="fa-solid fa-chevron-down chevron"></i>';
    container.parentNode.insertBefore(toggle, container);
    container.classList.add('collapsed');
    toggle.addEventListener('click', function() {
      toggle.classList.toggle('open');
      container.classList.toggle('collapsed');
    });
  });

  // Pinch-to-zoom + zoom buttons for mermaid diagrams
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var mermaidEl = container.querySelector('.mermaid');
    if (!mermaidEl) return;
    var scale = 1;
    var minScale = 0.5;
    var maxScale = 3;

    // Add zoom buttons
    var zoomDiv = document.createElement('div');
    zoomDiv.className = 'diagram-zoom-controls';
    zoomDiv.innerHTML = '<button class="diagram-zoom-btn" data-action="out" title="Zoom out"><i class="fa-solid fa-minus"></i></button><button class="diagram-zoom-btn" data-action="reset" title="Reset zoom"><i class="fa-solid fa-rotate-left"></i></button><button class="diagram-zoom-btn" data-action="in" title="Zoom in"><i class="fa-solid fa-plus"></i></button>';
    container.appendChild(zoomDiv);

    function applyZoom() {
      mermaidEl.style.transform = 'scale(' + scale + ')';
      mermaidEl.style.transformOrigin = 'top left';
    }

    zoomDiv.addEventListener('click', function(e) {
      var btn = e.target.closest('[data-action]');
      if (!btn) return;
      var action = btn.getAttribute('data-action');
      if (action === 'in') scale = Math.min(maxScale, scale + 0.25);
      else if (action === 'out') scale = Math.max(minScale, scale - 0.25);
      else { scale = 1; }
      applyZoom();
    });

    // Touch pinch-to-zoom
    var lastDist = 0;
    var startScale = 1;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        startScale = scale;
      }
    }, { passive: false });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        var dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        scale = Math.min(maxScale, Math.max(minScale, startScale * (dist / lastDist)));
        applyZoom();
      }
    }, { passive: false });

    // Single-finger pan when zoomed
    var panStartX, panStartY, scrollStartX, scrollStartY;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        panStartX = e.touches[0].clientX;
        panStartY = e.touches[0].clientY;
        scrollStartX = container.scrollLeft;
        scrollStartY = container.scrollTop;
      }
    });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 1 && scale > 1) {
        e.preventDefault();
        container.scrollLeft = scrollStartX - (e.touches[0].clientX - panStartX);
        container.scrollTop = scrollStartY - (e.touches[0].clientY - panStartY);
      }
    }, { passive: false });
  });

  // Initialize Highlight.js
  document.querySelectorAll('pre code').forEach(function(block) {
    hljs.highlightElement(block);
  });

  // Q&A toggle
  document.querySelectorAll('.qa-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Generic collapsible sections
  document.querySelectorAll('.collapsible-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Tab system
  document.querySelectorAll('.tab-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var container = this.closest('.tab-container');
      var target = this.getAttribute('data-tab');

      container.querySelectorAll('.tab-btn').forEach(function(b) {
        b.classList.remove('active');
      });
      container.querySelectorAll('.tab-panel').forEach(function(p) {
        p.classList.remove('active');
      });

      this.classList.add('active');
      var panel = container.querySelector('[data-panel="' + target + '"]');
      if (panel) panel.classList.add('active');
    });
  });

  // Nav toggle
  var navFab = document.getElementById('navFab');
  var navPanel = document.getElementById('navPanel');
  navFab.addEventListener('click', function() {
    navPanel.classList.toggle('open');
    navFab.classList.toggle('active');
  });

  // Smooth scroll helper with easing
  function smoothScrollTo(targetY, duration) {
    var prefersReduced = window.matchMedia('(prefers-reduced-motion:reduce)').matches;
    if (prefersReduced) { window.scrollTo(0, targetY); return; }
    var startY = window.scrollY;
    var diff = targetY - startY;
    var startTime = null;
    function step(timestamp) {
      if (!startTime) startTime = timestamp;
      var progress = Math.min((timestamp - startTime) / duration, 1);
      var ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      window.scrollTo(0, startY + diff * ease);
      if (progress < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // Nav panel links â€” smooth scroll + auto-close
  document.querySelectorAll('.nav-panel a').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      var target = document.querySelector(this.getAttribute('href'));
      if (target) {
        var offset = target.getBoundingClientRect().top + window.scrollY - ((document.querySelector('.top-toolbar')||{}).offsetHeight||56) - 8;
        smoothScrollTo(offset, 800);
      }
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    });
  });

  // Click outside to close nav panel and open diagrams
  document.addEventListener('click', function(e) {
    if (navPanel.classList.contains('open') && !navPanel.contains(e.target) && !navFab.contains(e.target)) {
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    }
    document.querySelectorAll('.diagram-toggle.open').forEach(function(toggle) {
      var container = toggle.nextElementSibling;
      if (!toggle.contains(e.target) && !container.contains(e.target)) {
        toggle.classList.remove('open');
        container.classList.add('collapsed');
      }
    });
  });

  // Scroll up/down buttons
  document.getElementById('scrollUp').addEventListener('click', function() {
    window.scrollBy({ top: -Math.round(window.innerHeight*0.35), behavior: 'smooth' });
  });
  document.getElementById('scrollDown').addEventListener('click', function() {
    window.scrollBy({ top: Math.round(window.innerHeight*0.35), behavior: 'smooth' });
  });

  // Scroll percentage tracker
  var percentText = document.getElementById('percentText');
  window.addEventListener('scroll', function() {
    var docHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percent = docHeight > 0 ? Math.round((window.scrollY / docHeight) * 100) : 0;
    percentText.textContent = percent + '%';
  });

  // Fullscreen toggle
  var fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', function() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });
  document.addEventListener('fullscreenchange', function() {
    var icon = fsBtn.querySelector('i');
    if (document.fullscreenElement) {
      icon.className = 'fa-solid fa-compress';
    } else {
      icon.className = 'fa-solid fa-expand';
    }
  });

  // Expand/Collapse all cards toggle
  var expandBtn = document.getElementById('expandAllBtn');
  var allExpanded = false;
  expandBtn.addEventListener('click', function() {
    allExpanded = !allExpanded;
    var cards = document.querySelectorAll('.card');
    cards.forEach(function(card) {
      if (allExpanded) {
        card.classList.add('open');
      } else {
        card.classList.remove('open');
      }
    });
    var icon = expandBtn.querySelector('i');
    icon.className = allExpanded ? 'fa-solid fa-angles-up' : 'fa-solid fa-angles-down';
    expandBtn.title = allExpanded ? 'Collapse all cards' : 'Expand all cards';
  });
});
</script>
</body>
</html>
