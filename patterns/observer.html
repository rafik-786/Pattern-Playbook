<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Observer Design Pattern â€” Complete Wiki</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“˜</text></svg>">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true,theme:'base',themeVariables:{primaryColor:'#1e3a5f',primaryTextColor:'#f1f5f9',primaryBorderColor:'#3b82f6',lineColor:'#60a5fa',secondaryColor:'#2d1b4e',secondaryTextColor:'#f1f5f9',secondaryBorderColor:'#8b5cf6',tertiaryColor:'#1a3a2a',tertiaryTextColor:'#f1f5f9',tertiaryBorderColor:'#10b981',mainBkg:'#1e3a5f',nodeBorder:'#3b82f6',clusterBkg:'#0f172a',clusterBorder:'#334155',titleColor:'#f1f5f9',edgeLabelBackground:'#1e293b',nodeTextColor:'#f1f5f9',actorBkg:'#1e3a5f',actorBorder:'#3b82f6',actorTextColor:'#f1f5f9',actorLineColor:'#60a5fa',signalColor:'#60a5fa',signalTextColor:'#f1f5f9',labelBoxBkgColor:'#1e293b',labelBoxBorderColor:'#3b82f6',labelTextColor:'#f1f5f9',loopTextColor:'#f1f5f9',activationBorderColor:'#3b82f6',activationBkgColor:'#1e3a5f',sequenceNumberColor:'#f1f5f9',noteBkgColor:'#2d1b4e',noteTextColor:'#e2e8f0',noteBorderColor:'#8b5cf6',classText:'#f1f5f9',relationColor:'#60a5fa',relationLabelColor:'#94a3b8',fontFamily:'Inter',fontSize:'14px',background:'#0f172a'}});</script>
<style>
:root{--bg-primary:#0f172a;--bg-secondary:#1e293b;--bg-tertiary:#334155;--accent-blue:#3b82f6;--accent-purple:#8b5cf6;--accent-green:#10b981;--accent-red:#ef4444;--accent-yellow:#f59e0b;--accent-cyan:#06b6d4;--text-primary:#f1f5f9;--text-secondary:#94a3b8;--text-muted:#64748b;--border-color:#334155;--glass-bg:rgba(30,41,59,0.7);--glass-border:rgba(148,163,184,0.1);}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}
html{scroll-behavior:smooth;}
body{font-family:'Inter',sans-serif;background:var(--bg-primary);color:var(--text-primary);line-height:1.6;font-size:1rem;padding-top:52px;}
::-webkit-scrollbar{width:8px;}::-webkit-scrollbar-track{background:var(--bg-secondary);}::-webkit-scrollbar-thumb{background:var(--bg-tertiary);border-radius:4px;}::-webkit-scrollbar-thumb:hover{background:var(--accent-blue);}
.wiki-container{max-width:100%;margin:0 auto;padding:0 2rem 4rem;}
.hero{background:linear-gradient(135deg,#0f172a 0%,#1e1b4b 50%,#0f172a 100%);border-bottom:1px solid var(--border-color);padding:3rem 2rem 3rem;text-align:center;position:relative;overflow:hidden;}
.hero::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at 50% 0%,rgba(59,130,246,0.15) 0%,transparent 70%);}
.hero-badge{display:inline-flex;align-items:center;gap:0.5rem;background:rgba(59,130,246,0.1);border:1px solid rgba(59,130,246,0.3);color:var(--accent-blue);padding:0.375rem 1rem;border-radius:999px;font-size:0.875rem;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;margin-bottom:1.5rem;}
.hero h1{font-size:clamp(2.5rem,5vw,4rem);font-weight:900;background:linear-gradient(135deg,#f1f5f9,#93c5fd,#a78bfa);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin-bottom:1rem;position:relative;}
.hero-subtitle{font-size:1.25rem;color:var(--text-secondary);max-width:700px;margin:0 auto 2rem;}
.hero-meta{display:flex;justify-content:center;gap:2rem;flex-wrap:wrap;font-size:0.9rem;color:var(--text-muted);}
.hero-meta span{display:flex;align-items:center;gap:0.4rem;}
.hero-meta i{color:var(--accent-blue);}
.top-toolbar{position:fixed;top:0;left:0;right:0;z-index:1000;display:flex;align-items:center;justify-content:space-between;padding:0.5rem 1.25rem;background:rgba(15,23,42,0.95);backdrop-filter:blur(12px);border-bottom:1px solid rgba(59,130,246,0.15);box-shadow:0 2px 12px rgba(0,0,0,0.3);overflow:hidden;}
.toolbar-left,.toolbar-right{display:flex;align-items:center;gap:0.5rem;}
.fab-btn{width:38px;height:38px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(30,41,59,0.8);color:#93c5fd;font-size:0.9rem;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.25);transition:background-color 0.2s,border-color 0.2s,color 0.2s,transform 0.2s;display:flex;align-items:center;justify-content:center;text-decoration:none;padding:0;-webkit-tap-highlight-color:transparent;outline:none;}
.fab-btn:hover{background:rgba(59,130,246,0.2);border-color:var(--accent-blue);color:#fff;}
.fab-btn.active{background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-color:transparent;color:#fff;}
.fab-back{border-color:rgba(239,68,68,0.35);color:#fca5a5;width:36px;height:36px;font-size:0.8rem;margin-left:0.75rem;}
.fab-back:hover{border-color:var(--accent-red);background:rgba(239,68,68,0.15);color:#fca5a5;}
.scroll-percent{font-family:'JetBrains Mono',monospace;font-size:0.6875rem;font-weight:700;color:var(--text-muted);user-select:none;min-width:2rem;text-align:center;}
.nav-panel{position:fixed;top:3.5rem;left:1rem;background:rgba(15,23,42,0.97);backdrop-filter:blur(16px);border:1px solid rgba(59,130,246,0.3);border-radius:1rem;padding:1rem;z-index:1001;max-height:70vh;overflow-y:auto;width:220px;max-width:calc(100vw - 2rem);box-shadow:0 12px 40px rgba(0,0,0,0.5);opacity:0;visibility:hidden;transform:translateY(-10px) scale(0.95);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0.25s;}
.nav-panel.open{opacity:1;visibility:visible;transform:translateY(0) scale(1);transition:opacity 0.25s cubic-bezier(0.4,0,0.2,1),transform 0.25s cubic-bezier(0.4,0,0.2,1),visibility 0s linear 0s;}
.nav-panel-title{font-size:0.6875rem;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.08em;margin-bottom:0.5rem;padding:0 0.25rem;}
.nav-panel a{display:flex;align-items:center;gap:0.5rem;padding:0.5rem 0.625rem;border-radius:0.5rem;font-size:0.8125rem;font-weight:500;text-decoration:none;color:#93c5fd;transition:background-color 0.15s,color 0.15s;min-height:44px;}
.nav-panel a:hover{}
.nav-panel a i{width:16px;text-align:center;font-size:0.75rem;color:var(--accent-blue);}
.nav-panel::-webkit-scrollbar{width:4px;}
.nav-panel::-webkit-scrollbar-thumb{background:#475569;border-radius:2px;}
.section{margin:3rem 0;scroll-margin-top:5rem;overflow:hidden;}
.section-header{display:flex;align-items:center;gap:1rem;margin-bottom:2rem;padding-bottom:1rem;border-bottom:2px solid var(--border-color);flex-wrap:wrap;}
.section-icon{width:3rem;height:3rem;border-radius:0.75rem;display:flex;align-items:center;justify-content:center;font-size:1.25rem;flex-shrink:0;}
.section-icon.blue{background:rgba(59,130,246,0.15);color:var(--accent-blue);}
.section-icon.purple{background:rgba(139,92,246,0.15);color:var(--accent-purple);}
.section-icon.green{background:rgba(16,185,129,0.15);color:var(--accent-green);}
.section-icon.red{background:rgba(239,68,68,0.15);color:var(--accent-red);}
.section-icon.yellow{background:rgba(245,158,11,0.15);color:var(--accent-yellow);}
.section-icon.cyan{background:rgba(6,182,212,0.15);color:var(--accent-cyan);}
.section-title{font-size:1.875rem;font-weight:800;}
.section-num{font-size:0.875rem;color:var(--text-muted);font-weight:600;}
.card{background:var(--glass-bg);backdrop-filter:blur(10px);border:1px solid var(--glass-border);border-radius:1rem;padding:0;transition:border-color 0.3s;margin-bottom:0.75rem;overflow:hidden;}
.card.open{overflow:visible;}
.card:hover{border-color:rgba(59,130,246,0.3);}
.card-title{font-size:1.125rem;font-weight:700;margin:0;padding:1rem 1.25rem;display:flex;align-items:center;gap:0.5rem;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;position:relative;}
.card-title::after{content:'\f078';font-family:'Font Awesome 6 Free';font-weight:900;font-size:0.75rem;color:var(--text-muted);margin-left:auto;transition:transform 0.3s;}
.card.open .card-title::after{transform:rotate(180deg);}
.card-body{max-height:0;overflow:hidden;transition:max-height 0.4s cubic-bezier(0.4,0,0.2,1),padding 0.3s;padding:0 1.25rem;}
.card.open .card-body{max-height:none;padding:0 1.25rem 1.25rem;overflow:visible;}
.jr-sr-list{display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;}
@media(max-width:768px){.jr-sr-list{grid-template-columns:1fr;}}
.jr-sr-item{position:relative;display:flex;flex-direction:column;}
.jr-sr-item>.callout{flex:1;}
.sr-toggle{display:flex;width:fit-content;align-items:center;gap:0.4rem;margin-top:0.75rem;padding:0.5rem 0.9rem 0.4rem;border-radius:999px;border:1px solid rgba(16,185,129,0.4);background:rgba(16,185,129,0.1);color:#6ee7b7;font-size:0.8rem;font-weight:600;cursor:pointer;transition:all 0.2s;-webkit-tap-highlight-color:transparent;position:relative;z-index:11;}
.sr-toggle:hover{background:rgba(16,185,129,0.2);border-color:var(--accent-green);color:#a7f3d0;}
.sr-solution-wrap{position:absolute;left:0;right:0;top:0;z-index:10;pointer-events:none;opacity:0;transition:opacity 0.25s ease;}
.sr-solution-wrap.show{pointer-events:auto;opacity:1;}
.sr-solution-wrap>.sr-solution{margin:0;padding:1.25rem 1.5rem;border-left:3px solid var(--accent-green);border-radius:0.75rem;background:#0a1f14;border:1px solid rgba(16,185,129,0.3);box-shadow:0 12px 48px rgba(0,0,0,0.7),0 0 0 1px rgba(16,185,129,0.15);min-height:100%;}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;align-items:start;}
.grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:1.5rem;align-items:start;}
.grid-4{display:grid;grid-template-columns:repeat(4,1fr);gap:1rem;align-items:start;}
.grid-9{display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;}
.grid-2>*,.grid-3>*,.grid-4>*,.grid-9>*,.two-col>*{min-width:0;}
@media(max-width:1024px){
body{font-size:0.9375rem;padding-top:48px;}
.wiki-container{max-width:100%;padding:0 1rem 2rem;}
.hero{padding:2.5rem 1rem 2rem;}
.hero h1{font-size:clamp(1.75rem,4vw,2.5rem);}
.hero-subtitle{font-size:1rem;}
.hero-meta{gap:1rem;font-size:0.8rem;}
.section{margin:2rem 0;scroll-margin-top:4.5rem;}
.section-title{font-size:1.375rem;}
.section-header{gap:0.75rem;margin-bottom:1.25rem;}
.section-icon{width:2.25rem;height:2.25rem;font-size:1rem;}
.card{margin-bottom:1rem;border-radius:0.75rem;}
.card-title{font-size:1rem;}
.callout{padding:1rem;margin:0.75rem 0;}
.macos-body{padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.8rem;line-height:1.5;}
.grid-2{gap:1rem;}
.grid-3{grid-template-columns:repeat(2,1fr);gap:0.75rem;}
table{font-size:0.8125rem;}
td,th{padding:0.5rem 0.75rem;}
.top-toolbar{padding:0.375rem 0.75rem;}
.fab-btn{width:36px;height:36px;font-size:0.8rem;}
.nav-panel{top:3rem;left:0.5rem;width:180px;}
.sr-toggle{padding:0.75rem 1rem;min-height:44px;display:inline-flex;align-items:center;}
.mermaid-container{padding:1rem;max-height:50vh;}
.diagram-hint{display:block;}
.diagram-zoom-btn{width:44px;height:44px;}
}
@media(max-width:768px){
.grid-2,.grid-3,.grid-4,.grid-9{grid-template-columns:1fr;}
.sr-solution-wrap{position:static;opacity:0;max-height:0;overflow:hidden;transition:opacity 0.25s ease,max-height 0.4s cubic-bezier(0.4,0,0.2,1);}
.sr-solution-wrap.show{opacity:1;max-height:3000px;pointer-events:auto;}
.collapsible-body{padding:1rem;}
.tab-btn{padding:0.875rem 1rem;min-height:44px;}
.tab-panel{padding:1rem;}
}
@media(max-width:480px){
.wiki-container{padding:0 0.625rem 1.5rem;}
.hero{padding:2rem 0.75rem 1.5rem;}
body{font-size:1rem;padding-top:44px;}
.hero h1{font-size:1.5rem;}
.hero-subtitle{font-size:0.875rem;}
.section-title{font-size:1.2rem;}
.card-title{font-size:0.9375rem;padding:0.75rem 1rem;}
.macos-body pre code{font-size:0.75rem;}
.top-toolbar{padding:0.25rem 0.5rem;}
.fab-btn{width:36px;height:36px;font-size:0.75rem;}
.nav-panel{top:2.75rem;left:0.5rem;width:min(170px,calc(100vw - 1rem));}
.diagram-zoom-btn{width:44px;height:44px;}
.collapsible-body{padding:0.75rem;}
.hero-meta{gap:0.5rem;}
.qa-content{padding:0 1rem 1rem;}
.section{scroll-margin-top:3.5rem;}
th{white-space:normal;word-break:break-word;}
.footer{padding:2rem 1rem;}
}
.macos-window{background:#1a1a2e;border-radius:0.75rem;border:1px solid rgba(255,255,255,0.08);overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,0.5);margin-bottom:1.5rem;max-width:100%;margin-left:auto;margin-right:auto;}
@media(min-width:1025px){.macos-window{max-width:85%;}}
.macos-titlebar{background:#2d2d3f;padding:0.75rem 1rem;display:flex;align-items:center;gap:0.5rem;border-bottom:1px solid rgba(255,255,255,0.05);}
.dot{width:12px;height:12px;border-radius:50%;}
.dot-red{background:#ff5f57;}.dot-yellow{background:#ffbd2e;}.dot-green{background:#28c840;}
.macos-filename{margin-left:0.75rem;font-size:0.8rem;color:#6b7280;font-family:'JetBrains Mono',monospace;}
.macos-body{padding:1.25rem 1.5rem;max-height:400px;overflow-y:auto;overflow-x:auto;overscroll-behavior:contain;}
.macos-body::-webkit-scrollbar{width:6px;}
.macos-body::-webkit-scrollbar-track{background:rgba(30,41,59,0.5);border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb{background:#475569;border-radius:3px;}
.macos-body::-webkit-scrollbar-thumb:hover{background:#64748b;}
.macos-body pre{margin:0;padding:0;background:transparent;overflow-x:auto;}
.macos-body pre code{display:block!important;font-family:'JetBrains Mono',monospace;font-size:0.9rem;line-height:1.6;background:transparent!important;}
.callout{border-radius:0.75rem;padding:1.25rem 1.5rem;border-left:4px solid;margin:1rem 0;}
.callout-danger{background:rgba(239,68,68,0.08);border-color:var(--accent-red);}
.callout-success{background:rgba(16,185,129,0.08);border-color:var(--accent-green);}
.callout-info{background:rgba(59,130,246,0.08);border-color:var(--accent-blue);}
.callout-warning{background:rgba(245,158,11,0.08);border-color:var(--accent-yellow);}
.callout-title{font-weight:700;font-size:0.9rem;text-transform:uppercase;letter-spacing:0.05em;margin-bottom:0.5rem;display:flex;align-items:center;gap:0.5rem;}
.callout-danger .callout-title{color:var(--accent-red);}
.callout-success .callout-title{color:var(--accent-green);}
.callout-info .callout-title{color:var(--accent-blue);}
.callout-warning .callout-title{color:var(--accent-yellow);}
.callout-tip{background:rgba(16,185,129,0.08);border-color:var(--accent-green);}
.callout-tip .callout-title{color:var(--accent-green);}
.table-wrapper{overflow-x:auto;border-radius:0.75rem;border:1px solid var(--border-color);margin-bottom:1.5rem;}
table{width:100%;border-collapse:collapse;}
thead{background:rgba(59,130,246,0.1);}
th{padding:0.875rem 1.25rem;text-align:left;font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-secondary);white-space:nowrap;}
td{padding:0.875rem 1.25rem;border-top:1px solid var(--border-color);font-size:0.9rem;vertical-align:top;}
tr:hover td{background:rgba(255,255,255,0.02);}
:not(pre)>code{font-family:'JetBrains Mono',monospace;font-size:max(0.75rem,0.85em);background:rgba(59,130,246,0.12);padding:0.15rem 0.4rem;border-radius:0.3rem;color:#93c5fd;display:inline;overflow-wrap:break-word;word-break:break-all;white-space:pre-wrap;border:1px solid rgba(59,130,246,0.15);line-height:1;vertical-align:baseline;}
pre code.hljs{display:block;overflow-x:auto;padding:1em;}
.hljs{color:#abb2bf;background:transparent;}
.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic;}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd;}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75;}
.hljs-literal{color:#56b6c2;}
.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379;}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66;}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee;}
.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b;}
.hljs-emphasis{font-style:italic;}
.hljs-strong{font-weight:700;}
.badge{display:inline-flex;align-items:center;padding:0.2rem 0.6rem;border-radius:0.375rem;font-size:0.75rem;font-weight:700;}
.badge-blue{background:rgba(59,130,246,0.15);color:#93c5fd;}
.badge-green{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.badge-red{background:rgba(239,68,68,0.15);color:#fca5a5;}
.badge-yellow{background:rgba(245,158,11,0.15);color:#fcd34d;}
.badge-purple{background:rgba(139,92,246,0.15);color:#c4b5fd;}
.comparison-grid{display:grid;grid-template-columns:1fr auto 1fr;gap:1rem;align-items:start;}
.comparison-panel{border-radius:0.75rem;overflow:hidden;border:1px solid;padding-bottom:1rem;}
.comparison-panel>.macos-body,.comparison-panel>div:not(.comparison-header){padding-left:1.25rem;padding-right:1.25rem;}
.comparison-panel.bad{border-color:rgba(239,68,68,0.3);}
.comparison-panel.good{border-color:rgba(16,185,129,0.3);}
.comparison-header{padding:1rem 1.5rem;font-weight:700;display:flex;align-items:center;gap:0.5rem;}
.comparison-panel.bad .comparison-header{background:rgba(239,68,68,0.15);color:#fca5a5;}
.comparison-panel.good .comparison-header{background:rgba(16,185,129,0.15);color:#6ee7b7;}
.vs-badge{width:3rem;height:3rem;border-radius:50%;background:linear-gradient(135deg,#ef4444,#3b82f6);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:0.875rem;align-self:center;justify-self:center;box-shadow:0 0 20px rgba(59,130,246,0.4);flex-shrink:0;margin-top:3rem;}
@media(max-width:900px){.comparison-grid{grid-template-columns:1fr;}.vs-badge{margin-top:0.5rem;margin-bottom:0.5rem;}}
.qa-item{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.qa-header{padding:1.25rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:flex-start;gap:1rem;transition:background 0.2s;}
.qa-header:hover{background:rgba(255,255,255,0.03);}
.qa-question{font-weight:700;font-size:1rem;color:var(--text-primary);}
.qa-meta{font-size:0.8rem;color:var(--text-muted);margin-top:0.25rem;}
.qa-chevron{color:var(--text-muted);transition:transform 0.3s;flex-shrink:0;margin-top:0.25rem;}
.qa-item.active .qa-chevron{transform:rotate(180deg);}
.qa-body{max-height:0;overflow:hidden;transition:max-height 0.5s ease;}
.qa-item.active .qa-body{max-height:6000px;}
.qa-content{padding:0 1.5rem 1.5rem;}
.qa-think{background:rgba(139,92,246,0.08);border-left:3px solid var(--accent-purple);border-radius:0.5rem;padding:1rem 1.25rem;margin-bottom:1rem;font-style:italic;font-size:0.95rem;color:#c4b5fd;}
.qa-think strong{color:var(--accent-purple);font-style:normal;}
.qa-great{background:rgba(16,185,129,0.08);border-left:3px solid var(--accent-green);border-radius:0.5rem;padding:1rem 1.25rem;margin-top:1rem;font-size:0.95rem;color:#6ee7b7;}
.qa-great strong{color:var(--accent-green);}
.collapsible{border:1px solid var(--border-color);border-radius:0.75rem;margin-bottom:0.75rem;overflow:hidden;}
.collapsible-header{padding:1rem 1.5rem;cursor:pointer;user-select:none;display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,0.02);transition:background 0.2s;}
.collapsible-header:hover{background:rgba(255,255,255,0.05);}
.collapsible-chevron{color:var(--text-muted);transition:transform 0.3s;}
.collapsible.active .collapsible-chevron{transform:rotate(180deg);}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height 0.4s ease;}
.collapsible.active .collapsible-content{max-height:10000px;}
.collapsible-body{padding:1.5rem;border-top:1px solid var(--border-color);}
ul.styled{list-style:none;padding:0;}
ul.styled li{padding:0.5rem 0 0.5rem 1.5rem;position:relative;color:var(--text-secondary);font-size:0.95rem;border-bottom:1px solid rgba(255,255,255,0.04);}
ul.styled li:last-child{border-bottom:none;}
ul.styled li::before{content:'â–¸';position:absolute;left:0;color:var(--accent-blue);font-size:0.8rem;top:0.6rem;}
ul.styled.green li::before{color:var(--accent-green);}
ul.styled.red li::before{color:var(--accent-red);content:'âœ—';}
.tab-container{background:var(--glass-bg);border:1px solid var(--glass-border);border-radius:0.75rem;overflow:hidden;margin-bottom:1.5rem;}
.tab-header{display:flex;background:rgba(0,0,0,0.2);border-bottom:1px solid var(--border-color);overflow-x:auto;}
.tab-btn{padding:0.75rem 1.25rem;cursor:pointer;font-size:0.85rem;font-weight:600;color:var(--text-muted);border-bottom:2px solid transparent;white-space:nowrap;transition:color 0.2s,border-color 0.2s;background:none;border-top:none;border-left:none;border-right:none;}
.tab-btn.active{color:var(--accent-blue);border-bottom-color:var(--accent-blue);}
.tab-btn:hover{color:var(--text-primary);}
.tab-panel{display:none;padding:1.5rem;}
.tab-panel.active{display:block;}
.cheat-card{background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:0.75rem;padding:1.25rem;transition:border-color 0.2s,transform 0.2s;min-width:0;overflow:hidden;}
.cheat-card pre{overflow-x:auto;}
.cheat-card:hover{border-color:var(--accent-blue);}
.cheat-card-title{font-size:0.8rem;font-weight:700;text-transform:uppercase;letter-spacing:0.05em;color:var(--text-muted);margin-bottom:0.75rem;}
.cheat-card-body{font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:#a5f3fc;line-height:1.5;}
.footer{text-align:center;padding:3rem 2rem;color:var(--text-muted);border-top:1px solid var(--border-color);margin-top:4rem;font-size:0.875rem;}
.mermaid-container{background:rgba(15,23,42,0.95);border:1px solid rgba(59,130,246,0.3);border-radius:12px;padding:2rem 1.5rem;margin:1rem 0;overflow:auto;overscroll-behavior:contain;-webkit-overflow-scrolling:touch;box-shadow:0 0 20px rgba(59,130,246,0.08);max-height:60vh;max-width:100%;touch-action:pan-x pan-y;position:relative;}
.diagram-zoom-controls{position:absolute;top:0.5rem;right:0.5rem;display:flex;gap:0.25rem;z-index:5;}
.diagram-zoom-btn{width:30px;height:30px;border-radius:50%;border:1px solid rgba(59,130,246,0.3);background:rgba(15,23,42,0.9);color:#93c5fd;font-size:0.75rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s;-webkit-tap-highlight-color:transparent;}
.diagram-zoom-btn:hover{background:rgba(59,130,246,0.2);color:#fff;}
.mermaid-container .mermaid{display:flex;justify-content:center;min-width:fit-content;}
.mermaid-container .mermaid svg{height:auto;}
.diagram-hint{display:none;position:absolute;bottom:0.5rem;right:0.75rem;font-size:0.6875rem;color:var(--text-muted);background:rgba(15,23,42,0.85);padding:0.2rem 0.5rem;border-radius:4px;pointer-events:none;}
.diagram-toggle{display:flex;align-items:center;gap:0.5rem;padding:0.6rem 1rem;margin:0.75rem 0;background:rgba(59,130,246,0.08);border:1px solid rgba(59,130,246,0.2);border-radius:0.5rem;cursor:pointer;color:#93c5fd;font-size:0.875rem;font-weight:600;user-select:none;-webkit-tap-highlight-color:transparent;transition:background-color 0.2s,border-color 0.2s;min-height:44px;}
.diagram-toggle:hover{background:rgba(59,130,246,0.15);border-color:var(--accent-blue);}
.diagram-toggle .chevron{font-size:0.7rem;transition:transform 0.3s;margin-left:auto;color:var(--text-muted);}
.diagram-toggle.open .chevron{transform:rotate(180deg);}
.mermaid-container.collapsed{max-height:0;overflow:hidden;padding:0;margin:0;border:none;box-shadow:none;}
.mermaid .classGroup rect{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid .classGroup .label{fill:#f1f5f9!important;font-weight:600!important;}
.mermaid .classLabel .label{fill:#93c5fd!important;}
.mermaid .classTitle{font-weight:700!important;fill:#60a5fa!important;font-size:16px!important;}
.mermaid .classTitleText{fill:#60a5fa!important;font-size:16px!important;font-weight:700!important;}
.mermaid .relation{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .cardinality{fill:#94a3b8!important;}
.mermaid defs marker path{fill:#60a5fa!important;stroke:#60a5fa!important;}
.mermaid .actor-line{stroke:#3b82f6!important;stroke-width:2px!important;stroke-dasharray:4;}
.mermaid .actor{fill:#1e3a5f!important;stroke:#3b82f6!important;stroke-width:2px!important;}
.mermaid text.actor>tspan{fill:#e2e8f0!important;font-weight:600!important;}
.mermaid .messageLine0,.mermaid .messageLine1{stroke:#60a5fa!important;stroke-width:2px!important;}
.mermaid .messageText{fill:#f1f5f9!important;font-weight:500!important;}
.mermaid .note{fill:#2d1b4e!important;stroke:#8b5cf6!important;stroke-width:1.5px!important;}
.mermaid .noteText>tspan{fill:#e2e8f0!important;}
.mermaid .activation0,.mermaid .activation1,.mermaid .activation2{fill:#1e3a5f!important;stroke:#3b82f6!important;}
.mermaid .loopText>tspan{fill:#94a3b8!important;}
.mermaid .loopLine{stroke:#334155!important;}
.mermaid .nodeLabel{color:#f1f5f9!important;font-weight:500!important;}
.mermaid .edgeLabel{background:#1e293b!important;color:#94a3b8!important;}
.mermaid .label{color:#f1f5f9!important;}
h3.sub{font-size:1.1rem;font-weight:700;margin:1.5rem 0 0.75rem;color:var(--text-primary);}
p.body-text{color:var(--text-secondary);font-size:0.95rem;margin-bottom:0.75rem;}
.two-col{display:grid;grid-template-columns:1fr 1fr;gap:1.25rem;margin-top:1rem;}
@media(max-width:900px){.two-col{grid-template-columns:1fr;}}
.two-col pre{margin:0;background:#1a1a2e;border-radius:0 0 0.75rem 0.75rem;border:1px solid rgba(255,255,255,0.08);border-top:none;overflow-x:auto;}
.two-col pre code{display:block;font-family:'JetBrains Mono',monospace;font-size:0.8rem;line-height:1.6;padding:1rem 1.25rem;background:transparent!important;color:#e2e8f0;}
.two-col .callout{margin:0;border-radius:0.75rem 0.75rem 0 0;padding:0.6rem 1rem;}
@media(max-width:375px){
  .wiki-container{padding:0 0.5rem 1.5rem;}
  .qa-content{padding:0 0.75rem 0.75rem;}
}
@media(max-width:360px){
  .top-toolbar{padding:0.25rem 0.25rem;}
  .toolbar-left,.toolbar-right{gap:0.25rem;}
  .fab-btn{width:32px;height:32px;font-size:0.7rem;}
  .fab-back{width:32px;height:32px;margin-left:0.25rem;}
  .scroll-percent{min-width:1.75rem;font-size:0.6rem;}
}
@media(hover:hover){
  .fab-btn:hover{transform:scale(1.08);}
  .cheat-card:hover{transform:translateY(-2px);}
  .nav-panel a:hover{background:rgba(59,130,246,0.15);color:#fff;}
}
@media(prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:0.01ms!important;transition-duration:0.01ms!important;}html{scroll-behavior:auto;}}
</style>
</head>
<body>

<div class="hero">
  <div style="position:relative;z-index:1;">
    <div class="hero-badge"><i class="fa-solid fa-eye"></i> GoF Behavioral Pattern</div>
    <h1>Observer Design Pattern</h1>
    <p class="hero-subtitle">Don't call us, we'll call you â€” because polling is the architecture of desperation.</p>
    <div class="hero-meta">
      <span><i class="fa-solid fa-layer-group"></i> Behavioral Pattern</span>
      <span><i class="fa-brands fa-microsoft"></i> C# / .NET</span>
      <span><i class="fa-solid fa-list-check"></i> 25 Interview Q&amp;As</span>
      <span><i class="fa-solid fa-bug"></i> 3 Bug Case Studies</span>
      <span><i class="fa-solid fa-shield-halved"></i> 7 Pitfalls</span>
    </div>
  </div>
</div>

<div class="wiki-container">

<div class="top-toolbar">
  <div class="toolbar-left">
    <button class="fab-btn" id="navFab" title="Navigate sections"><i class="fa-solid fa-compass"></i></button>
    <button class="fab-btn" id="expandAllBtn" title="Expand all cards"><i class="fa-solid fa-angles-down"></i></button>
    <button class="fab-btn" id="fullscreenBtn" title="Toggle fullscreen"><i class="fa-solid fa-expand"></i></button>
  </div>
  <div class="toolbar-right">
    <button class="fab-btn" id="scrollUp" title="Scroll up"><i class="fa-solid fa-chevron-up"></i></button>
    <span class="scroll-percent" id="percentText">0%</span>
    <button class="fab-btn" id="scrollDown" title="Scroll down"><i class="fa-solid fa-chevron-down"></i></button>
    <a href="../index.html" class="fab-btn fab-back" title="Back to Pattern Playbook"><i class="fa-solid fa-arrow-left"></i></a>
  </div>
</div>
<div class="nav-panel" id="navPanel">
  <div class="nav-panel-title">Jump to Section</div>
  <a href="#s3"><i class="fa-solid fa-lightbulb"></i> Analogies</a>
  <a href="#s4"><i class="fa-solid fa-diagram-project"></i> Core Pattern</a>
  <a href="#s5"><i class="fa-solid fa-graduation-cap"></i> Jr vs Sr</a>
  <a href="#s6"><i class="fa-solid fa-code"></i> Implementations</a>
  <a href="#s10"><i class="fa-solid fa-bug"></i> Bug Studies</a>
  <a href="#s12"><i class="fa-solid fa-cubes"></i> SOLID</a>
  <a href="#s13"><i class="fa-solid fa-scale-balanced"></i> Comparisons</a>
  <a href="#s14"><i class="fa-solid fa-comments"></i> Interview Q&amp;As</a>
  <a href="#s15"><i class="fa-solid fa-compass-drafting"></i> When To Use</a>
  <a href="#s16"><i class="fa-solid fa-triangle-exclamation"></i> Pitfalls</a>
  <a href="#s18"><i class="fa-solid fa-bolt"></i> Cheat Sheet</a>
</div>

<!-- ============================================================ SECTION 3 -->
<section id="s3" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-lightbulb"></i></div>
    <div><div class="section-num">Section 3</div><h2 class="section-title">Real-World Analogies</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-brands fa-youtube" style="color:var(--accent-blue)"></i> YouTube Subscriptions â€” Deep Mapping</div>
    <p class="body-text">Think about how YouTube works. A YouTuber uploads a video. They don't personally call every subscriber to say "Hey, I posted a new video." Instead, YouTube automatically sends a notification to EVERYONE who subscribed to that channel. Subscribers can join or leave anytime â€” the YouTuber doesn't even notice. They just keep uploading, and YouTube handles the rest. Some subscribers watch immediately, some save it for later, some ignore it completely â€” the YouTuber doesn't care. That's exactly how the Observer pattern works.</p>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>YouTube World</th><th>What It Means in Code</th></tr></thead>
        <tbody>
          <tr><td><strong>The YouTuber's channel</strong> â€” uploads videos and has a subscriber list</td><td><strong>Subject (Observable)</strong> â€” holds state and a list of observers, notifies them when state changes</td></tr>
          <tr><td><strong>The Subscribe button</strong> â€” click it to start getting notifications</td><td><strong><code>Subscribe()</code> method</strong> â€” an observer registers itself with the subject</td></tr>
          <tr><td><strong>The Unsubscribe button</strong> â€” click it to stop getting notifications</td><td><strong><code>Unsubscribe()</code> method</strong> â€” an observer removes itself from the subject's list</td></tr>
          <tr><td><strong>YouTube sending notifications to all subscribers</strong> â€” automatic, one-to-many</td><td><strong><code>NotifyAll()</code> method</strong> â€” the subject loops through all observers and calls <code>Update()</code> on each</td></tr>
          <tr><td><strong>A subscriber who watches immediately</strong> â€” reacts to the notification their own way</td><td><strong>ConcreteObserver A</strong> (e.g., <code>AlertEngine</code>) â€” receives the update and does something specific with it</td></tr>
          <tr><td><strong>A subscriber who just adds to Watch Later</strong> â€” same notification, different reaction</td><td><strong>ConcreteObserver B</strong> (e.g., <code>AuditLogger</code>) â€” same <code>Update()</code> call, completely different behavior</td></tr>
        </tbody>
      </table>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-check-circle"></i> Why This Analogy Works</div>
      <ul class="styled green">
        <li><strong>The YouTuber doesn't know what each subscriber does with the video</strong> â€” the subject doesn't know what observers do with the data</li>
        <li><strong>Subscribers join and leave freely</strong> â€” observers register and unregister at runtime without changing the subject</li>
        <li><strong>One upload triggers millions of notifications</strong> â€” one state change notifies all observers automatically</li>
        <li><strong>The YouTuber keeps uploading whether they have 1 subscriber or 10 million</strong> â€” the subject works the same regardless of how many observers are attached</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-quote-left" style="color:var(--accent-purple)"></i> Six Quick Analogies</div>
    <div class="grid-2">
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-comments"></i> WhatsApp Group Chat</div>Someone sends a message in the group. Everyone in the group gets it instantly. You didn't send it to each person one by one â€” the group (subject) pushed it to all members (observers). Leave the group? You stop getting messages.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-fire"></i> Fire Alarm</div>Smoke detector detects smoke and sets off the alarm. Sprinklers turn on, fire doors close, elevators go to ground floor â€” all automatically. The detector just said "FIRE!" â€” it doesn't know about sprinklers or doors. Each system (observer) reacted on its own.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-heart"></i> Instagram Followers</div>You post a photo. All your followers see it in their feed. You didn't send it to each person â€” Instagram pushed it. Some like it, some comment, some scroll past. You (subject) posted once, many people (observers) reacted differently.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-bell"></i> School Bell</div>The bell rings. Students pack up, teachers end lectures, janitors start cleaning, cafeteria staff begin serving. One bell (event), many different reactions from many different people. The bell doesn't know about any of them.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-traffic-light"></i> Traffic Light</div>Light turns green. Car #1 goes straight, Car #2 turns left, pedestrians wait. One signal change (subject notification), each observer reacts based on their own situation. The traffic light doesn't know what each car is doing.</div>
      <div class="callout callout-info"><div class="callout-title"><i class="fa-solid fa-cloud-bolt"></i> Weather Alert on Your Phone</div>Government issues a tornado warning. TV shows it, radio broadcasts it, phones buzz, sirens sound. One warning (event), many systems react. Adding smart speakers as a new alert channel doesn't change the warning system.</div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-briefcase" style="color:var(--accent-green)"></i> Six Real-World Use Cases</div>
    <div class="grid-2">
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(59,130,246,0.04);">
        <div style="font-weight:700;color:var(--accent-blue);margin-bottom:0.4rem;"><i class="fa-solid fa-futbol"></i> 1. Live Sports Scores</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">When a goal is scored, the score app, fantasy league, betting site, and group chat bot all update at once. One event ("goal scored"), many systems react differently.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(139,92,246,0.04);">
        <div style="font-weight:700;color:var(--accent-purple);margin-bottom:0.4rem;"><i class="fa-solid fa-shopping-cart"></i> 2. Online Shopping Order</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">When you place an order, inventory decreases, confirmation email sends, analytics logs it, and loyalty points get added. The order system doesn't know about any of these â€” they're all observers.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(16,185,129,0.04);">
        <div style="font-weight:700;color:var(--accent-green);margin-bottom:0.4rem;"><i class="fa-solid fa-comments"></i> 3. Chat Messages</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">When a message arrives in a chat room, the mention notifier pings users, the unread counter updates badges, and the audit logger records it. One message, three different reactions.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(6,182,212,0.04);">
        <div style="font-weight:700;color:var(--accent-cyan);margin-bottom:0.4rem;"><i class="fa-solid fa-message"></i> 4. Chat App (like Slack)</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">When someone posts in a channel, everyone in that channel gets the message. Join the channel = subscribe. Leave = unsubscribe. The poster doesn't know who's listening.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(245,158,11,0.04);">
        <div style="font-weight:700;color:var(--accent-yellow);margin-bottom:0.4rem;"><i class="fa-solid fa-house-signal"></i> 5. Smart Home Sensors</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">Motion detected at night: camera starts recording, lights turn on, phone gets a notification. One sensor event, three different devices react independently.</p>
      </div>
      <div style="padding:0.75rem;border:1px solid var(--border-color);border-radius:0.5rem;background:rgba(239,68,68,0.04);">
        <div style="font-weight:700;color:var(--accent-red);margin-bottom:0.4rem;"><i class="fa-solid fa-gear"></i> 6. Config File Changes</div>
        <p style="font-size:0.85rem;color:var(--text-secondary);">When a settings file changes, the rate limiter adjusts, feature flags toggle, and log level updates â€” all without restarting the app. One config change triggers many reactions.</p>
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 4 -->
<section id="s4" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-diagram-project"></i></div>
    <div><div class="section-num">Section 4</div><h2 class="section-title">Core Pattern &amp; UML</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-book" style="color:var(--accent-purple)"></i> GoF Formal Definition</div>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-quote-left"></i> Gang of Four (1994)</div>
      <strong>Observer</strong> â€” Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
    </div>
    <p class="body-text"><strong>Intent:</strong> Establish a subscription mechanism that allows multiple objects (observers) to listen for and react to events or state changes occurring in another object (the subject), without the subject having any direct knowledge of the observers' concrete types or behavior.</p>
    <h3 class="sub">Key Forces at Play</h3>
    <ul class="styled">
      <li>A single state change in one object must trigger reactions in many other objects â€” and you don't know at compile time how many or which ones</li>
      <li>The subject must NOT depend on the concrete types of its observers â€” otherwise every new observer requires modifying the subject, violating OCP</li>
      <li>Observers must be able to subscribe and unsubscribe dynamically at runtime â€” the set of interested parties changes as the system runs</li>
      <li>Polling (repeatedly asking "has anything changed?") wastes CPU, creates network traffic, introduces latency, and doesn't scale</li>
      <li>The subject should be reusable across different contexts â€” a chat room service should work with zero observers or a thousand</li>
    </ul>
    <h3 class="sub">Why This Is Behavioral</h3>
    <p class="body-text">Observer is behavioral because it defines a <strong>communication protocol</strong> between objects. It doesn't control how objects are created (creational) or how they're composed (structural). It governs how objects <strong>interact at runtime</strong> â€” specifically, how a change in one object propagates to others through a well-defined notification mechanism.</p>
    <h3 class="sub">Push vs Pull vs Hybrid Model</h3>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Model</th><th>How It Works</th><th>Pros</th><th>Cons</th></tr></thead>
        <tbody>
          <tr><td><span class="badge badge-blue">Push</span></td><td>Subject sends complete state change data in the <code>Update()</code> call</td><td>Observers get everything in one shot</td><td>Observers may receive data they don't care about; <code>Update()</code> signature must accommodate all shapes</td></tr>
          <tr><td><span class="badge badge-yellow">Pull</span></td><td>Subject sends minimal notification ("something changed"); observers query back</td><td>Observers only fetch what they care about</td><td>Observers need reference back to subject; redundant queries from multiple observers</td></tr>
          <tr><td><span class="badge badge-green">Hybrid</span></td><td>Subject pushes a strongly-typed event object containing change data</td><td>Type-safe, observers get exactly what's relevant</td><td>Slightly more ceremony than raw events</td></tr>
        </tbody>
      </table>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-star"></i> Production Recommendation</div>
      Use the <strong>Hybrid model</strong>. This is what .NET's <code>event</code> system, MediatR, and all modern event-driven systems use. Strongly-typed event objects give you type safety, self-documenting APIs, and clean observer signatures.
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-sitemap" style="color:var(--accent-blue)"></i> UML Class Diagram â€” Generic Observer</div>
    <h3>Class Diagram</h3>
    <div class="mermaid-container">
      <span class="diagram-hint">Scroll or pinch to zoom</span>
      <div class="mermaid">
classDiagram
    class ISubject_T {
        &lt;&lt;interface&gt;&gt;
        +Subscribe(observer IObserver_T) IDisposable
        +Unsubscribe(observer IObserver_T) void
        +NotifyObservers() void
    }
    class IObserver_T {
        &lt;&lt;interface&gt;&gt;
        +Update(data T) void
    }
    class ConcreteSubject {
        -_observers List~IObserver_T~
        -_state T
        -_lock ReaderWriterLockSlim
        +Subscribe(observer IObserver_T) IDisposable
        +Unsubscribe(observer IObserver_T) void
        +NotifyObservers() void
        +SetState(newState T) void
    }
    class ConcreteObserverA {
        -_state TA
        +Update(data T) void
    }
    class ConcreteObserverB {
        -_state TB
        +Update(data T) void
    }
    class ConcreteObserverC {
        -_state TC
        +Update(data T) void
    }
    ISubject_T <|.. ConcreteSubject : implements
    IObserver_T <|.. ConcreteObserverA : implements
    IObserver_T <|.. ConcreteObserverB : implements
    IObserver_T <|.. ConcreteObserverC : implements
    ConcreteSubject o-- IObserver_T : maintains list of
      </div>
    </div>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-key"></i> Key Design Notes</div>
      <ul class="styled">
        <li><code>ISubject</code> and <code>IObserver</code> are <strong>generic (T)</strong> â€” type-safe event data</li>
        <li><code>Subscribe()</code> returns <code>IDisposable</code> â€” enables <code>using</code> blocks for automatic cleanup</li>
        <li>Observer list is snapshot during notification â€” safe against concurrent modification</li>
        <li>Each observer handles its own exceptions â€” one crash doesn't cascade</li>
        <li>This is <strong>COMPOSITION</strong>: Subject "has-a" list of Observers, not "is-a" relationship</li>
      </ul>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-comments" style="color:var(--accent-green)"></i> UML Class Diagram â€” Chat App Domain</div>
    <h3>Domain Class Diagram</h3>
    <div class="mermaid-container">
      <span class="diagram-hint">Scroll or pinch to zoom</span>
      <div class="mermaid">
classDiagram
    class ChatRoomService {
        -_observers ConcurrentDictionary
        -_recentMessages ConcurrentDictionary
        -_logger ILogger
        -_metrics IMetricsCollector
        +Subscribe(observer) IDisposable
        +Unsubscribe(observerId) void
        +BroadcastMessageAsync(message) Task
        +GetRecentMessages(roomId) List~ChatMessage~
    }
    class IChatObserver {
        &lt;&lt;interface&gt;&gt;
        +ObserverId string
        +OnMessageReceivedAsync(message, ct) Task
        +MutedRoomIds IReadOnlySet~string~
    }
    class ChatMessage {
        +MessageId Guid
        +RoomId string
        +SenderId string
        +Content string
        +MentionedUserIds IReadOnlyList~string~
        +Timestamp DateTimeOffset
        +MessageType MessageType
    }
    class MentionNotifier {
        -_pushService IPushNotificationService
        -_userPrefs IUserPreferenceService
        +OnMessageReceivedAsync() Task
    }
    class UnreadCountTracker {
        -_counts ConcurrentDictionary
        -_hub IHubContext
        +OnMessageReceivedAsync() Task
    }
    class ChatAuditLogger {
        -_repository IAuditRepo
        -_buffer Channel~T~
        +OnMessageReceivedAsync() Task
    }
    class AutoModerationObserver {
        -_spamRules List~ISpamRule~
        -_moderationService IModerationService
        +OnMessageReceivedAsync() Task
    }
    ChatRoomService o-- IChatObserver : notifies 1..*
    ChatRoomService ..> ChatMessage : publishes
    IChatObserver <|.. MentionNotifier
    IChatObserver <|.. UnreadCountTracker
    IChatObserver <|.. ChatAuditLogger
    IChatObserver <|.. AutoModerationObserver
      </div>
    </div>
    <div class="callout callout-warning">
      <div class="callout-title"><i class="fa-solid fa-arrows-spin"></i> Data Flow</div>
      <ol style="color:var(--text-secondary);font-size:0.9rem;padding-left:1.25rem;">
        <li>User sends a message via WebSocket connection</li>
        <li>ChatRoomService parses it into a <code>ChatMessage</code></li>
        <li>ChatRoomService stores message in recent history (for pull model)</li>
        <li>ChatRoomService snapshots observer list</li>
        <li>For each observer: check <code>MutedRoomIds</code> filter â€” skip if room is muted</li>
        <li>If interested: call <code>OnMessageReceivedAsync(message, ct)</code></li>
        <li>Each observer processes independently and asynchronously</li>
        <li>Subject logs any observer failures but does NOT stop notification chain</li>
      </ol>
    </div>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-link"></i> See Section 6</div>
      The full Chat App implementation with all observer classes is in <strong>Section 6 â€” Core Implementations</strong>.
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-arrows-turn-right" style="color:var(--accent-cyan)"></i> Sequence Diagram â€” Notification Flow</div>
    <h3>Sequence Diagram</h3>
    <div class="mermaid-container">
      <span class="diagram-hint">Scroll or pinch to zoom</span>
      <div class="mermaid">
sequenceDiagram
    participant WS as WebSocket Client
    participant CRS as ChatRoomService
    participant MN as MentionNotifier
    participant UCT as UnreadCountTracker
    participant CAL as ChatAuditLogger
    participant AMO as AutoModerationObserver

    Note over CRS: System startup
    MN->>CRS: Subscribe(mentionNotifier)
    CRS-->>MN: IDisposable
    UCT->>CRS: Subscribe(unreadCountTracker)
    CRS-->>UCT: IDisposable
    CAL->>CRS: Subscribe(chatAuditLogger)
    CRS-->>CAL: IDisposable
    AMO->>CRS: Subscribe(autoModerationObserver)
    CRS-->>AMO: IDisposable

    Note over CRS: Runtime â€” normal message
    WS->>CRS: "Hey @alice, check this out!" in #general
    CRS->>CRS: Parse + Store + Snapshot

    par Task.WhenAll
        CRS->>MN: OnMessageReceivedAsync
        MN->>MN: @alice mentioned? YES â†’ push notification
        MN-->>CRS: CompletedTask
        CRS->>UCT: OnMessageReceivedAsync
        UCT->>UCT: Increment unread for #general members
        UCT-->>CRS: CompletedTask
        CRS->>CAL: OnMessageReceivedAsync
        CAL->>CAL: Buffer in Channel
        CAL-->>CRS: CompletedTask
        CRS->>AMO: OnMessageReceivedAsync
        AMO->>AMO: Spam rules match? No
        AMO-->>CRS: CompletedTask
    end

    Note over CRS: Spam message arrives
    WS->>CRS: "BUY NOW FREE CRYPTO!!!" in #general

    par Task.WhenAll
        CRS->>AMO: OnMessageReceivedAsync
        AMO->>AMO: Spam detected? YES
        AMO->>AMO: Flag + mute sender
        CRS->>CAL: OnMessageReceivedAsync
        CAL->>CAL: Log flagged message
    end

    AMO->>CRS: subscription.Dispose()
    Note over CRS: Next message â€” only 3 observers
      </div>
    </div>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-magnifying-glass"></i> Key Observations</div>
      <ul class="styled">
        <li><strong>Subscribe happens once, notifications happen many times</strong> â€” the subscription cost is amortized. This is why Observer beats polling: polling incurs cost on every check, even when nothing changed.</li>
        <li><strong>Parallel notification via <code>Task.WhenAll</code></strong> â€” slow observers (audit logger writing to disk) don't block fast observers (mention notifier doing in-memory comparison).</li>
        <li><strong>Dynamic unsubscription</strong> â€” AutoModerationObserver unsubscribes after flagging. Next cycle has one fewer observer. No code change, no restart.</li>
        <li><strong>Each observer's logic is completely independent</strong> â€” they share nothing except the event data. One message, many independent reactions.</li>
      </ul>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 5 -->
<section id="s5" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-graduation-cap"></i></div>
    <div><div class="section-num">Section 5</div><h2 class="section-title">Junior vs Senior Thinking</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-shopping-cart" style="color:var(--accent-yellow)"></i> Scenario A: Order Fulfillment Notifications</div>
    <p class="body-text"><strong>The Task:</strong> When a customer places an order, the system must do 5 things: (1) send a confirmation email, (2) tell the warehouse to start packing, (3) reduce stock count, (4) give the customer loyalty points, and (5) update the admin dashboard. The product manager says "next quarter we're also adding SMS notifications and fraud detection."</p>

    <div class="jr-sr-list">
      <!-- Junior Problem 1: Constructor Bloat -->
      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: Puts Everything in One Method</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">The junior passes 6 services (email, warehouse, inventory, loyalty, dashboard, repo) into <code>OrderService</code> and calls them one after another inside <code>PlaceOrderAsync()</code>. Each call is wrapped in its own try-catch that just prints to console. When SMS is needed next quarter, they plan to add a 7th service.</p>
          <ul class="styled red">
            <li><strong>SRP violation (Single Responsibility)</strong> â€” <code>PlaceOrderAsync()</code> is supposed to place an order, but it also sends emails, updates inventory, awards points, etc. That's 5 unrelated side effects tacked onto a method whose only real job is to create and save an order.</li>
            <li><strong>Constructor bloat</strong> â€” 6 constructor parameters today, 10 next quarter. Every new feature means another parameter. When a constructor keeps growing like this, it's a warning sign (called a "code smell") that the class is doing too many things.</li>
            <li><strong>Sequential execution</strong> â€” Each service call waits for the previous one to finish before starting. If email takes 2s and warehouse takes 3s, the customer waits 5+ seconds total. Even though we use <code>async/await</code>, the calls still happen one after another â€” <code>async</code> frees the server to handle other requests, but it doesn't make YOUR calls run at the same time.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: Fires an Event, Handlers React Independently</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;"><code>OrderService</code> only needs 2 things: <code>IOrderRepository</code> (to save the order) and <code>IDomainEventDispatcher</code> (to fire the event). It fires an <code>OrderPlacedEvent</code> and separate handler classes pick it up â€” email handler, warehouse handler, etc.</p>
            <ul class="styled green">
              <li><strong>Event-driven decoupling</strong> â€” each handler does ONE thing and is tested on its own â€” no need to set up 6 mocks.</li>
              <li><strong>Handler priority</strong> â€” handlers have a <code>Priority</code> number so inventory reserves stock first (priority 1), then email sends (priority 10). Order is controlled, not random.</li>
              <li><strong>Parallel dispatch</strong> â€” all handlers run at the same time via <code>Task.WhenAll</code> â€” total wait = slowest handler, not all added up.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Junior Problem 2: OCP Violation -->
      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: Edits the Same Method for Every New Feature</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">Every time a new notification is needed (SMS, fraud check, etc.), the junior opens <code>PlaceOrderAsync()</code> and adds more code. The method keeps growing â€” 100 lines, 200 lines... and every edit risks breaking the order placement itself.</p>
          <ul class="styled red">
            <li><strong>OCP violation (Open/Closed Principle)</strong> â€” Want SMS? You have to open and modify the same method that places orders. Code should be open for extension (add new behavior by writing new code) but closed for modification (never edit working code to add features).</li>
            <li><strong>Regression risk</strong> â€” Every time you touch this method to add a feature, you might accidentally break something that was already working and tested.</li>
            <li><strong>Temporal coupling</strong> â€” The customer can't get a response until ALL notifications finish. If the email provider is slow (3 seconds), the customer stares at a loading spinner for 3 extra seconds â€” even though the order itself was saved instantly. The response time is chained to the slowest side effect.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: Add New Features Without Touching Old Code</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;">The dispatcher automatically finds all handlers that are registered in your app's startup config (this is called Dependency Injection / DI â€” the framework creates and connects objects for you). <code>OrderService</code> never changes after it's written.</p>
            <ul class="styled green">
              <li><strong>Closed for modification</strong> â€” <code>OrderService</code> is written once and never modified again â€” zero risk of breaking it.</li>
              <li><strong>Open for extension</strong> â€” Adding SMS next quarter means one new file (<code>SmsNotificationHandler.cs</code>) and one DI registration line. <code>OrderService</code> is never opened again.</li>
              <li><strong>Independent error handling</strong> â€” if loyalty points fail, email still sends. Each handler decides its own failure policy â€” retry, skip, or escalate.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Junior Problem 3: Error Handling Nightmare -->
      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: Wraps Everything in Try-Catch and Hopes for the Best</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">Five separate try-catch blocks, each just printing the error to console with <code>Console.WriteLine</code>. No plan for what should happen when something fails. If loyalty points fail, should the order be cancelled? The code has no answer.</p>
          <ul class="styled red">
            <li><strong>No error isolation</strong> â€” all the extra tasks (email, warehouse, loyalty, etc.) run in the same method one after another. There's no way to say "if inventory fails, that's serious â€” abort. But if loyalty points fail, just log it and retry later." Every failure is handled the same way â€” catch and print.</li>
            <li><strong>No retry strategy</strong> â€” a temporary network glitch causes a permanent failure because there's no retry logic. Transient failures (short-lived issues like a brief network timeout) are just swallowed â€” there's no way to say "try again in 5 seconds."</li>
            <li><strong>Zero observability</strong> (the ability to see what your system is doing in production) â€” <code>Console.WriteLine</code> in a deployed service means errors vanish. No structured logs, no alerting, no metrics â€” when something breaks, you have no way to find out.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: Each Handler Handles Its Own Errors</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;">The <code>DomainEventDispatcher</code> runs each handler inside its own try-catch and logs errors properly using <code>ILogger</code>. If one handler crashes, the others still run normally.</p>
            <ul class="styled green">
              <li><strong>Fault isolation</strong> â€” one handler failing never stops the others. Email still sends even if loyalty points crash.</li>
              <li><strong>Retry-ready</strong> â€” failed handlers can be extended to retry automatically. For more reliable retry, you can pair this with a message queue (like Azure Service Bus) that saves failed messages and replays them later.</li>
              <li><strong>Per-handler resilience</strong> â€” each handler decides what to do when it fails â€” ignore the error, send an alert, or let the error propagate up. The dispatcher doesn't force a one-size-fits-all failure policy.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Junior Problem 4: Untestable -->
      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: Needs 6 Mocks Just to Test One Thing</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">Want to test if the confirmation email is correct? You still have to mock the warehouse, inventory, loyalty, and dashboard â€” even though they have nothing to do with email. 80% of the test setup is irrelevant noise.</p>
          <ul class="styled red">
            <li><strong>Testing complexity</strong> â€” Every single test needs 6 mocks, even if you only care about one thing. Most of the mocks are completely irrelevant to what you're testing.</li>
            <li><strong>Fragile tests</strong> â€” Adding SMS means every existing test now needs a 7th mock added to its setup. New features break old tests.</li>
            <li><strong>Compilation cascade</strong> â€” When the constructor signature changes (e.g., a new parameter added), every single test for <code>OrderService</code> fails to compile. The test suite becomes a maintenance burden.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: Each Handler Tested Alone with Just 1 Mock</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;">Testing the warehouse handler? Mock only <code>IWarehouseService</code>. Testing the email handler? Mock only <code>IEmailService</code>. Each handler is tested completely on its own â€” clean, simple, focused.</p>
            <ul class="styled green">
              <li><strong>Focused assertions</strong> â€” each test focuses on exactly one thing â€” no irrelevant setup code cluttering the test.</li>
              <li><strong>Additive testing</strong> â€” adding a new handler means adding a new test class. Old tests are never touched.</li>
              <li><strong>Separation of concerns</strong> â€” <code>OrderService</code> test just checks "was the event fired?" â€” it doesn't test what handlers do.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <h3 class="sub">Junior's Code â€” The Problem</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderService.cs â€” Junior (Tightly Coupled)</span></div>
      <div class="macos-body"><pre><code class="language-csharp">public class OrderService
{
    private readonly IOrderRepository _orderRepo;
    private readonly IEmailService _emailService;
    private readonly IWarehouseService _warehouseService;
    private readonly IInventoryService _inventoryService;
    private readonly ILoyaltyService _loyaltyService;
    private readonly IAdminDashboardHub _dashboardHub;
    // Next quarter: ISmsService, IFraudDetectionService...

    public OrderService(
        IOrderRepository orderRepo, IEmailService emailService,
        IWarehouseService warehouseService, IInventoryService inventoryService,
        ILoyaltyService loyaltyService, IAdminDashboardHub dashboardHub)
    {
        _orderRepo = orderRepo;
        _emailService = emailService;
        _warehouseService = warehouseService;
        _inventoryService = inventoryService;
        _loyaltyService = loyaltyService;
        _dashboardHub = dashboardHub;
    }

    public async Task&lt;OrderResult&gt; PlaceOrderAsync(PlaceOrderRequest request)
    {
        var order = new Order {
            Id = Guid.NewGuid(), CustomerId = request.CustomerId,
            Items = request.Items,
            Total = request.Items.Sum(i =&gt; i.Price * i.Quantity),
            CreatedAt = DateTimeOffset.UtcNow, Status = OrderStatus.Placed
        };
        await _orderRepo.SaveAsync(order);

        // ALL side effects jammed sequentially
        try { await _emailService.SendOrderConfirmationAsync(
                  order.CustomerId, order.Id, order.Total); }
        catch (Exception ex) { Console.WriteLine($"Email failed: {ex.Message}"); }

        try { await _warehouseService.NotifyNewOrderAsync(order.Id, order.Items); }
        catch (Exception ex) { Console.WriteLine($"Warehouse failed: {ex.Message}"); }

        try { foreach (var item in order.Items)
                  await _inventoryService.DecrementStockAsync(item.Sku, item.Quantity); }
        catch (Exception ex) { Console.WriteLine($"Inventory failed: {ex.Message}"); }

        try { await _loyaltyService.AwardPointsAsync(
                  order.CustomerId, (int)(order.Total * 10)); }
        catch (Exception ex) { Console.WriteLine($"Loyalty failed: {ex.Message}"); }

        try { await _dashboardHub.Clients.All.SendAsync(
                  "OrderPlaced", new { order.Id, order.Total }); }
        catch (Exception ex) { Console.WriteLine($"Dashboard failed: {ex.Message}"); }

        // Method grows with every new requirement...
        return new OrderResult(order.Id, order.Status);
    }
}</code></pre></div>
    </div>

    <h3 class="sub">Senior's Code â€” The Solution</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderService.cs â€” Senior (Observer Pattern)</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// â”€â”€â”€ Domain Event (the contract) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed record OrderPlacedEvent(
    Guid OrderId, Guid CustomerId,
    IReadOnlyList&lt;OrderItem&gt; Items,
    decimal Total, DateTimeOffset PlacedAt);

// â”€â”€â”€ Observer Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public interface IDomainEventHandler&lt;in TEvent&gt; where TEvent : class
{
    int Priority =&gt; 0;  // Lower = runs first
    Task HandleAsync(TEvent domainEvent, CancellationToken ct);
}

// â”€â”€â”€ Dispatcher (Subject) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class DomainEventDispatcher : IDomainEventDispatcher
{
    private readonly IServiceProvider _sp;
    private readonly ILogger&lt;DomainEventDispatcher&gt; _logger;

    public async Task DispatchAsync&lt;TEvent&gt;(TEvent domainEvent,
        CancellationToken ct = default) where TEvent : class
    {
        var handlers = _sp.GetServices&lt;IDomainEventHandler&lt;TEvent&gt;&gt;()
            .OrderBy(h =&gt; h.Priority).ToList();

        var tasks = handlers.Select(async handler =&gt; {
            try { await handler.HandleAsync(domainEvent, ct); }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                _logger.LogError(ex, "Handler {Handler} failed",
                    handler.GetType().Name);
            }
        });
        await Task.WhenAll(tasks);
    }
}

// â”€â”€â”€ Clean OrderService (TWO dependencies, not six) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class OrderService
{
    private readonly IOrderRepository _orderRepo;
    private readonly IDomainEventDispatcher _dispatcher;

    public async Task&lt;OrderResult&gt; PlaceOrderAsync(
        PlaceOrderRequest request, CancellationToken ct = default)
    {
        var order = new Order { /* ... */ };
        await _orderRepo.SaveAsync(order, ct);

        // Publish event â€” OrderService doesn't know WHO listens
        await _dispatcher.DispatchAsync(new OrderPlacedEvent(
            order.Id, order.CustomerId, order.Items,
            order.Total, order.CreatedAt), ct);

        return new OrderResult(order.Id, order.Status);
    }
}

// â”€â”€â”€ Independent Handlers (each is an Observer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class InventoryReservationHandler
    : IDomainEventHandler&lt;OrderPlacedEvent&gt;
{
    public int Priority =&gt; 1; // Highest â€” reserve stock first
    private readonly IInventoryService _inventoryService;

    public async Task HandleAsync(OrderPlacedEvent evt, CancellationToken ct)
    {
        foreach (var item in evt.Items)
            await _inventoryService.ReserveStockAsync(
                item.Sku, item.Quantity, evt.OrderId, ct);
    }
}

public sealed class OrderConfirmationEmailHandler
    : IDomainEventHandler&lt;OrderPlacedEvent&gt;
{
    public int Priority =&gt; 10;
    private readonly IEmailService _emailService;

    public async Task HandleAsync(OrderPlacedEvent evt, CancellationToken ct)
    {
        await _emailService.SendOrderConfirmationAsync(
            evt.CustomerId, evt.OrderId, evt.Total, ct);
    }
}

// DI: Adding SMS = one new class + one line. Zero changes elsewhere.
services.AddScoped&lt;IDomainEventHandler&lt;OrderPlacedEvent&gt;,
    InventoryReservationHandler&gt;();
services.AddScoped&lt;IDomainEventHandler&lt;OrderPlacedEvent&gt;,
    OrderConfirmationEmailHandler&gt;();
// services.AddScoped&lt;...., SmsNotificationHandler&gt;(); // Next quarter</code></pre></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-temperature-high" style="color:var(--accent-cyan)"></i> Scenario B: IoT Sensor Data Processing</div>
    <p class="body-text"><strong>The Task:</strong> A factory has hundreds of temperature sensors. Every second, each sensor sends a reading. The system must: (1) save the reading to a database, (2) check if the temperature is dangerously high, (3) show it live on a dashboard, (4) send it to an ML model. Next month, they're adding vibration and pressure sensors too.</p>

    <div class="jr-sr-list">
      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: Keeps Asking Every Sensor "Any Update?"</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">Creates a background service with a timer that asks each sensor for its reading every second using HTTP calls, one after another. Then processes the result through all 4 systems inline.</p>
          <ul class="styled red">
            <li><strong>Polling overhead</strong> â€” 500 sensors polled every second = 500 HTTP calls/sec whether or not any reading has changed. You pay the full network and CPU cost on every cycle, even for sensors that are completely idle.</li>
            <li><strong>Detection lag</strong> â€” If a temperature spike occurs right after a poll completes, the system won't notice until the next poll cycle â€” up to 1 full second later. In a factory, that delay is dangerous.</li>
            <li><strong>Sequential blocking</strong> â€” Asking 500 sensors one by one, 200ms each = 100 seconds to finish one round. The goal was 1 second. It's 100x too slow.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: Sensors Push Data, Observers React Instantly</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;">Instead of asking sensors, let sensors TELL the system when something changes. Think of it like notifications on your phone â€” you don't keep refreshing, the app tells you. This is done using MQTT (a lightweight messaging system built for IoT devices) or SignalR (for web dashboards). A <code>SensorDataHub</code> receives the data and notifies all registered observers.</p>
            <ul class="styled green">
              <li><strong>Zero latency</strong> â€” the moment a sensor pushes data, the alarm triggers immediately. No polling delay, no waiting for the next cycle.</li>
              <li><strong>Subject-side filtering</strong> â€” each observer declares which sensor types it cares about via <code>InterestedSensorTypes</code>. It's never invoked for irrelevant data.</li>
              <li><strong>Parallel execution</strong> â€” all observers run at the same time via <code>Task.WhenAll</code>. Total time = slowest observer, not all added up.</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="jr-sr-item">
        <div class="callout callout-danger">
          <div class="callout-title"><i class="fa-solid fa-user"></i> Junior: One Giant Class Does Everything</div>
          <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;">When vibration sensors are added, the junior adds new if-else branches, new thresholds, and new ML model calls â€” all inside the same <code>SensorPollingService</code>. It grows into a 500+ line monster class that handles everything.</p>
          <ul class="styled red">
            <li><strong>God class anti-pattern</strong> â€” Database writes, alarm checks, dashboard updates, and ML processing all crammed into one <code>ExecuteAsync</code> method. One class that knows and does everything is called a "god class" â€” it has way too many responsibilities (SRP violation from Scenario A), and changing anything in it risks breaking everything else.</li>
            <li><strong>Timer drift</strong> â€” Processing takes 800ms, then it waits another 1000ms. That's 1800ms between cycles instead of the intended 1000ms. The polling rate is consistently off â€” you never achieve the real-time monitoring the spec requires.</li>
            <li><strong>Single point of failure</strong> â€” If one sensor times out, every sensor after it in the queue never gets checked in that round. One failure kills the entire polling cycle.</li>
          </ul>
        </div>
        <div class="sr-toggle" onclick="toggleSrSolution(this)"><i class="fa-solid fa-wand-magic-sparkles"></i> How Senior Solves This</div>
        <div class="sr-solution-wrap">
          <div class="sr-solution">
            <div style="font-weight:700;color:#6ee7b7;margin-bottom:0.5rem;"><i class="fa-solid fa-check-circle"></i> Senior: New Sensor Type = Just Add a New Observer Class</div>
            <p style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.75rem;">All sensor readings use the same <code>SensorReadingEvent</code> format (with a sensor type field). Each observer declares which types it cares about. Adding vibration sensors = create a <code>VibrationAnalysisObserver</code> class and register it. Nothing else changes.</p>
            <ul class="styled green">
              <li><strong>Independent testability</strong> â€” each observer tested with just ONE mock â€” clean, focused unit tests.</li>
              <li><strong>Fault isolation</strong> â€” if the ML model crashes, the safety alarm still works. In a safety-critical factory environment, this independence is essential.</li>
              <li><strong>OCP compliance</strong> â€” adding vibration or pressure sensors next month means writing one new observer class and registering it. The hub and all existing observers remain untouched.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <h3 class="sub">Junior's Code â€” Polling Approach</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SensorPollingService.cs â€” Junior (Polling)</span></div>
      <div class="macos-body"><pre><code class="language-csharp">public class SensorPollingService : BackgroundService
{
    private readonly HttpClient _httpClient;
    private readonly ITimeSeriesDb _tsDb;
    private readonly IAlarmService _alarmService;
    private readonly IDashboardHub _dashboardHub;
    private readonly IMlModelService _mlService;
    private readonly List&lt;string&gt; _sensorEndpoints;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            foreach (var endpoint in _sensorEndpoints)
            {
                try
                {
                    // Sequential HTTP â€” 100 sensors Ã— 200ms = 20s cycle!
                    var response = await _httpClient.GetAsync(endpoint, stoppingToken);
                    var reading = await response.Content
                        .ReadFromJsonAsync&lt;SensorReading&gt;(
                            cancellationToken: stoppingToken);

                    if (reading is null) continue;

                    // All processing inline â€” blocks everything
                    await _tsDb.WriteAsync(reading);

                    if (reading.Temperature &gt; 85.0)
                        await _alarmService.TriggerAsync(reading.SensorId,
                            $"Temperature {reading.Temperature}Â°C exceeds threshold");

                    await _dashboardHub.Clients.All.SendAsync(
                        "SensorUpdate", reading, stoppingToken);

                    await _mlService.FeedReadingAsync(reading);
                    // Adding vibration sensors = ALL changes HERE
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Sensor {endpoint} failed: {ex.Message}");
                }
            }
            await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);
        }
    }
}</code></pre></div>
    </div>

    <h3 class="sub">Senior's Code â€” Push-Based Observer</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SensorDataHub.cs â€” Senior (Observer Pattern)</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// â”€â”€â”€ Generic Event â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed record SensorReadingEvent(
    string SensorId, string SensorType, string Location,
    double Value, string Unit, DateTimeOffset Timestamp,
    CriticalityLevel Criticality);

// â”€â”€â”€ Observer Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public interface ISensorReadingObserver
{
    string ObserverId { get; }
    IReadOnlySet&lt;string&gt;? InterestedSensorTypes { get; } // null = all
    Task OnReadingReceivedAsync(SensorReadingEvent reading, CancellationToken ct);
}

// â”€â”€â”€ Subject: Sensor Data Hub â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class SensorDataHub
{
    private readonly ConcurrentDictionary&lt;string, ISensorReadingObserver&gt;
        _observers = new();
    private readonly ILogger&lt;SensorDataHub&gt; _logger;

    public async Task PublishReadingAsync(
        SensorReadingEvent reading, CancellationToken ct = default)
    {
        var relevant = _observers.Values
            .Where(o =&gt; o.InterestedSensorTypes is null
                || o.InterestedSensorTypes.Contains(reading.SensorType))
            .ToList();

        var tasks = relevant.Select(async observer =&gt; {
            try { await observer.OnReadingReceivedAsync(reading, ct); }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                _logger.LogError(ex, "Observer {Id} failed", observer.ObserverId);
            }
        });
        await Task.WhenAll(tasks);
    }
}

// â”€â”€â”€ Concrete Observers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public sealed class SafetyAlarmObserver : ISensorReadingObserver
{
    public string ObserverId =&gt; "safety-alarm";
    public IReadOnlySet&lt;string&gt;? InterestedSensorTypes =&gt;
        new HashSet&lt;string&gt; { "temperature", "pressure" }; // NOT vibration

    public async Task OnReadingReceivedAsync(
        SensorReadingEvent reading, CancellationToken ct)
    {
        var threshold = reading.SensorType switch {
            "temperature" =&gt; _thresholds.CurrentValue.MaxTemperature,
            "pressure" =&gt; _thresholds.CurrentValue.MaxPressure,
            _ =&gt; double.MaxValue
        };
        if (reading.Value &gt; threshold)
            await _alarmService.TriggerAsync(reading.SensorId,
                $"{reading.SensorType} {reading.Value}{reading.Unit} " +
                $"exceeds {threshold}{reading.Unit}", reading.Criticality, ct);
    }
}

// DI: Each observer independently registered
services.AddSingleton&lt;ISensorReadingObserver, TimeSeriesStorageObserver&gt;();
services.AddSingleton&lt;ISensorReadingObserver, SafetyAlarmObserver&gt;();
services.AddSingleton&lt;ISensorReadingObserver, DashboardPushObserver&gt;();
// Next month: services.AddSingleton&lt;..., VibrationAnalysisObserver&gt;();</code></pre></div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 6 -->
<section id="s6" class="section">
  <div class="section-header">
    <div class="section-icon cyan"><i class="fa-solid fa-code"></i></div>
    <div><div class="section-num">Section 6</div><h2 class="section-title">Core Implementations</h2></div>
  </div>

  <div class="callout callout-info" style="margin-bottom:1.5rem;">
    <div class="callout-title"><i class="fa-solid fa-comments"></i> Domain: Real-Time Chat Application</div>
    <p style="margin:0.5rem 0 0 0;">Think WhatsApp or Slack â€” a <strong>ChatRoom</strong> (subject) broadcasts every new message to all members (observers). Some members mute the chat, some are offline and get push notifications, some log everything for compliance. Each reacts to the same message differently â€” that's the Observer pattern.</p>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-file-code" style="color:var(--accent-blue)"></i> Observer Interface â€” IChatObserver</div>
    <p class="body-text">Every service that wants to react to new chat messages implements this interface. We build a custom one instead of <code>System.IObserver&lt;T&gt;</code> because we need three things the built-in can't do: <strong>async/await</strong> support, <strong>cancellation</strong> for graceful shutdown, and <strong>observer identity</strong> so the chat room can find and remove you in O(1) instead of scanning the entire list.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Abstractions/IChatObserver.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">namespace ChatApp.Abstractions;

public interface IChatObserver
{
    /// Think of this like a username â€” "message-renderer", "push-notifier".
    /// WHY? The chat room stores observers in a Dictionary&lt;string, IChatObserver&gt;.
    /// Without an ID, removing someone means scanning every member = O(n).
    /// With an ID, it's a dictionary lookup = O(1). In a room with 10,000
    /// members, that's the difference between instant and sluggish.
    string ObserverId { get; }

    /// Which rooms has this observer MUTED? null = listening to ALL rooms.
    /// Example: You mute the "random-memes" room but keep "project-alpha".
    /// The chat room checks this BEFORE calling OnMessageReceivedAsync â€”
    /// so muted observers don't even get woken up. Zero wasted work.
    /// WHY IReadOnlySet? Because .Contains() on a HashSet is O(1).
    /// A List would be O(n) â€” checked on EVERY message in EVERY room.
    IReadOnlySet&lt;string&gt;? MutedRoomIds { get; }

    /// Called by the chat room every time someone sends a message.
    ///
    /// CONTRACT (the rules every observer MUST follow):
    /// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    /// â”‚ 1. BE IDEMPOTENT â€” if WiFi glitches and the room retries,  â”‚
    /// â”‚    you must not show the same message twice.                â”‚
    /// â”‚    (Use message.MessageId to detect duplicates.)            â”‚
    /// â”‚                                                             â”‚
    /// â”‚ 2. HANDLE YOUR OWN ERRORS â€” if you crash, the room catches â”‚
    /// â”‚    it, logs it, and moves on. Other observers still get     â”‚
    /// â”‚    the message. Your bug â‰  everyone else's problem.         â”‚
    /// â”‚                                                             â”‚
    /// â”‚ 3. BE FAST â€” the room notifies observers one by one.        â”‚
    /// â”‚    If you block for 5 seconds, the next observer waits 5s. â”‚
    /// â”‚    Heavy work? Enqueue it and return immediately.           â”‚
    /// â”‚                                                             â”‚
    /// â”‚ 4. RESPECT CANCELLATION â€” when the app shuts down, the     â”‚
    /// â”‚    CancellationToken fires. Stop what you're doing cleanly. â”‚
    /// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct);
}</code></pre></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-server" style="color:var(--accent-purple)"></i> Subject Interface â€” IChatRoom</div>
    <p class="body-text">The chat room is the <strong>subject</strong> â€” it knows who's listening and broadcasts every message. Two key design choices here: <code>Join()</code> returns an <code>IDisposable</code> (so you can't forget to leave â€” it auto-leaves when scope ends), and <code>GetRecentMessages()</code> lets new joiners catch up on what they missed (pull model).</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Abstractions/IChatRoom.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">namespace ChatApp.Abstractions;

public interface IChatRoom
{
    /// Join this chat room. Returns an IDisposable "membership card".
    ///
    /// WHY IDisposable? Think of it like a gym membership card:
    ///   using var membership = chatRoom.Join(myObserver);
    ///   // ... do stuff ...
    ///   // membership.Dispose() called automatically â†’ you leave the room
    ///
    /// Without this, the #1 Observer bug happens: you forget to call
    /// Leave(), the room keeps a reference to you, the GC can't collect
    /// you, and you have a memory leak. IDisposable makes leaving automatic.
    IDisposable Join(IChatObserver observer);

    /// Send a message to everyone in the room (push model).
    /// The room iterates over all observers and calls OnMessageReceivedAsync.
    /// Returns Task so the sender can optionally await delivery confirmation.
    Task SendMessageAsync(ChatMessage message, CancellationToken ct = default);

    /// PULL MODEL: Load recent messages for a room.
    /// Used when: (a) you just joined and need to see what you missed,
    /// (b) a REST API endpoint serves chat history,
    /// (c) an observer reconnects after being offline.
    /// Think of it like scrolling up in WhatsApp to see older messages.
    IReadOnlyList&lt;ChatMessage&gt; GetRecentMessages(string roomId, int count = 50);

    /// How many observers are in this room right now?
    /// Used for health checks and "5 members online" UI display.
    int MemberCount { get; }
}</code></pre></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-database" style="color:var(--accent-green)"></i> Event Data â€” ChatMessage</div>
    <p class="body-text">This is the data that flows from subject â†’ observers. It's a <strong>record</strong> (not a class) for three critical reasons: (1) <strong>immutability</strong> â€” once sent, nobody can tamper with what others see, (2) <strong>value equality</strong> â€” two messages with the same ID are considered duplicates, (3) <strong>with-expressions</strong> â€” easy to create modified copies without mutating the original.</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Models/ChatMessage.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">namespace ChatApp.Models;

/// Immutable record â€” once a message is sent, it CANNOT be changed.
/// Why does this matter? Because the chat room sends the SAME object
/// to every observer. If Observer A could mutate the message (e.g.,
/// change the content), Observer B would see the mutated version.
/// Records prevent this â€” all properties are init-only.
public sealed record ChatMessage
{
    /// Unique message ID â€” the backbone of idempotency.
    /// Scenario: Your WiFi drops, the app retries sending. The server
    /// receives the same message twice. Without MessageId, you'd see
    /// "Hello!" appear twice. With it, observers check "already processed
    /// this ID" and skip the duplicate.
    public required Guid MessageId { get; init; }

    /// Which room this message belongs to â€” "project-alpha", "random-memes"
    public required string RoomId { get; init; }

    /// Who sent it â€” "alice", "bob", "system" (for automated messages)
    public required string SenderId { get; init; }

    /// The actual message content
    public required string Content { get; init; }

    /// When it was sent â€” UTC so there's no timezone confusion.
    /// "3:00 PM" is ambiguous (whose timezone?). UTC is universal.
    public required DateTimeOffset Timestamp { get; init; }

    /// Message type â€” helps observers decide how to render/handle it
    public required MessageType Type { get; init; }
}

public enum MessageType
{
    Text,       // Regular chat message
    Image,      // Photo/image attachment
    System,     // "Alice joined the room", "Bob left"
    Reply       // Reply to another message
}</code></pre></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-heart-pulse" style="color:var(--accent-red)"></i> Concrete Subject â€” ChatRoomService</div>
    <p class="body-text">This is the <strong>heart</strong> of the Observer pattern â€” the class that ties everything together. It manages who's in the room, broadcasts messages to everyone, and handles the messy real-world problems: what if 50 people join/leave while a message is being delivered? What if one observer crashes? What if someone forgets to leave?</p>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Services/ChatRoomService.cs</span></div>
      <div class="macos-body"><pre><code class="language-csharp">using System.Collections.Concurrent;

namespace ChatApp.Services;

public sealed class ChatRoomService : IChatRoom, IDisposable
{
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MEMBER REGISTRY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHY ConcurrentDictionary instead of a regular Dictionary?
    //
    // Imagine a WhatsApp group with 500 members. At any moment:
    //   - Alice is sending a message (room is iterating over members)
    //   - Bob joins the room (room is adding to the member list)
    //   - Carol leaves the room (room is removing from the member list)
    //
    // With a regular Dictionary, these simultaneous operations CORRUPT
    // the internal data structure. ConcurrentDictionary handles this
    // safely â€” it uses fine-grained locks internally so all three
    // operations can happen at the same time without breaking anything.
    //
    // Key = ObserverId ("message-renderer", "push-notifier")
    // Value = The observer itself
    private readonly ConcurrentDictionary&lt;string, IChatObserver&gt;
        _members = new();

    // MESSAGE HISTORY for pull model (new joiners catch up)
    // Key = RoomId, Value = recent messages (bounded circular buffer)
    private readonly ConcurrentDictionary&lt;string, BoundedMessageBuffer&gt;
        _messageHistory = new();

    private readonly ILogger&lt;ChatRoomService&gt; _logger;

    public ChatRoomService(ILogger&lt;ChatRoomService&gt; logger) =&gt; _logger = logger;

    public int MemberCount =&gt; _members.Count;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // JOIN â€” Add an observer to this chat room
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    public IDisposable Join(IChatObserver observer)
    {
        ArgumentNullException.ThrowIfNull(observer);

        // TryAdd returns false if the ObserverId already exists.
        // This prevents the same service from joining twice â€” which
        // would cause it to receive every message TWICE.
        if (!_members.TryAdd(observer.ObserverId, observer))
            throw new InvalidOperationException(
                $"Observer '{observer.ObserverId}' is already in the room. " +
                "Each observer can only join once.");

        _logger.LogInformation(
            "'{Id}' joined the room (muted: {Muted}, total members: {Count})",
            observer.ObserverId,
            observer.MutedRoomIds is null ? "none"
                : string.Join(", ", observer.MutedRoomIds),
            _members.Count);

        // Return a "membership card" â€” an IDisposable that auto-removes
        // this observer when disposed. This is the secret sauce that
        // prevents the #1 Observer bug: forgetting to unsubscribe.
        //
        //   using var membership = chatRoom.Join(renderer);
        //   // ... renderer receives messages ...
        //   // scope ends â†’ membership.Dispose() â†’ renderer is removed
        //
        // Without this, the room holds a reference to the observer FOREVER,
        // the GC can never collect it, and you have a memory leak.
        return new Membership(this, observer.ObserverId);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEND MESSAGE â€” Notify all observers (push model)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    public async Task SendMessageAsync(
        ChatMessage message, CancellationToken ct = default)
    {
        // â‘  Store in history so new joiners can catch up later (pull model)
        var buffer = _messageHistory.GetOrAdd(
            message.RoomId, _ =&gt; new BoundedMessageBuffer(capacity: 200));
        buffer.Add(message);

        // â‘¡ SNAPSHOT + FILTER
        //
        // WHY snapshot? Imagine this scenario:
        //   - We start iterating over members to deliver the message
        //   - Halfway through, Bob joins the room
        //   - Without snapshot, the iterator might crash (collection modified)
        //     or deliver to Bob inconsistently
        //
        // .ToList() creates a COPY of the current member list. Now we
        // iterate over the copy while the original can safely change.
        //
        // The .Where() filter skips observers who MUTED this room.
        // If MutedRoomIds is null â†’ they haven't muted anything â†’ include them.
        // If MutedRoomIds exists but doesn't contain this room â†’ include them.
        // If MutedRoomIds contains this room â†’ skip them entirely.
        var recipients = _members.Values
            .Where(o =&gt; o.MutedRoomIds is null
                || !o.MutedRoomIds.Contains(message.RoomId))
            .ToList();

        if (recipients.Count == 0) return;

        // â‘¢ NOTIFY with per-observer exception isolation
        //
        // CRITICAL DESIGN DECISION: If the push notification service
        // crashes (maybe Firebase is down), should the message renderer
        // also fail to display the message? ABSOLUTELY NOT.
        //
        // Each observer runs in its own try-catch. One observer's failure
        // is logged but does NOT prevent others from receiving the message.
        // Your bug â‰  everyone else's problem.
        var tasks = recipients.Select(async observer =&gt;
        {
            try
            {
                await observer.OnMessageReceivedAsync(message, ct);
            }
            catch (OperationCanceledException)
            {
                // App is shutting down â€” this is expected, not an error
            }
            catch (Exception ex)
            {
                // Log the failure but keep going â€” other observers still
                // need their messages. Imagine if a broken audit logger
                // prevented all chat messages from being displayed!
                _logger.LogError(ex,
                    "Observer '{Id}' failed to process message {MsgId} in room '{Room}'",
                    observer.ObserverId, message.MessageId, message.RoomId);
            }
        });

        // Task.WhenAll runs ALL observer notifications concurrently.
        // If we have 5 observers, all 5 start processing at the same time
        // instead of waiting for each one to finish before starting the next.
        await Task.WhenAll(tasks);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GET RECENT MESSAGES â€” Pull model for catch-up
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Think: "I just joined the group. What did I miss?"
    // Like scrolling up in WhatsApp to see older messages.
    public IReadOnlyList&lt;ChatMessage&gt; GetRecentMessages(
        string roomId, int count = 50)
    {
        return _messageHistory.TryGetValue(roomId, out var buffer)
            ? buffer.GetRecent(count)
            : Array.Empty&lt;ChatMessage&gt;();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LEAVE â€” Internal, called by the Membership's Dispose()
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private void Leave(string observerId)
    {
        if (_members.TryRemove(observerId, out _))
            _logger.LogInformation(
                "'{Id}' left the room (remaining: {Count})",
                observerId, _members.Count);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MEMBERSHIP â€” The IDisposable "membership card"
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // This is a nested class because it's an implementation detail
    // of ChatRoomService â€” nobody outside needs to know about it.
    //
    // When you call membership.Dispose(), it calls chatRoom.Leave().
    // The Interlocked.Exchange trick ensures that calling Dispose()
    // twice doesn't try to leave twice (idempotent disposal).
    private sealed class Membership : IDisposable
    {
        private ChatRoomService? _room;
        private readonly string _observerId;

        public Membership(ChatRoomService room, string observerId)
        {
            _room = room;
            _observerId = observerId;
        }

        public void Dispose()
        {
            // Interlocked.Exchange atomically reads _room and sets it to null.
            // If _room was already null (Dispose called twice), this is a no-op.
            // If _room was set, it calls Leave() exactly once.
            // WHY? Without this, two threads calling Dispose() simultaneously
            // could both call Leave(), causing double-removal warnings.
            Interlocked.Exchange(ref _room, null)?.Leave(_observerId);
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BOUNDED MESSAGE BUFFER â€” Simple ring buffer for chat history
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    private sealed class BoundedMessageBuffer
    {
        private readonly ChatMessage[] _buffer;
        private int _index;
        private int _count;
        private readonly object _lock = new();

        public BoundedMessageBuffer(int capacity) =&gt;
            _buffer = new ChatMessage[capacity];

        public void Add(ChatMessage msg)
        {
            lock (_lock)
            {
                _buffer[_index] = msg;
                _index = (_index + 1) % _buffer.Length;
                if (_count &lt; _buffer.Length) _count++;
            }
        }

        public IReadOnlyList&lt;ChatMessage&gt; GetRecent(int count)
        {
            lock (_lock)
            {
                var take = Math.Min(count, _count);
                var result = new ChatMessage[take];
                var start = (_index - take + _buffer.Length) % _buffer.Length;
                for (var i = 0; i &lt; take; i++)
                    result[i] = _buffer[(start + i) % _buffer.Length];
                return result;
            }
        }
    }

    public void Dispose() =&gt; _members.Clear();
}</code></pre></div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-users" style="color:var(--accent-yellow)"></i> Concrete Observers â€” Two Independent Handlers</div>
    <p class="body-text">Both observers implement the same <code>IChatObserver</code> interface but react to messages in completely different ways. This is the core power of the Observer pattern â€” <strong>the chat room doesn't know or care what each observer does with the message</strong>. It just calls <code>OnMessageReceivedAsync()</code> and moves on.</p>

    <div class="tab-container">
      <div class="tab-header">
        <button class="tab-btn active" data-tab="renderer">MessageRenderer</button>
        <button class="tab-btn" data-tab="notifier">PushNotificationService</button>
      </div>
      <div class="tab-panel active" data-panel="renderer">
        <p class="body-text">The simplest possible observer â€” receives a message and pushes it to all connected browser/mobile clients via SignalR (real-time WebSocket connections). This is what makes your WhatsApp messages appear instantly without refreshing the page. No filtering, no batching â€” just immediate delivery.</p>
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Observers/MessageRenderer.cs</span></div>
          <div class="macos-body"><pre><code class="language-csharp">namespace ChatApp.Observers;

/// SIMPLEST OBSERVER â€” receives message, pushes to UI. That's it.
/// This is the purest form of the Observer pattern: react and forward.
public sealed class MessageRenderer : IChatObserver
{
    // Identity â€” the chat room uses this to find us in O(1)
    public string ObserverId =&gt; "message-renderer";

    // We don't mute anything â€” we render messages for ALL rooms.
    // null means "I'm interested in everything, don't filter me out."
    public IReadOnlySet&lt;string&gt;? MutedRoomIds =&gt; null;

    // SignalR hub â€” pushes real-time updates to connected browsers/apps.
    // Think of it as a pipe: message goes in here â†’ appears on user's screen.
    private readonly IHubContext&lt;ChatHub&gt; _hubContext;
    private readonly ILogger&lt;MessageRenderer&gt; _logger;

    public MessageRenderer(
        IHubContext&lt;ChatHub&gt; hubContext,
        ILogger&lt;MessageRenderer&gt; logger)
    {
        _hubContext = hubContext;
        _logger = logger;
    }

    public async Task OnMessageReceivedAsync(
        ChatMessage message, CancellationToken ct)
    {
        // Push to all connected clients in this room's SignalR group.
        // SignalR groups map 1:1 to chat rooms â€” only members of
        // "project-alpha" receive messages sent to "project-alpha".
        await _hubContext.Clients
            .Group(message.RoomId)
            .SendAsync("NewMessage", new
            {
                message.MessageId,
                message.RoomId,
                message.SenderId,
                message.Content,
                message.Type,
                Timestamp = message.Timestamp.ToString("HH:mm")
            }, ct);

        _logger.LogDebug(
            "Rendered message {MsgId} from '{Sender}' in room '{Room}'",
            message.MessageId, message.SenderId, message.RoomId);
    }
}</code></pre></div>
        </div>
      </div>
      <div class="tab-panel" data-panel="notifier">
        <p class="body-text">A more advanced observer that demonstrates <strong>filtering</strong> (skip muted rooms), <strong>batching</strong> (group multiple messages into a single "You have 3 new messages" notification instead of spamming), and <strong>idempotency</strong> (don't send duplicate push notifications if the server retries). Uses <code>Channel&lt;T&gt;</code> as a high-performance async queue â€” the notification handler just enqueues and returns instantly, while a background loop processes the queue in batches.</p>
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Observers/PushNotificationService.cs</span></div>
          <div class="macos-body"><pre><code class="language-csharp">using System.Threading.Channels;

namespace ChatApp.Observers;

/// ADVANCED OBSERVER â€” demonstrates filtering, batching, and idempotency.
/// This is the observer that sends "You have 3 new messages in project-alpha"
/// push notifications to your phone when you're not looking at the app.
public sealed class PushNotificationService : IChatObserver, IHostedService
{
    public string ObserverId =&gt; "push-notifier";

    // â”€â”€ FILTERING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Users can mute rooms. If "random-memes" is muted, this observer
    // tells the chat room: "don't even call me for that room."
    // The chat room checks MutedRoomIds BEFORE calling OnMessageReceivedAsync,
    // so muted rooms cause ZERO work for this observer. Efficient.
    //
    // In a real app, this would be loaded from a database per-user.
    // For this example, it's a simple in-memory set.
    private readonly HashSet&lt;string&gt; _mutedRooms = new();
    public IReadOnlySet&lt;string&gt;? MutedRoomIds =&gt;
        _mutedRooms.Count &gt; 0 ? _mutedRooms : null;

    // â”€â”€ BATCHING via Channel&lt;T&gt; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WHY NOT send push notifications immediately?
    //
    // Imagine a busy group chat: 20 messages in 10 seconds.
    // Sending 20 separate push notifications would:
    //   (a) Annoy the user â€” buzz buzz buzz buzz...
    //   (b) Get you rate-limited by Apple/Google push services
    //   (c) Drain the user's battery
    //
    // Instead, we ENQUEUE messages into a Channel&lt;T&gt; (a high-performance
    // async queue built into .NET) and a background loop processes them
    // every 3 seconds: "You have 5 new messages in project-alpha".
    //
    // Channel&lt;T&gt; vs Queue&lt;T&gt;?
    //   - Queue&lt;T&gt; is NOT thread-safe and has no async support
    //   - Channel&lt;T&gt; is thread-safe, async-native, and has backpressure
    //     (BoundedChannelOptions limits memory if messages pile up)
    private readonly Channel&lt;ChatMessage&gt; _notificationQueue =
        Channel.CreateBounded&lt;ChatMessage&gt;(
            new BoundedChannelOptions(10_000)
            {
                // If the queue is full (10K messages backed up), drop the
                // OLDEST message. Missing an old notification is better
                // than running out of memory.
                FullMode = BoundedChannelFullMode.DropOldest
            });

    // â”€â”€ IDEMPOTENCY tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // If WiFi glitches and the chat room retries delivering a message,
    // we don't want to send the same push notification twice.
    // This set tracks recently processed MessageIds.
    // ConcurrentDictionary instead of HashSet â€” HashSet is NOT thread-safe
    // OnMessageReceivedAsync runs via Task.WhenAll + background loop reads concurrently
    private readonly ConcurrentDictionary&lt;Guid, byte&gt; _processedIds = new();

    private readonly IPushProvider _pushProvider;
    private readonly ILogger&lt;PushNotificationService&gt; _logger;

    public PushNotificationService(
        IPushProvider pushProvider,
        ILogger&lt;PushNotificationService&gt; logger)
    {
        _pushProvider = pushProvider;
        _logger = logger;
    }

    // â”€â”€ OnMessageReceivedAsync â€” THE FAST PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // This is called by the chat room on EVERY message. It MUST be fast
    // because it blocks other observers. So we just enqueue and return.
    // Total time: ~microseconds (not milliseconds, not seconds).
    public Task OnMessageReceivedAsync(
        ChatMessage message, CancellationToken ct)
    {
        // Idempotency check: already processed this message?
        if (!_processedIds.TryAdd(message.MessageId, 0))
            return Task.CompletedTask; // Duplicate â€” skip silently

        // Enqueue for batched delivery. TryWrite is non-blocking.
        // If the queue is full, DropOldest kicks in automatically.
        _notificationQueue.Writer.TryWrite(message);
        return Task.CompletedTask;
    }

    // â”€â”€ Background batch processor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Runs as an IHostedService â€” starts when the app starts,
    // stops when the app shuts down.
    public Task StartAsync(CancellationToken ct)
    {
        _ = Task.Run(async () =&gt;
        {
            var batch = new List&lt;ChatMessage&gt;(100);

            while (!ct.IsCancellationRequested)
            {
                // Wait 3 seconds, then drain everything in the queue
                await Task.Delay(TimeSpan.FromSeconds(3), ct);

                while (_notificationQueue.Reader.TryRead(out var msg))
                    batch.Add(msg);

                if (batch.Count == 0) continue;

                // Group by room â†’ one notification per room
                // Instead of 5 separate notifications:
                //   "Alice: Hey" â†’ "Bob: What?" â†’ "Alice: NVM" â†’ ...
                // Send ONE:
                //   "5 new messages in project-alpha"
                // .ToList() materializes the grouping â€” prevents double-evaluation
                var grouped = batch.GroupBy(m =&gt; m.RoomId).ToList();
                foreach (var group in grouped)
                {
                    var count = group.Count();
                    var preview = group.Last(); // Show the latest message

                    await _pushProvider.SendAsync(new PushNotification
                    {
                        Title = $"{count} new message{(count &gt; 1 ? "s" : "")} in {group.Key}",
                        Body = $"{preview.SenderId}: {Truncate(preview.Content, 80)}",
                        RoomId = group.Key,
                        Badge = count
                    }, ct);
                }

                _logger.LogInformation(
                    "Sent {Count} batched push notifications for {Rooms} rooms",
                    batch.Count, grouped.Count);

                batch.Clear();

                // Trim old processed IDs to prevent unbounded memory growth.
                // Keep only the last 50K IDs â€” old messages won't be retried.
                if (_processedIds.Count &gt; 50_000)
                    _processedIds.Clear(); // Thread-safe clear â€” acceptable trade-off
            }
        }, ct);

        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken ct)
    {
        _notificationQueue.Writer.Complete();
        return Task.CompletedTask;
    }

    private static string Truncate(string text, int maxLength) =&gt;
        text.Length &lt;= maxLength ? text : text[..maxLength] + "...";
}</code></pre></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-plug" style="color:var(--accent-cyan)"></i> Wiring It All Together â€” DI Registration &amp; Pull Model API</div>
    <p class="body-text">Here's how all the pieces connect in a real ASP.NET Core application. The DI container creates the chat room and observers, a hosted service subscribes them at startup, and a REST API exposes the pull model for chat history.</p>
    <div class="two-col">
      <div>
        <div class="callout callout-info" style="margin:0;border-radius:0.75rem 0.75rem 0 0;padding:0.6rem 1rem;"><div class="callout-title"><i class="fa-solid fa-gear"></i> Program.cs â€” DI Setup</div></div>
        <pre style="margin:0;background:#1a1a2e;border-radius:0 0 0.75rem 0.75rem;border:1px solid rgba(255,255,255,0.08);border-top:none;"><code class="language-csharp" style="display:block;font-family:'JetBrains Mono',monospace;font-size:0.8rem;line-height:1.6;padding:1rem 1.25rem;background:transparent!important;color:#e2e8f0;">// â”€â”€ Subject â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Singleton = ONE chat room for the entire app.
// Every request, every controller, every service
// gets the SAME instance. This is important because
// the chat room holds the member list in memory â€”
// creating a new instance would lose all members.
builder.Services.AddSingleton&lt;IChatRoom,
    ChatRoomService&gt;();

// â”€â”€ Observers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each observer is also a Singleton â€” created once,
// lives forever, handles ALL messages. Registering
// them as IChatObserver lets us inject IEnumerable
// &lt;IChatObserver&gt; to get ALL observers at once.
builder.Services.AddSingleton&lt;IChatObserver,
    MessageRenderer&gt;();
builder.Services.AddSingleton&lt;IChatObserver,
    PushNotificationService&gt;();

// â”€â”€ Auto-subscribe at startup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This hosted service grabs all IChatObserver
// instances from DI and calls chatRoom.Join()
// for each one when the app starts.
builder.Services.AddHostedService&lt;
    ChatRoomSubscriptionManager&gt;();

// â”€â”€ SignalR for real-time UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
builder.Services.AddSignalR();</code></pre>
      </div>
      <div>
        <div class="callout callout-success" style="margin:0;border-radius:0.75rem 0.75rem 0 0;padding:0.6rem 1rem;"><div class="callout-title"><i class="fa-solid fa-globe"></i> Pull Model â€” REST API for Chat History</div></div>
        <pre style="margin:0;background:#1a1a2e;border-radius:0 0 0.75rem 0.75rem;border:1px solid rgba(255,255,255,0.08);border-top:none;"><code class="language-csharp" style="display:block;font-family:'JetBrains Mono',monospace;font-size:0.8rem;line-height:1.6;padding:1rem 1.25rem;background:transparent!important;color:#e2e8f0;">/// Pull model: "Show me what I missed."
/// This endpoint is called when a user opens the
/// app and wants to see recent messages BEFORE
/// the next push arrives. Think: scrolling up in
/// WhatsApp to see older messages.
[ApiController]
[Route("api/chat")]
public class ChatController : ControllerBase
{
    private readonly IChatRoom _chatRoom;

    public ChatController(IChatRoom chatRoom)
        =&gt; _chatRoom = chatRoom;

    [HttpGet("{roomId}/messages")]
    public IActionResult GetRecentMessages(
        string roomId, [FromQuery] int count = 50)
    {
        var messages = _chatRoom
            .GetRecentMessages(roomId, count);

        return messages.Count &gt; 0
            ? Ok(messages)
            : NotFound(new {
                Message = $"No messages in '{roomId}'"
              });
    }
}</code></pre>
      </div>
    </div>
    <div class="table-wrapper" style="margin-top:1rem;">
      <table>
        <thead><tr><th>Model</th><th>Chat App Example</th><th>Mechanism</th><th>When It Happens</th></tr></thead>
        <tbody>
          <tr><td><span class="badge badge-blue">Push</span></td><td>New message appears instantly in the chat window</td><td><code>OnMessageReceivedAsync()</code></td><td>Real-time â€” as soon as someone sends a message</td></tr>
          <tr><td><span class="badge badge-yellow">Pull</span></td><td>Loading chat history when you open the app</td><td><code>GetRecentMessages()</code></td><td>On-demand â€” when you scroll up or open a room</td></tr>
          <tr><td><span class="badge badge-green">Hybrid</span></td><td>Open app â†’ load history (pull) â†’ then receive new messages live (push)</td><td>Both: pull on join + push subscription</td><td>Best of both â€” no missed messages, plus real-time</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 10 -->
<section id="s10" class="section">
  <div class="section-header">
    <div class="section-icon red"><i class="fa-solid fa-bug"></i></div>
    <div><div class="section-num">Section 10</div><h2 class="section-title">Bug Case Studies</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-memory" style="color:var(--accent-red)"></i> Bug 10.1 â€” Memory Leak from Unsubscribed Observers</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-building"></i> Context</div>
      <strong>Company:</strong> Enterprise chat platform â€” presence and notification system.<br>
      <strong>Service:</strong> Real-time chat room service notifying presence observers when users connect/disconnect.
    </div>
    <h3 class="sub">The Buggy Code</h3>
    <div class="tab-container">
      <div class="tab-header">
        <button class="tab-btn active" data-tab="bug101-broken">ChatSessionManager.cs â€” BUGGY</button>
        <button class="tab-btn" data-tab="bug101-chatroom">ChatRoomService.cs (relevant portion)</button>
        <button class="tab-btn" data-tab="bug101-fixed">ChatSessionManager.cs â€” FIXED</button>
      </div>
      <div class="tab-panel active" data-panel="bug101-broken">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ChatSessionManager.cs â€” BUGGY</span></div>
          <div class="macos-body"><pre><code class="language-csharp">public class ChatSessionManager
{
    private readonly ChatRoomService _chatRoom;

    public void OnUserConnected(string userId, WebSocket socket)
    {
        // BUG: observer created and subscribed but NEVER stored
        // for later unsubscription
        var observer = new ChannelPresenceObserver(userId, socket);
        _chatRoom.Subscribe(observer);
        // When WebSocket disconnects, observer is NOT removed.
        // Developer assumed GC would handle it â€” WRONG.
        // The ChatRoomService holds a strong reference via subscriber list.
    }
}</code></pre></div>
        </div>
      </div>
      <div class="tab-panel" data-panel="bug101-chatroom">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ChatRoomService.cs â€” Subscribe/Unsubscribe</span></div>
          <div class="macos-body"><pre><code class="language-csharp">// The ChatRoomService keeps a ConcurrentDictionary of observers.
// Subscribe() adds the observer â€” Unsubscribe() removes it.
// If Unsubscribe is never called, the observer lives FOREVER.

public IDisposable Subscribe(IChatObserver observer)
{
    _observers[observer.ObserverId] = observer;
    _logger.LogInformation("Observer {Id} subscribed", observer.ObserverId);
    return new Unsubscriber(() =&gt;
    {
        _observers.TryRemove(observer.ObserverId, out _);
        _logger.LogInformation("Observer {Id} unsubscribed", observer.ObserverId);
    });
}

// This IDisposable is the KEY â€” if the caller discards it,
// there is NO way to remove the observer from the dictionary.</code></pre></div>
        </div>
      </div>
      <div class="tab-panel" data-panel="bug101-fixed">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ChatSessionManager.cs â€” FIXED</span></div>
          <div class="macos-body"><pre><code class="language-csharp">public class FixedChatSessionManager
{
    private readonly ChatRoomService _chatRoom;
    private readonly ConcurrentDictionary&lt;string, IDisposable&gt;
        _subscriptions = new();

    public void OnUserConnected(string userId, WebSocket socket)
    {
        var observer = new ChannelPresenceObserver(userId, socket);
        var subscription = _chatRoom.Subscribe(observer); // STORE IT
        _subscriptions[userId] = subscription;
    }

    public void OnUserDisconnected(string userId)
    {
        if (_subscriptions.TryRemove(userId, out var sub))
            sub.Dispose(); // Calls Unsubscribe internally
    }
}

// Belt-and-suspenders: background purge of dead observers
public class ObserverHealthCheck : BackgroundService
{
    private readonly ChatRoomService _chatRoom;
    public ObserverHealthCheck(ChatRoomService chatRoom)
        =&gt; _chatRoom = chatRoom;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            _chatRoom.RemoveDeadObservers(); // Remove consistently-failing observers
            await Task.Delay(TimeSpan.FromMinutes(1), ct);
        }
    }
}</code></pre></div>
        </div>
      </div>
    </div>
    <h3 class="sub">Business Impact</h3>
    <div class="grid-2">
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-microchip"></i> Memory</div>After 3 days: 12GB RAM (vs 500MB baseline). 200,000+ dead observers at ~50KB each.</div>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-clock"></i> Latency</div>Notification loop: 2ms â†’ 800ms (iterating 200K observers, mostly dead). Users reported "unacceptable message delay."</div>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-dollar-sign"></i> Revenue</div>$2.1M ARR lost â€” enterprise clients switched to competitors before bug was identified.</div>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-power-off"></i> Downtime</div>Service OOM-killed twice during peak hours. 45 minutes total downtime.</div>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> Lesson</div>
      <strong>Always store the <code>IDisposable</code> returned by <code>Subscribe()</code></strong>. If you don't call <code>Dispose()</code>, the observer stays subscribed forever. The subject holds a strong reference â€” GC cannot collect it.
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-hourglass-half" style="color:var(--accent-yellow)"></i> Bug 10.2 â€” Slow Observer Blocking Publisher</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-building"></i> Context</div>
      <strong>Company:</strong> Collaboration analytics platform.<br>
      <strong>Service:</strong> Message distribution service fanning out chat messages to analytics observers (spam detection, sentiment analysis, engagement tracking).
    </div>
    <h3 class="sub">The Buggy Code</h3>
    <div class="tab-container">
      <div class="tab-header">
        <button class="tab-btn active" data-tab="bug102-distributor">MessageDistributor.cs â€” BUGGY</button>
        <button class="tab-btn" data-tab="bug102-observer">SpamDetectionObserver.cs â€” BUGGY</button>
        <button class="tab-btn" data-tab="bug102-fixed">MessageDistributor.cs â€” FIXED</button>
      </div>
      <div class="tab-panel active" data-panel="bug102-distributor">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MessageDistributor.cs â€” BUGGY</span></div>
          <div class="macos-body"><pre><code class="language-csharp">public class MessageDistributor
{
    private readonly List&lt;IChatObserver&gt; _observers = new();

    public void OnMessageReceived(ChatMessage message)
    {
        // BUG: Sequential notification â€” each observer runs on same thread
        foreach (var observer in _observers)
            observer.OnMessageReceivedAsync(message, CancellationToken.None)
                .GetAwaiter().GetResult(); // One slow observer blocks ALL others
    }
}</code></pre></div>
        </div>
      </div>
      <div class="tab-panel" data-panel="bug102-observer">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SpamDetectionObserver.cs â€” BUGGY</span></div>
          <div class="macos-body"><pre><code class="language-csharp">// This observer started doing ML inference on every message
public class SpamDetectionObserver : IChatObserver
{
    public string ObserverId =&gt; "spam-detection";
    public IReadOnlySet&lt;string&gt;? MutedRoomIds =&gt; null; // null = listens to ALL rooms

    public async Task OnMessageReceivedAsync(
        ChatMessage message, CancellationToken ct)
    {
        // 5ms normally. During traffic spike: 500ms (model queue saturation)
        var history = await _dbContext.Messages
            .Where(m =&gt; m.SenderId == message.SenderId)
            .OrderByDescending(m =&gt; m.Timestamp)
            .Take(50).ToListAsync(ct); // SYNCHRONOUS DB on notification thread

        var score = await _mlModel.PredictSpamScoreAsync(
            message.Content, history, ct); // ML inference ON hot path
    }
}</code></pre></div>
        </div>
      </div>
      <div class="tab-panel" data-panel="bug102-fixed">
        <div class="macos-window">
          <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FixedMessageDistributor.cs</span></div>
          <div class="macos-body"><pre><code class="language-csharp">public class FixedMessageDistributor
{
    public async Task OnMessageReceivedAsync(ChatMessage message)
    {
        // Fix 1: PARALLEL with per-observer 100ms timeout
        var tasks = _observers.Select(async observer =&gt; {
            try {
                using var cts = new CancellationTokenSource(
                    TimeSpan.FromMilliseconds(100));
                await observer.OnMessageReceivedAsync(message, cts.Token);
            }
            catch (OperationCanceledException) {
                _logger.LogWarning("{Observer} timed out", observer.ObserverId);
            }
        });
        await Task.WhenAll(tasks);
    }
}

// Fix 2: Decouple I/O from notification via Channel&lt;T&gt;
public class FixedSpamDetectionObserver : IChatObserver
{
    private readonly Channel&lt;ChatMessage&gt; _queue =
        Channel.CreateBounded&lt;ChatMessage&gt;(new BoundedChannelOptions(10_000)
        { FullMode = BoundedChannelFullMode.DropOldest });

    public Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        _queue.Writer.TryWrite(message); // Non-blocking enqueue
        return Task.CompletedTask;
    }

    private async Task ProcessQueueAsync(CancellationToken ct) // Background
    {
        await foreach (var msg in _queue.Reader.ReadAllAsync(ct))
        {
            var history = await _dbContext.Messages
                .Where(m =&gt; m.SenderId == msg.SenderId)
                .Take(50).ToListAsync(ct); // DB work OFF hot path
            var score = await _mlModel.PredictSpamScoreAsync(
                msg.Content, history, ct);
        }
    }
}</code></pre></div>
        </div>
      </div>
    </div>
    <h3 class="sub">Business Impact</h3>
    <div class="grid-2">
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-clock"></i> Latency</div>Message delivery delayed 30+ seconds during peak. Users experienced "messages not appearing" in real-time chat.</div>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-users"></i> User Impact</div>Enterprise clients reported "unusable during all-hands meetings." Three clients escalated to VP-level complaints.</div>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> Lesson</div>
      <strong>Never do I/O in the notification handler.</strong> Use <code>Task.WhenAll</code> for parallel notification with per-observer timeouts. If an observer needs to do slow work, decouple it via <code>Channel&lt;T&gt;</code> â€” enqueue fast, process in background.
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-infinity" style="color:var(--accent-purple)"></i> Bug 10.3 â€” Infinite Notification Loop (Event Storm)</div>
    <div class="callout callout-danger">
      <div class="callout-title"><i class="fa-solid fa-building"></i> Context</div>
      <strong>Company:</strong> Enterprise chat platform with automated workflow triggers.<br>
      <strong>Service:</strong> Event-driven system where chat messages trigger automated actions (notifications â†’ escalations â†’ auto-responses).
    </div>
    <h3 class="sub">The Circular Chain</h3>
    <div class="mermaid-container">
      <span class="diagram-hint">Scroll or pinch to zoom</span>
      <div class="mermaid">
flowchart LR
    A["New Message"] --> B["@mention Notifier"]
    B --> C["Escalation Observer"]
    C --> D["Auto-Response Bot"]
    D --> E["Post Reply"]
    E -->|"New message!"| A
    style A fill:#1e3a5f,stroke:#ef4444,color:#f1f5f9
    style E fill:#1e3a5f,stroke:#ef4444,color:#f1f5f9
      </div>
    </div>
    <p class="body-text">A single @mention in #support triggered: Message â†’ Notifier â†’ Escalation â†’ Auto-Response Bot â†’ New Message â†’ ... <strong>Within 10 seconds:</strong> 50,000+ events, 8GB memory consumed, 12,000 auto-reply messages posted, users flooded with notifications.</p>
    <div class="grid-2">
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-bell"></i> Notification Storm</div>12,000 auto-generated messages in 10 seconds. All channel members received thousands of push notifications. Multiple users reported the app as spam.</div>
      <div class="callout callout-danger"><div class="callout-title"><i class="fa-solid fa-power-off"></i> Downtime</div>Chat service offline for 4 hours. Required manual database cleanup of 50K+ auto-generated messages.</div>
    </div>
    <h3 class="sub">The Fix</h3>
    <div class="macos-window">
      <div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SafeEventBus.cs â€” Loop Detection</span></div>
      <div class="macos-body"><pre><code class="language-csharp">// Fix 1: Correlation ID + depth tracking
public abstract record TrackedEvent(
    string CorrelationId, int Depth, DateTimeOffset Timestamp);

public class SafeEventBus : IChatEventBus
{
    private const int MaxEventDepth = 5;

    public async Task PublishAsync&lt;TEvent&gt;(TEvent @event)
        where TEvent : TrackedEvent
    {
        if (@event.Depth &gt; MaxEventDepth)
        {
            _logger.LogCritical(
                "CIRCUIT-BREAKER: Chain depth {Depth} exceeds max {Max}. " +
                "Correlation: {Id}. DROPPING event.",
                @event.Depth, MaxEventDepth, @event.CorrelationId);
            return; // Break the infinite loop
        }
        // Normal publish, passing Depth + 1 to child events...
    }
}

// Fix 2: Debounce auto-responses â€” max once per 5 minutes per channel
public class FixedAutoResponseObserver
{
    private readonly Timer _debounce;
    private EscalationEvent? _pending;

    public Task HandleAsync(EscalationEvent e)
    {
        _pending = e;          // Store latest; timer picks it up
        return Task.CompletedTask; // Don't act immediately
    }

    private void OnTimer(object? _)
    {
        var evt = Interlocked.Exchange(ref _pending, null);
        if (evt != null &amp;&amp; NeedsAutoResponse(evt))
        { /* Rate-limited auto-response */ }
    }
}

// Fix 3: Tag auto-responses as "bot-generated" â€”
// notification observer ignores bot-generated messages</code></pre></div>
    </div>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-lightbulb"></i> Lesson</div>
      <strong>When observers publish events, watch for circular chains.</strong> Use: (1) correlation ID + depth limit for circuit-breaking, (2) debounce for rate-limiting, (3) event tagging to distinguish internal vs external triggers.
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 12 -->
<section id="s12" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-cubes"></i></div>
    <div><div class="section-num">Section 12</div><h2 class="section-title">SOLID Mapping</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-1" style="color:var(--accent-blue)"></i> Single Responsibility Principle â€” ENFORCES</div>
    <p class="body-text">Observer structurally separates "what happened" (Subject detecting a new message) from "what to do about it" (each Observer's reaction). Without Observer, the Subject accumulates responsibilities for every downstream concern.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-xmark"></i> Before (No Observer)</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);"><code>ChatRoomService</code> does EVERYTHING: mention notifications, unread counting, spam detection, audit logging. 4 injected services, 4 reasons to change. Every new requirement = modify this class.</p>
        </div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-check"></i> After (Observer)</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);">Subject has ONE job: detect changes, notify observers. Each concern is an independent observer class. Alert team, compliance team, analytics team work in parallel â€” no merge conflicts.</p>
        </div>
      </div>
    </div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SRP_Comparison.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// &#x274C; BEFORE: ChatRoomService does EVERYTHING &#x2014; 4 responsibilities
public class ChatRoomService
{
    private readonly IPushNotificationService _push;    // Responsibility 1
    private readonly IUnreadCountService _unread;       // Responsibility 2
    private readonly IAuditLogger _audit;               // Responsibility 3
    private readonly ISpamDetectionService _spam;       // Responsibility 4

    public async Task OnMessageReceived(ChatMessage message, CancellationToken ct)
    {
        await _push.NotifyMentionsAsync(message, ct);   // Mention logic HERE
        await _unread.IncrementAsync(message, ct);      // Unread count HERE
        await _audit.LogAsync(message, ct);             // Audit logic HERE
        await _spam.EvaluateAsync(message, ct);         // Spam detection HERE
        // Every new requirement = modify THIS class
    }
}

// &#x2705; AFTER: Subject has ONE job &#x2014; detect and notify
public class ChatRoomService
{
    private readonly IEnumerable&lt;IChatObserver&gt; _observers; // ONE dependency

    public async Task OnMessageReceived(ChatMessage message, CancellationToken ct)
    {
        foreach (var obs in _observers)
            await obs.OnMessageReceivedAsync(message, ct);  // That is ALL it does
    }
}

// Each concern is its own class, its own file, its own team
public class MentionNotifier : IChatObserver { /* mention notifications */ }
public class UnreadCountTracker : IChatObserver { /* unread count tracking */ }
public class ChatAuditLogger : IChatObserver { /* audit logging */ }
public class AutoModerationObserver : IChatObserver { /* spam detection */ }</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-2" style="color:var(--accent-green)"></i> Open/Closed Principle â€” ENFORCES</div>
    <p class="body-text">Adding a new consumer = add one new observer class + one DI registration. <strong>Zero changes to the Subject or existing observers.</strong> The subject is closed for modification, open for extension.</p>
    <div class="callout callout-success">
      <div class="callout-title"><i class="fa-solid fa-code-branch"></i> Sprint-14 Example</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">PM says "add auto-translation for every message." Senior creates <code>TranslationObserver : IChatObserver</code>, registers in DI. Done. <code>ChatRoomService</code> not touched. No regression risk. No re-testing of existing observers.</p>
    </div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OCP_AddingTranslationObserver.cs &#x2014; Zero Existing Code Modified</span></div><div class="macos-body"><pre><code class="language-csharp">// Sprint 14: "Add auto-translation for every message"
// Step 1: Create ONE new class
public sealed class TranslationObserver : IChatObserver
{
    private readonly ITranslationService _translator;
    private readonly ILogger&lt;TranslationObserver&gt; _logger;

    public TranslationObserver(ITranslationService translator,
        ILogger&lt;TranslationObserver&gt; logger)
    {
        _translator = translator;
        _logger = logger;
    }

    public async Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        var result = await _translator.DetectAndTranslateAsync(message.Content, ct);
        if (result.WasTranslated)
            _logger.LogInformation("Translated message in {Room} from {Lang}",
                message.RoomId, result.SourceLanguage);
    }
}

// Step 2: ONE line in DI registration
builder.Services.AddSingleton&lt;IChatObserver, TranslationObserver&gt;();

// Classes that are NEVER MODIFIED:
// &#x2713; ChatRoomService            (Subject &#x2014; unchanged)
// &#x2713; MentionNotifier            (existing observer &#x2014; unchanged)
// &#x2713; UnreadCountTracker         (existing observer &#x2014; unchanged)
// &#x2713; ChatAuditLogger            (existing observer &#x2014; unchanged)
// &#x2713; AutoModerationObserver     (existing observer &#x2014; unchanged)</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-3" style="color:var(--accent-yellow)"></i> Liskov Substitution Principle â€” SUPPORTS (When Used Correctly)</div>
    <p class="body-text">All observers implement <code>IChatObserver</code> and are interchangeable from the Subject's perspective. The contract: <strong>never throw</strong>, complete in bounded time, don't mutate input data.</p>
    <div class="callout callout-warning">
      <div class="callout-title"><i class="fa-solid fa-triangle-exclamation"></i> LSP Violation</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);">An observer that throws exceptions or takes 30 seconds to complete violates LSP â€” it changes the Subject's behavior (cascading failures, timeouts). The contract must be explicit: <em>"Observers MUST handle their own exceptions and complete within 50ms."</em></p>
    </div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LSP_ObserverContract.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// &#x274C; BAD: Violates LSP &#x2014; changes Subject's behavior
public class BadAnalyticsObserver : IChatObserver
{
    public async Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        // Violation 1: No try/catch &#x2014; exception propagates to Subject,
        // potentially killing notification for ALL remaining observers
        var result = await _httpClient.PostAsync("/analytics", content);

        // Violation 2: No timeout &#x2014; if analytics API hangs for 30 seconds,
        // the entire notification pipeline stalls
        await _dbContext.SaveChangesAsync();
    }
}

// &#x2705; GOOD: Respects LSP contract &#x2014; predictable behavior from Subject's perspective
public class GoodAnalyticsObserver : IChatObserver
{
    public async Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        // Self-imposed timeout: 50ms max, linked to parent cancellation
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(TimeSpan.FromMilliseconds(50));

        try
        {
            await _httpClient.PostAsync("/analytics", content, cts.Token);
            await _dbContext.SaveChangesAsync(cts.Token);
        }
        catch (OperationCanceledException)
        {
            _logger.LogWarning("Analytics observer timed out for {Room}", message.RoomId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Analytics observer failed for {Room}", message.RoomId);
            // Swallow &#x2014; never let this observer's failure affect others
        }
    }
}</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-4" style="color:var(--accent-purple)"></i> Interface Segregation Principle â€” ENFORCES</div>
    <p class="body-text">Observers should implement focused interfaces per event type, not a fat interface with methods for every event.</p>
    <div class="comparison-grid">
      <div class="comparison-panel bad">
        <div class="comparison-header"><i class="fa-solid fa-xmark"></i> Fat Interface</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);"><code>IChatEventObserver</code> with 4 methods: <code>OnMessageReceived</code>, <code>OnReactionAdded</code>, <code>OnPresenceChanged</code>, <code>OnTypingStarted</code>. Mention notifier forced to implement all 4 â€” 3 are no-op.</p>
        </div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel good">
        <div class="comparison-header"><i class="fa-solid fa-check"></i> Segregated Interfaces</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);">Separate <code>IChatObserver</code>, <code>IReactionObserver</code>, <code>IPresenceObserver</code>. Each observer implements only the interface(s) it actually needs.</p>
        </div>
      </div>
    </div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ISP_Comparison.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// &#x274C; BEFORE: Fat interface &#x2014; forces implementations to stub out unused methods
public interface IChatEventObserver
{
    Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct);
    Task OnReactionAddedAsync(ReactionEvent reaction, CancellationToken ct);
    Task OnPresenceChangedAsync(PresenceEvent presence, CancellationToken ct);
    Task OnTypingStartedAsync(TypingEvent typing, CancellationToken ct);
}

// MentionNotifier only cares about messages &#x2014; forced to implement 3 no-ops
public class MentionNotifier : IChatEventObserver
{
    public Task OnMessageReceivedAsync(ChatMessage m, CancellationToken ct)
        =&gt; NotifyMentions(m, ct);  // &#x2190; the only real implementation
    public Task OnReactionAddedAsync(ReactionEvent r, CancellationToken ct)
        =&gt; Task.CompletedTask;     // &#x2190; waste
    public Task OnPresenceChangedAsync(PresenceEvent p, CancellationToken ct)
        =&gt; Task.CompletedTask;     // &#x2190; waste
    public Task OnTypingStartedAsync(TypingEvent t, CancellationToken ct)
        =&gt; Task.CompletedTask;     // &#x2190; waste
}

// &#x2705; AFTER: Segregated interfaces &#x2014; implement only what you need
public interface IChatObserver
{
    Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct);
}
public interface IReactionObserver
{
    Task OnReactionAddedAsync(ReactionEvent reaction, CancellationToken ct);
}
public interface IPresenceObserver
{
    Task OnPresenceChangedAsync(PresenceEvent presence, CancellationToken ct);
}

// MentionNotifier implements ONLY IChatObserver
public class MentionNotifier : IChatObserver { /* message logic only */ }

// AdminDashboardObserver needs all three &#x2014; implements by CHOICE
public class AdminDashboardObserver
    : IChatObserver, IReactionObserver, IPresenceObserver { /* all three */ }</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-5" style="color:var(--accent-cyan)"></i> Dependency Inversion Principle â€” ENFORCES</div>
    <p class="body-text">The Subject depends on the <code>IChatObserver</code> abstraction, never on concrete types. The DI container wires concrete observers at runtime. Subject can be tested with mock observers, and concrete observers can be swapped without modifying the Subject.</p>
    <div class="callout callout-info">
      <div class="callout-title"><i class="fa-solid fa-arrows-up-down"></i> The Inversion</div>
      <p style="font-size:0.9rem;color:var(--text-secondary);"><strong>Before:</strong> <code>ChatRoomService</code> depends on <code>IPushNotificationService</code>, <code>IUnreadCountService</code>, <code>IAuditRepository</code> (concrete/specific). <strong>After:</strong> depends only on <code>IChatObserver</code> (abstract/general). The dependency arrow points toward the abstraction, not toward the details.</p>
    </div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DIP_Comparison.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// &#x274C; BEFORE: Subject depends on concrete implementations (arrows point DOWN)
public class ChatRoomService
{
    // Three concrete/specific dependencies &#x2014; tightly coupled
    private readonly IPushNotificationService _push;  // concrete push service
    private readonly IUnreadCountService _unread;      // specific counter
    private readonly IAuditRepository _audit;          // specific repository

    public async Task OnMessageReceived(ChatMessage message, CancellationToken ct)
    {
        await _push.NotifyMentionsAsync(message, ct);   // knows about push
        await _unread.IncrementAsync(message, ct);       // knows about unread counts
        await _audit.LogAsync(message, ct);              // knows about auditing
    }
}
// Dependency: ChatRoomService &#x2192; IPushNotificationService (VIOLATION)
// Dependency: ChatRoomService &#x2192; IUnreadCountService (VIOLATION)
// Dependency: ChatRoomService &#x2192; IAuditRepository (VIOLATION)

// &#x2705; AFTER: Subject depends ONLY on abstraction (arrow points UP to interface)
public class ChatRoomService
{
    private readonly IEnumerable&lt;IChatObserver&gt; _observers; // ONE abstraction

    public async Task OnMessageReceived(ChatMessage message, CancellationToken ct)
    {
        foreach (var obs in _observers)
            await obs.OnMessageReceivedAsync(message, ct);
    }
}

// DI wiring &#x2014; concrete types listed here, not in the Subject
builder.Services.AddSingleton&lt;IChatObserver, MentionNotifier&gt;();
builder.Services.AddSingleton&lt;IChatObserver, UnreadCountTracker&gt;();
builder.Services.AddSingleton&lt;IChatObserver, ChatAuditLogger&gt;();
builder.Services.AddSingleton&lt;IChatObserver, AutoModerationObserver&gt;();

// Dependency: ChatRoomService &#x2192; IChatObserver (CORRECT &#x2014; abstraction)
// Dependency: MentionNotifier &#x2192; IChatObserver (CORRECT &#x2014; implements abstraction)</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-table" style="color:var(--accent-blue)"></i> SOLID Summary</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Principle</th><th>Verdict</th><th>Mechanism</th></tr></thead>
        <tbody>
          <tr><td><strong>SRP</strong></td><td><span class="badge badge-green">ENFORCES</span></td><td>Subject broadcasts; each observer has one concern</td></tr>
          <tr><td><strong>OCP</strong></td><td><span class="badge badge-green">ENFORCES</span></td><td>New observer = new class + DI line. Subject unchanged.</td></tr>
          <tr><td><strong>LSP</strong></td><td><span class="badge badge-yellow">SUPPORTS</span></td><td>All observers interchangeable IF they follow the contract (no-throw, bounded time)</td></tr>
          <tr><td><strong>ISP</strong></td><td><span class="badge badge-green">ENFORCES</span></td><td>Focused per-event interfaces, not fat multi-event interface</td></tr>
          <tr><td><strong>DIP</strong></td><td><span class="badge badge-green">ENFORCES</span></td><td>Subject depends on <code>IChatObserver</code> abstraction, not concrete types</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 13 -->
<section id="s13" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-scale-balanced"></i></div>
    <div><div class="section-num">Section 13</div><h2 class="section-title">Pattern Comparisons</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-table-columns" style="color:var(--accent-blue)"></i> Master Comparison Table</div>
    <div class="table-wrapper">
      <table>
        <thead><tr><th>Dimension</th><th>Observer</th><th>Mediator</th><th>Pub/Sub (Broker)</th><th>Chain of Responsibility</th></tr></thead>
        <tbody>
          <tr><td><strong>Intent</strong></td><td>One-to-many notification</td><td>Many-to-many coordination via central hub</td><td>Decoupled messaging via broker</td><td>Pass request along chain until handled</td></tr>
          <tr><td><strong>Coupling</strong></td><td>Subject knows it HAS observers (interface)</td><td>Mediator knows all colleagues</td><td>Zero â€” publisher/subscriber unaware</td><td>Each handler knows next handler</td></tr>
          <tr><td><strong>Routing</strong></td><td>Broadcast to ALL â€” no intelligence</td><td>Mediator contains routing logic</td><td>Broker routes by topic/filter</td><td>Each handler inspects &amp; decides</td></tr>
          <tr><td><strong>Scale</strong></td><td>In-process, single app</td><td>In-process, single app</td><td>Cross-process, distributed</td><td>In-process, single app</td></tr>
          <tr><td><strong>Awareness</strong></td><td>Observers don't know each other</td><td>Colleagues don't know each other</td><td>Subscribers don't know each other</td><td>Handler knows next handler only</td></tr>
          <tr><td><strong>Direction</strong></td><td>Unidirectional: Subject â†’ Observers</td><td>Bidirectional: Colleague â†” Mediator</td><td>Unidirectional: Pub â†’ Broker â†’ Sub</td><td>Unidirectional: Handler â†’ Next</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-arrows-left-right" style="color:var(--accent-purple)"></i> Observer vs Mediator â€” The Most Confused Pair</div>
    <div class="comparison-grid">
      <div class="comparison-panel" style="border-color:rgba(59,130,246,0.3);">
        <div class="comparison-header" style="background:rgba(59,130,246,0.15);color:#93c5fd;"><i class="fa-solid fa-bullhorn"></i> Observer â€” Broadcast</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);">Subject broadcasts to ALL observers. Zero routing intelligence. Each observer receives every event and filters on its own. The subject has NO knowledge of which observer needs what.</p>
          <div class="macos-window" style="max-width:100%;margin:0.5rem 0;">
            <div class="macos-body" style="max-height:200px;"><pre><code class="language-csharp">// Subject: broadcast to ALL â€” no filtering
foreach (var observer in _observers.ToList())
    await observer.OnMessageReceivedAsync(update, ct);

// Observer does its own filtering
if (!_watchedRooms.Contains(message.RoomId))
    return;</code></pre></div>
          </div>
        </div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel" style="border-color:rgba(139,92,246,0.3);">
        <div class="comparison-header" style="background:rgba(139,92,246,0.15);color:#c4b5fd;"><i class="fa-solid fa-sitemap"></i> Mediator â€” Routing</div>
        <div style="padding:0 1.25rem 1rem;">
          <p style="font-size:0.85rem;color:var(--text-secondary);">Mediator contains routing intelligence. It decides WHO gets notified based on business rules. Colleagues don't subscribe â€” the mediator explicitly wires them.</p>
          <div class="macos-window" style="max-width:100%;margin:0.5rem 0;">
            <div class="macos-body" style="max-height:200px;"><pre><code class="language-csharp">// Mediator: routing rules inside
if (update.RoomId is "#general" or "#engineering")
    await _moderationEngine.EvaluateAsync(update, ct);

if (update.MentionedUserIds.Count > 5)
    await _alertService.NotifyAsync(update, ct);

await _auditService.LogAsync(update, ct);</code></pre></div>
          </div>
        </div>
      </div>
    </div>
    <div class="callout callout-info" style="margin-top:1rem;">
      <div class="callout-title"><i class="fa-solid fa-key"></i> Key Distinction</div>
      <strong>Observer:</strong> "I don't know who needs this, but everyone subscribed will get it."<br>
      <strong>Mediator:</strong> "I know exactly who needs this and I'll route it to the right services."
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-network-wired" style="color:var(--accent-green)"></i> Observer vs Pub/Sub â€” In-Process vs Distributed</div>
    <div class="comparison-grid">
      <div class="comparison-panel" style="border-color:rgba(59,130,246,0.3);">
        <div class="comparison-header" style="background:rgba(59,130,246,0.15);color:#93c5fd;"><i class="fa-solid fa-eye"></i> Observer (In-Process)</div>
        <div style="padding:0 1.25rem 1rem;">
          <ul class="styled">
            <li>Direct object references â€” subject calls observer methods</li>
            <li>No serialization, no network, no broker</li>
            <li>Subject and observers live in the same process</li>
            <li>No durability â€” if process crashes, in-flight notifications lost</li>
          </ul>
        </div>
      </div>
      <div class="vs-badge">VS</div>
      <div class="comparison-panel" style="border-color:rgba(16,185,129,0.3);">
        <div class="comparison-header" style="background:rgba(16,185,129,0.15);color:#6ee7b7;"><i class="fa-solid fa-server"></i> Pub/Sub (Distributed)</div>
        <div style="padding:0 1.25rem 1rem;">
          <ul class="styled green">
            <li>Message broker intermediary (RabbitMQ, Kafka)</li>
            <li>Publisher and subscriber never know about each other</li>
            <li>Cross-process, cross-language, cross-platform</li>
            <li>Durable â€” messages survive process crashes, replay possible</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-compass" style="color:var(--accent-cyan)"></i> Senior Decision Tree</div>
    <h3>Decision Flowchart</h3>
    <div class="mermaid-container">
      <span class="diagram-hint">Scroll or pinch to zoom</span>
      <div class="mermaid">
flowchart TD
    A["How many consumers?"] --> B{"1 consumer"}
    A --> C{"2 consumers, stable"}
    A --> D{"3+ consumers OR growing"}
    B --> E["Direct method call"]
    C --> F["Direct calls or facade"]
    D --> G{"In-process only?"}
    G --> H{"Yes"} --> I["Observer Pattern"]
    G --> J{"Cross-process needed"} --> K["Pub/Sub with Message Broker"]
    I --> L{"Need routing intelligence?"}
    L --> M{"Yes"} --> N["Mediator Pattern"]
    L --> O{"No, broadcast"} --> P["Observer Pattern"]
    style E fill:#1a3a2a,stroke:#10b981,color:#f1f5f9
    style F fill:#1a3a2a,stroke:#10b981,color:#f1f5f9
    style I fill:#1e3a5f,stroke:#3b82f6,color:#f1f5f9
    style K fill:#2d1b4e,stroke:#8b5cf6,color:#f1f5f9
    style N fill:#2d1b4e,stroke:#8b5cf6,color:#f1f5f9
    style P fill:#1e3a5f,stroke:#3b82f6,color:#f1f5f9
      </div>
    </div>
  </div>
</section>

<!-- ============================================================ SECTION 14 -->
<section id="s14" class="section">
  <div class="section-header">
    <div class="section-icon purple"><i class="fa-solid fa-comments"></i></div>
    <div><div class="section-num">Section 14</div><h2 class="section-title">Interview Q&amp;As</h2></div>
  </div>

  <p class="body-text">25 questions arranged by category: <span class="badge badge-blue">Conceptual</span> Q1-Q5, <span class="badge badge-green">Design</span> Q6-Q10, <span class="badge badge-red">Debugging</span> Q11-Q15, <span class="badge badge-purple">Comparison</span> Q16-Q20, <span class="badge badge-yellow">Production</span> Q21-Q25. All answers are written in plain language &#x2014; every technical term is explained when it first appears. You do not need prior knowledge of threading, distributed systems, or async programming to follow along.</p>

  <!-- Q1 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q1: What is the Observer pattern and why does it exist?</div><div class="qa-meta"><span class="badge badge-blue">Conceptual</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Start by explaining the problem: what goes wrong when one object directly calls another every time something changes? Then show a real example where this gets messy. Finally, mention that Observer is not always the right tool â€” there are simpler situations where it adds more complexity than it solves.</div>
      <p class="body-text">The Observer pattern is like a notification system â€” think of it as subscribing to a YouTube channel. You have one object called the <strong>Subject</strong> (the thing being watched â€” like a YouTube channel) and many objects called <strong>Observers</strong> (the watchers â€” like subscribers). Whenever the Subject changes, it automatically tells all its Observers. Without this pattern, every time you want something new to happen when data changes, you would have to go back and edit the original code â€” which gets messy fast. The code example below shows this: on the left, the <code>ChatRoom</code> class has to be modified every single sprint to add a new reaction. On the right, with Observer, the <code>ChatRoom</code> never needs to change â€” you just register a new observer.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">WithoutVsWithObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// WITHOUT Observer: modify ChatRoom for every new reaction
public class ChatRoom {
    public void BroadcastMessage(string roomId, string content) {
        SaveToDatabase(roomId, content);
        SendAlert(roomId, content);        // Sprint 1
        UpdateDashboard(roomId, content);   // Sprint 3
        CalculateRisk(roomId, content);     // Sprint 7 â€” this grows forever
    }
}

// WITH Observer: Subject never changes
public class ChatRoom {
    private readonly List&lt;IChatObserver&gt; _observers = new();
    public void BroadcastMessage(string roomId, string content) {
        foreach (var obs in _observers.ToList())
            obs.OnMessageReceived(roomId, content);
        // New reaction = register new observer. Zero changes here.
    }
}</code></pre></div></div>
      <p class="body-text"><strong>Follow-up:</strong> Sometimes a direct call is better and simpler. If you only have one or two things that react to a change, and those things will never change, Observer just adds unnecessary complexity. For example, if <code>TradeExecutor</code> always and only calls <code>Settlement.Settle()</code> â€” that's a fixed, stable relationship â€” adding Observer would be over-engineering it.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> A strong answer acknowledges the hidden downside of Observer: it makes the code harder to trace. When you read the Subject, you can't easily see "who is watching this?" without digging through the dependency injection setup. A great engineer designs the Observer system AND builds a monitoring dashboard at the same time, so the team can always see which observers are registered and running.</div>
    </div></div>
  </div>

  <!-- Q2 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q2: Push vs Pull models â€” which for a high-frequency chat system?</div><div class="qa-meta"><span class="badge badge-blue">Conceptual</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> First, explain what push and pull actually mean in simple terms. Then compare them: what are the pros and cons of each? Finally, give a clear recommendation for real-time chat systems specifically, and explain why.</div>
      <p class="body-text">Think of this like a news service. <strong>Push</strong> means the news service sends you the full article the moment it is published â€” you get the complete data right away. <strong>Pull</strong> means the news service just taps you on the shoulder and says "hey, something changed" â€” then you go fetch the full article yourself. For a chat system where messages arrive in real-time, <strong>push is the right choice</strong> â€” you cannot afford the delay of going back to ask for the data. A hybrid approach is even better: push the lightweight essential data (like message text + sender) immediately, but only go fetch the full metadata on demand when you actually need it.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PushVsPull.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// PUSH: Observer gets fresh data immediately
public interface IPushObserver {
    Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct);
}

// HYBRID (recommended): Push lightweight + pull details on demand
public record MessageNotification(string RoomId, string SenderId, long SeqNum);

public sealed class DetailedAnalysisObserver : IHybridObserver {
    public async Task OnMessageReceivedAsync(MessageNotification n, CancellationToken ct) {
        if (n.RoomId == _monitoredRoom) {
            var full = await _query.GetBySequenceAsync(n.SeqNum, ct);
            await PerformDetailedAnalysis(full, ct);
        }
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> The best answer explains the hybrid model: push the small, essential data immediately (so the observer reacts fast), but only pull the full detailed data when the observer actually decides it needs it. This avoids sending large data packages for every single tick when most observers won't even use the details. This is the same approach that .NET's event system, MediatR (a popular .NET messaging library), and real-world event-driven systems use in production.</div>
    </div></div>
  </div>

  <!-- Q3 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q3: How do you manage observer lifecycle in a DI container?</div><div class="qa-meta"><span class="badge badge-blue">Conceptual</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1: explain what DI (Dependency Injection) is in simple terms â€” a system that creates and manages your objects for you. Step 2: explain when observers should subscribe (at app startup) and unsubscribe (at app shutdown). Step 3: explain the difference between singleton (one instance shared forever) vs scoped (a fresh instance per web request) and why the wrong choice causes bugs.</div>
      <p class="body-text"><strong>DI (Dependency Injection)</strong> is a system where you tell the app "I need this service," and the framework creates it and hands it to you â€” you don't create it yourself with <code>new</code>. For observers, you register them in DI and use an <code>IHostedService</code> (think of it as a background manager that runs when the app starts and stops) to subscribe observers when the app boots up and unsubscribe them cleanly when the app shuts down. Observers should be registered as <strong>singletons</strong> â€” meaning one instance is created and shared for the entire lifetime of the app. If you made them "scoped" (a fresh instance per web request), you'd create thousands of observer instances, each subscribing to the feed, which would be a disaster.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SubscriptionLifecycle.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public class ChatRoomSubscriptionManager : IHostedService
{
    private readonly IChatMessageFeed _feed;
    private readonly IEnumerable&lt;IChatObserver&gt; _observers;
    private readonly List&lt;IDisposable&gt; _subscriptions = new();

    public Task StartAsync(CancellationToken ct) {
        foreach (var observer in _observers)
            _subscriptions.Add(_feed.Subscribe(observer));
        return Task.CompletedTask;
    }

    public Task StopAsync(CancellationToken ct) {
        foreach (var sub in _subscriptions)
            sub.Dispose(); // Clean unsubscribe
        return Task.CompletedTask;
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer warns about a specific trap: never let a "scoped" observer (one that is supposed to be created and destroyed per web request) subscribe to a "singleton" subject (one that lives forever). Here's the problem â€” the scoped observer gets destroyed after each request, but the singleton subject still holds a reference to it. The next time the subject tries to notify that observer, it is accessing a dead object. This causes a <strong>use-after-dispose bug</strong> â€” a crash or silent failure that is very hard to debug.</div>
    </div></div>
  </div>

  <!-- Q4 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q4: How do you make Observer thread-safe?</div><div class="qa-meta"><span class="badge badge-blue">Conceptual</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> First, explain what "thread-safe" means: multiple parts of the code running at the same time without corrupting each other. Then identify the specific problem: one thread is going through the observer list to send notifications, while another thread is adding or removing observers from that same list at the same time. Then explain the solution: take a snapshot of the list first, then iterate the snapshot.</div>
      <p class="body-text"><strong>Thread-safe</strong> means your code works correctly even when multiple threads are running at the same time. Imagine your app is handling requests on multiple threads simultaneously. Thread A is going through the observer list sending notifications. At the exact same moment, Thread B is adding a new observer to that list. This is a race condition â€” Thread A might crash, skip observers, or behave unpredictably. The solution is called <strong>snapshot-before-iterate</strong>: before you start the loop, take a copy of the entire list. Then loop over the copy. Even if Thread B modifies the original list, your copy is safe. Using <code>ConcurrentDictionary.Values</code> does this automatically â€” it returns a snapshot of the values at that moment.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ThreadSafeNotification.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ConcurrentDictionary.Values returns a snapshot â€” safe to iterate
var snapshot = _observers.Values.ToList();
var tasks = snapshot.Select(async observer =&gt; {
    try { await observer.OnMessageReceivedAsync(update, ct); }
    catch (Exception ex) { _logger.LogError(ex, "..."); }
});
await Task.WhenAll(tasks);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer warns about a subtle trap with a tool called <code>ReaderWriterLockSlim</code>. If you hold a "read lock" while calling observers, and one of those observers tries to unsubscribe (which needs a "write lock"), the two locks will wait for each other forever â€” a situation called a <strong>deadlock</strong>, where the app just freezes. The snapshot-then-iterate approach avoids this entirely: you grab the list copy quickly, release any lock, and then call the observers with no lock held at all.</div>
    </div></div>
  </div>

  <!-- Q5 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q5: What is the "lapsed listener" problem?</div><div class="qa-meta"><span class="badge badge-blue">Conceptual</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Explain the problem with a real-world analogy first. Then explain what "garbage collection" is in simple terms. Then list the solutions with their trade-offs.</div>
      <p class="body-text">The "lapsed listener" problem is like being subscribed to thousands of email newsletters but never unsubscribing from any of them â€” even after you stop caring. In code: when an observer subscribes to a subject, the subject keeps a reference (a pointer) to that observer. This keeps the observer alive in memory. If the observer is no longer needed but never unsubscribes, the subject still holds that reference. <strong>Garbage collection</strong> is the automatic process that cleans up objects you no longer need â€” but it only cleans up objects that nothing is pointing to. Since the subject still points to the dead observer, the garbage collector cannot clean it up. Over time, thousands of these "zombie" observers pile up, wasting memory and CPU.</p>
      <p class="body-text"><strong>Solutions:</strong> (1) Use <code>IDisposable</code> subscription handles â€” when you subscribe, you get back a handle object. When you are done, call <code>Dispose()</code> on it to unsubscribe cleanly. (2) Use <code>WeakReference&lt;T&gt;</code> â€” a "weak" reference that the garbage collector is allowed to throw away. (3) Add a background health check that automatically removes observers that keep failing.</p>
      <div class="qa-great"><strong>What separates good from great:</strong> <code>WeakReference</code> sounds like a clever automatic fix, but it is dangerous. If nothing else in your code is holding onto the observer (other than the subject's weak reference), the garbage collector can silently throw it away at any time â€” and your observer just vanishes with no error, no log, nothing. This is very hard to debug. The safest approach is explicit <code>IDisposable</code> â€” you control exactly when observers unsubscribe â€” combined with health checks that catch any that slip through.</div>
    </div></div>
  </div>

  <!-- Q6 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q6: Design a real-time chat mention alert system using Observer</div><div class="qa-meta"><span class="badge badge-green">Design</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Map the problem to Observer roles: what is the Subject (the thing being watched)? What is the Observer (the thing reacting)? What data does the Observer need? What does the Observer do when it reacts? Then mention one practical detail that makes it production-ready.</div>
      <p class="body-text">Let's map this to Observer roles. The <strong>Subject</strong> is <code>ChatRoomService</code> â€” it is the thing being watched. It publishes a notification every time a new message arrives. The <strong>Observer</strong> is <code>MentionNotifier</code> â€” it watches the chat rooms. It keeps a list of alert rules per user (e.g., "alert me when @alice is mentioned in #support"). Every time a message arrives, it checks the rules and fires a push notification if any rule is triggered. The <code>MutedRoomIds</code> property is an optimization â€” instead of the MentionNotifier receiving updates for all 5,000 rooms, it tells the service "skip these muted rooms," so the service avoids calling it for irrelevant updates. A <code>null</code> value means "I want updates from all rooms."</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MentionAlertSystem.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public sealed class MentionNotifier : IChatObserver
{
    public string ObserverId =&gt; "mention-notifier";
    public IReadOnlySet&lt;string&gt;? MutedRoomIds =&gt; null; // null = listens to all rooms (rules handle filtering)

    private readonly ConcurrentDictionary&lt;string, List&lt;AlertRule&gt;&gt; _rules;

    public async Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        if (!_rules.TryGetValue(message.RoomId, out var rules)) return;
        foreach (var rule in rules.Where(r =&gt; r.IsTriggered(message.Content)))
        {
            await _notifier.SendAsync(new Alert {
                UserId = rule.UserId, RoomId = message.RoomId,
                Content = message.Content, Type = rule.AlertType
            }, ct);
            if (rule.FireOnce) rules.Remove(rule);
        }
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A strong answer goes beyond the basic design and mentions the production-readiness features. <strong>Alert deduplication</strong> means don't send the same alert twice within 5 minutes â€” if a keyword keeps triggering the same rule, the user should not get 50 notifications. <strong>Rate limiting per user</strong> means cap how many alerts one user can receive per hour. <strong>Alert acknowledgment</strong> means the user can silence an alert. A <strong>dead-letter queue</strong> is a holding area for notifications that failed to send â€” so they are not just lost â€” they can be retried later.</div>
    </div></div>
  </div>

  <!-- Q7-Q10 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q7: How would you implement an undo/redo system using Observer? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-green">Design</span> &nbsp; Follow-up: How do you handle undo when some observers have already produced irreversible side effects like sending an email?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 â€” Observer by itself is a one-way notification. It fires and forgets. It does not remember what happened, so it has no way to undo. Step 2 â€” To support undo, you need to remember what happened. That is what the Command pattern adds: each action becomes an object that knows how to execute AND how to reverse itself. Step 3 â€” Combine Observer + Command: observers produce Command objects instead of doing things directly. A journal records those commands. Undo means popping the journal and calling Undo on the last command. Step 4 â€” Not everything can be undone. Think about what to do when undo is impossible.</div>
      <p class="body-text">Observer alone cannot support undo because it is a <strong>fire-and-forget</strong> mechanism &#x2014; meaning it sends the notification and immediately forgets it ever happened. There is no record of what was done, so there is nothing to reverse. To add undo, you layer another pattern on top called the <strong>Command pattern</strong>. Instead of observers directly doing things (like saving to a database), they create a "command" object &#x2014; a small object that knows two things: how to <em>do</em> the action, and how to <em>undo</em> it. A <code>CommandJournal</code> keeps a stack (like a history list) of every command. When the user presses "undo," you pop the last command off the stack and call its <code>UndoAsync()</code> method, which reverses what was done. This combination of Observer + Command + Journal is essentially a simplified version of a pattern called <strong>Event Sourcing</strong>.</p>
      <p class="body-text">But some things simply cannot be undone. If you already sent an email or an SMS, you cannot unsend it. For these situations you use <strong>compensation</strong> &#x2014; instead of reversing, you do a follow-up action that corrects the mistake. For example, sending a second email saying "Disregard the previous alert." In the code, you mark those commands as <code>IsReversible = false</code> so the undo system knows to apply compensation instead of true reversal. In large <strong>distributed systems</strong> (applications spread across multiple servers or services), this same idea is called the <strong>Saga pattern</strong> &#x2014; each part of the system knows how to "compensate" when something needs to be rolled back.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">UndoRedoWithObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Command abstraction with Execute and Undo
public interface IChatCommand
{
    string Description { get; }
    Task ExecuteAsync(CancellationToken ct);
    Task UndoAsync(CancellationToken ct);
    bool IsReversible { get; }
}

// Observer produces commands instead of executing actions directly
public sealed class AutoModerationObserver : IChatObserver
{
    private readonly ICommandJournal _journal;
    private readonly IModerationService _moderation;

    public async Task OnMessageReceivedAsync(ChatMessage message, CancellationToken ct)
    {
        var command = new ModerateMessageCommand(
            _moderation, message.RoomId, message.MessageId, message.Content);

        await command.ExecuteAsync(ct);
        await _journal.RecordAsync(command, ct); // Record for undo
    }
}

public sealed class ModerateMessageCommand : IChatCommand
{
    private readonly IModerationService _svc;
    private readonly string _roomId;
    private readonly Guid _messageId;
    private readonly string _content;

    public string Description =&gt; $"Moderate message {_messageId} in {_roomId}";
    public bool IsReversible =&gt; true; // Can undo by restoring message

    public async Task ExecuteAsync(CancellationToken ct)
    {
        var result = await _svc.EvaluateAsync(_content, ct);
        if (result.IsSpam)
        {
            await _svc.HideMessageAsync(_messageId, ct);
            await _svc.MuteSenderAsync(_roomId, _messageId, ct);
        }
    }

    public async Task UndoAsync(CancellationToken ct)
    {
        // Reverse: restore hidden message and unmute sender
        await _svc.RestoreMessageAsync(_messageId, ct);
        await _svc.UnmuteSenderAsync(_roomId, _messageId, ct);
    }
}

// Command journal supports undo &#x2014; stack-based history
public sealed class CommandJournal : ICommandJournal
{
    private readonly Stack&lt;IChatCommand&gt; _history = new();

    public async Task RecordAsync(IChatCommand command, CancellationToken ct)
        =&gt; _history.Push(command);

    public async Task UndoLastAsync(CancellationToken ct)
    {
        if (!_history.TryPop(out var command))
            throw new InvalidOperationException("Nothing to undo");

        if (!command.IsReversible)
            throw new InvalidOperationException(
                $"Cannot undo irreversible command: {command.Description}");

        await command.UndoAsync(ct);
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A strong answer recognises that Observer + Command + Journal is essentially a simplified <strong>Event Sourcing</strong> pattern. Event Sourcing means instead of saving "the current state," you save every event that ever happened. Want the current state? Replay all the events from the beginning. Want to undo something? Just replay everything except the last event. If undo/redo is a core requirement of the system, a senior engineer would recommend going straight to Event Sourcing rather than building a half-solution. They also mention that in systems spread across multiple services (microservices), the <strong>Saga pattern</strong> is the proper way to handle undo &#x2014; each service knows its own compensation action and publishes it when asked to roll back.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q8: Design a configuration change notification system using Observer <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-green">Design</span> &nbsp; Follow-up: How do you ensure consistency &#x2014; that all components see the same config version at the same time?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; show you know the framework already has this built in. Step 2 &#x2014; explain when the built-in solution is not enough. Step 3 &#x2014; explain the custom solution with priority ordering. Step 4 &#x2014; address the consistency follow-up: what happens when some components see the new config and others still see the old one?</div>
      <p class="body-text">The good news is that ASP.NET Core already has this built in via something called <code>IOptionsMonitor&lt;T&gt;</code>. It uses the Observer pattern internally &#x2014; you call <code>OnChange()</code> to subscribe, and it returns an <code>IDisposable</code> to unsubscribe. For simple cases, just use this directly. For more complex production needs &#x2014; version tracking, rollback support, or controlling which components update in which order &#x2014; you build a custom <code>ConfigWatcher&lt;T&gt;</code>. This is a background service that periodically checks the config store for changes. When it detects a new version, it notifies observers in a specific priority order: for example, risk limits must update BEFORE analytics dashboards.</p>
      <p class="body-text">The consistency problem is this: imagine you notify 5 components about a new config. The first 3 update successfully, but the 4th fails. Now components 1-3 are running on the new config and components 4-5 are still on the old config &#x2014; inconsistent behaviour. The solution is a <strong>two-phase approach</strong> (similar to how banks handle transfers). Phase 1: ask every observer "can you accept this new config?" &#x2014; they all check but do not apply yet. Phase 2: if everyone says yes, all apply the change at once. If anyone says no, everyone rolls back. The downside: if the app crashes between Phase 1 and Phase 2, you get stuck in a half-applied state &#x2014; this is a known limitation of this approach.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ConfigChangeNotification.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Configuration change event with version tracking
public record ConfigChangeEvent&lt;T&gt;(
    T OldValue, T NewValue, long Version,
    string ChangedBy, DateTime Timestamp) where T : class;

// Observer interface for config changes &#x2014; priority-ordered
public interface IConfigChangeObserver&lt;T&gt; where T : class
{
    Task OnConfigChangedAsync(ConfigChangeEvent&lt;T&gt; change, CancellationToken ct);
    int Priority { get; } // Lower = notified first
}

// Subject: watches config store and notifies observers in priority order
public sealed class ConfigWatcher&lt;T&gt; : BackgroundService where T : class, new()
{
    private readonly IConfigStore _store;
    private readonly SortedList&lt;int, IConfigChangeObserver&lt;T&gt;&gt; _observers = new();
    private T _currentConfig = new();
    private long _currentVersion = 0;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                var (newConfig, version) = await _store.GetAsync&lt;T&gt;(ct);
                if (version &gt; _currentVersion)
                {
                    var change = new ConfigChangeEvent&lt;T&gt;(
                        _currentConfig, newConfig, version, "ConfigStore", DateTime.UtcNow);

                    // Notify in priority order &#x2014; critical components first
                    foreach (var (_, observer) in _observers)
                        await observer.OnConfigChangedAsync(change, ct);

                    _currentConfig  = newConfig;
                    _currentVersion = version;
                }
                await Task.Delay(TimeSpan.FromSeconds(5), ct);
            }
            catch (OperationCanceledException) { break; }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Config polling failed");
                await Task.Delay(TimeSpan.FromSeconds(30), ct); // Back off on failure
            }
        }
    }
}

// Example: chat engine reconfigures moderation rules (high priority)
public sealed class ModerationConfigObserver : IConfigChangeObserver&lt;ChatConfig&gt;
{
    public int Priority =&gt; 1; // Notified first
    public async Task OnConfigChangedAsync(
        ConfigChangeEvent&lt;ChatConfig&gt; change, CancellationToken ct)
    {
        _logger.LogInformation("Updating moderation config: MaxMessageLength {Old} -&gt; {New}",
            change.OldValue.MaxMessageLength, change.NewValue.MaxMessageLength);
        await _moderationEngine.UpdateRulesAsync(change.NewValue, ct);
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A strong answer names the two-phase approach by its proper name: it mimics <strong>2PC (Two-Phase Commit)</strong>, which is a classic distributed systems technique for keeping multiple systems in sync. A great engineer also warns about the <strong>circuit breaker</strong> pattern here: if applying new config fails, the system should gracefully continue running with the old config rather than crashing. They also suggest using a mature, purpose-built config system for complex cases &#x2014; tools like etcd (a distributed key-value store used by Kubernetes), Consul (a service discovery and configuration tool), or Azure App Configuration &#x2014; rather than reinventing the wheel.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q9: How do you implement topic-based filtering in Observer? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-green">Design</span> &nbsp; Follow-up: What if observers want to subscribe to patterns like &#x201C;all public channels&#x201D; or &#x201C;all rooms with &gt; 100 members&#x201D;?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; explain the waste problem: if every observer gets every event, most of those notifications are useless. Step 2 &#x2014; the fix: use a dictionary where the key is the topic (e.g., chat room ID) and the value is the list of observers interested in that room. Step 3 &#x2014; some observers (like audit logs) need everything, so add a way to subscribe globally too. Step 4 &#x2014; for advanced pattern matching ("all public channels"), explain the performance cost and how to handle it.</div>
      <p class="body-text">Without topic filtering, if you have 5,000 chat rooms and 50 observers, every single message is broadcast to all 50 observers &#x2014; that is 250,000 calls per message, and most of them are wasted because each observer only cares about a few rooms. <strong>Topic-based filtering</strong> fixes this by using a dictionary (a lookup table) where the key is the room ID and the value is the list of observers interested in that room. Instead of <code>Subscribe(observer)</code>, you call <code>Subscribe("#general", observer)</code>. When a message arrives in #general, only observers registered for #general are called. For observers like audit loggers that need every message, there is a <code>SubscribeAll()</code> method &#x2014; they go into a separate "global" list that always gets called.</p>
      <p class="body-text">For pattern-based subscriptions like "all public channels" or "all rooms with more than 100 members," you use <strong>predicate-based filtering</strong> &#x2014; each subscription includes a function (a filter) that is evaluated on every incoming message. The problem is performance: if you have 500,000 subscriptions and 100,000 messages per second, you are running 50 billion filter checks per second, which is not realistic. The solution is a two-level approach: first look up by room ID (this is instant, like looking up a word in a dictionary), then only run the filter functions for observers that are interested in that room. A <strong>Bloom filter</strong> is an advanced data structure that lets you instantly answer "are there any subscribers for this room?" &#x2014; if the answer is no, you skip the whole process.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">TopicBasedChatRoom.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Topic-based subject: observers subscribe per room
public sealed class TopicBasedChatRoom : IChatMessageFeed
{
    // Key = roomId, Value = observers interested in that room
    private readonly ConcurrentDictionary&lt;string, ImmutableList&lt;IChatObserver&gt;&gt;
        _topicObservers = new();

    // Global observers (receive ALL updates &#x2014; audit, logging)
    private ImmutableList&lt;IChatObserver&gt; _globalObservers =
        ImmutableList&lt;IChatObserver&gt;.Empty;

    // Subscribe to specific room &#x2014; returns IDisposable for cleanup
    public IDisposable Subscribe(string roomId, IChatObserver observer)
    {
        _topicObservers.AddOrUpdate(
            roomId,
            _ =&gt; ImmutableList.Create(observer),
            (_, list) =&gt; list.Add(observer));

        return new SubscriptionToken(() =&gt;
            _topicObservers.AddOrUpdate(roomId,
                _ =&gt; ImmutableList&lt;IChatObserver&gt;.Empty,
                (_, list) =&gt; list.Remove(observer)));
    }

    // Subscribe to ALL rooms (for audit, logging, etc.)
    public IDisposable SubscribeAll(IChatObserver observer)
    {
        ImmutableInterlocked.Update(ref _globalObservers, list =&gt; list.Add(observer));
        return new SubscriptionToken(() =&gt;
            ImmutableInterlocked.Update(ref _globalObservers, list =&gt; list.Remove(observer)));
    }

    public async Task BroadcastMessageAsync(ChatMessage update, CancellationToken ct)
    {
        var tasks = new List&lt;Task&gt;();

        // Topic-specific observers (only those subscribed to this room)
        if (_topicObservers.TryGetValue(update.RoomId, out var topicObs))
            tasks.AddRange(topicObs.Select(obs =&gt; SafeNotifyAsync(obs, update, ct)));

        // Global observers (audit, logging &#x2014; always notified)
        tasks.AddRange(_globalObservers.Select(obs =&gt; SafeNotifyAsync(obs, update, ct)));

        await Task.WhenAll(tasks);
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer draws the connection to how major messaging systems work in the real world: this topic-based approach is exactly how <strong>Apache Kafka</strong> (which organises messages by partition key) and <strong>RabbitMQ</strong> (which routes messages via "topic exchanges" with routing keys) work at scale. You are essentially re-inventing the same routing logic that these systems have already solved. Knowing this shows that you understand how design patterns at the code level connect to infrastructure-level systems.</div>
    </div></div>
  </div>


  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q10: How do you handle backpressure in Observer?</div><div class="qa-meta"><span class="badge badge-green">Design</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Start with the analogy: what happens when a factory produces goods faster than the warehouse can store them? Then explain the code solution: use a buffer (a queue) between the producer and consumer. The producer puts items in the queue quickly; the consumer processes them at its own pace. Then explain what happens when the queue gets full.</div>
      <p class="body-text"><strong>Backpressure</strong> is the problem that happens when the publisher sends events faster than observers can process them. Imagine a fire hose pointed at a paper cup &#x2014; the cup cannot handle that flow rate. In code: the chat room sends 10,000 messages per second, but your <code>SlowAnalyticsObserver</code> takes 50ms per message &#x2014; it can only handle 20 per second. You need a buffer. The solution is a <code>Channel&lt;T&gt;</code> with a bounded capacity &#x2014; it is like a queue with a size limit. The observer's notification method just drops the update into the queue immediately (very fast, like handing off a package). A background worker reads from the queue and processes at its own pace. When the queue fills up, you have two choices: <code>DropOldest</code> (throw away the oldest unprocessed data &#x2014; acceptable for real-time data like prices where old data is stale) or <code>Wait</code> (pause the publisher until the consumer catches up &#x2014; this slows down the whole pipeline).</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">Backpressure.cs</span></div><div class="macos-body"><pre><code class="language-csharp">private readonly Channel&lt;ChatMessage&gt; _buffer =
    Channel.CreateBounded&lt;ChatMessage&gt;(new BoundedChannelOptions(10_000)
    { FullMode = BoundedChannelFullMode.DropOldest });

// Notification handler: non-blocking enqueue
public Task OnMessageReceivedAsync(ChatMessage update, CancellationToken ct) {
    _buffer.Writer.TryWrite(update);
    return Task.CompletedTask;
}

// Background: process at own pace
await foreach (var update in _buffer.Reader.ReadAllAsync(ct))
    await ProcessSlowly(update, ct);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A strong answer adds monitoring: track the queue depth (how full the buffer is) as a metric. When it exceeds 80% capacity, send an alert &#x2014; it means the observer is struggling to keep up and will soon start dropping data. If an observer consistently cannot keep up no matter how large the buffer is, that is a sign it needs its own dedicated infrastructure (its own separate service or message queue) rather than sharing the same process as the publisher.</div>
    </div></div>
  </div>

  <!-- Q11-Q15 Debugging -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q11: You have a multi-threaded chat message feed. Observers occasionally throw <code>InvalidOperationException: Collection was modified</code>. Where is the bug and how do you fix it? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-red">Debugging</span> &nbsp; Follow-up: How would you write a test that reliably reproduces this race condition?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; decode the error message: "collection was modified" only ever happens when you loop through a list AND change it at the same time. Step 2 &#x2014; identify the two threads involved: one thread is looping through the list to notify, another thread is adding or removing observers from that same list simultaneously. Step 3 &#x2014; the fix must prevent these two operations from happening on the same list at the same time.</div>
      <p class="body-text">The error message "Collection was modified; enumeration operation may not execute" is a very specific clue &#x2014; it means someone changed a list while another part of the code was looping through it. In .NET, a plain <code>List&lt;T&gt;</code> is explicitly <strong>not thread-safe</strong> (it is documented this way). Here is what happens: Thread A starts a <code>foreach</code> loop over the observer list to send notifications. Internally, .NET marks the list with a version number. At the exact same moment, Thread B calls <code>Subscribe()</code> and adds to the list &#x2014; this increments the version number. On Thread A's next loop step, it checks the version number, sees it changed, and throws the exception. This is called a <strong>race condition</strong> &#x2014; it only happens when two threads hit the exact same narrow window of time, which is why it often does not show up in simple tests.</p>
      <p class="body-text">There are three clean ways to fix this. (1) Use a <code>lock</code> &#x2014; simple but can cause a <strong>deadlock</strong> if an observer tries to subscribe/unsubscribe while receiving a notification. (2) Use <code>ConcurrentDictionary</code> &#x2014; a thread-safe version of a dictionary where adds and removes are safe; calling <code>.Values</code> gives you a snapshot safe to iterate. (3) Use <code>ImmutableList&lt;T&gt;</code> with <code>ImmutableInterlocked.Update</code> &#x2014; the most elegant approach. An immutable list is never changed in place; instead it is atomically replaced with a new version. Any thread that is already iterating keeps its own copy of the old version and is not affected.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ChatMessageSubject.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ============================================================
// BUG: Plain List&lt;T&gt; â€” NOT thread-safe
// ============================================================
public class ChatMessageSubject
{
    // Thread A iterates this while Thread B appends &#x2192; BOOM
    private readonly List&lt;IChatObserver&gt; _observers = new();

    public void Subscribe(IChatObserver observer)
    {
        _observers.Add(observer);      // Thread B path
    }

    public void Unsubscribe(IChatObserver observer)
    {
        _observers.Remove(observer);   // Thread C path
    }

    public void NotifyAll(ChatMessage message)
    {
        // Thread A: enumerator grabs version stamp here
        foreach (var observer in _observers)  // &lt;-- InvalidOperationException if list mutated mid-loop
        {
            observer.OnMessageReceived(message);
        }
    }
}

// ============================================================
// FIX 1: Lock snapshot before iterating (simplest)
// ============================================================
public class ChatMessageSubject_LockSnapshot
{
    private readonly List&lt;IChatObserver&gt; _observers = new();
    private readonly object _lock = new();

    public void Subscribe(IChatObserver observer)
    {
        lock (_lock) { _observers.Add(observer); }
    }

    public void Unsubscribe(IChatObserver observer)
    {
        lock (_lock) { _observers.Remove(observer); }
    }

    public void NotifyAll(ChatMessage message)
    {
        IChatObserver[] snapshot;
        lock (_lock)
        {
            // Copy under lock â€” tiny critical section, then iterate outside
            snapshot = _observers.ToArray();
        }

        // Iterate snapshot â€” safe even if Subscribe/Unsubscribe runs concurrently
        foreach (var observer in snapshot)
            observer.OnMessageReceived(message);
    }
}

// ============================================================
// FIX 2: ImmutableList + ImmutableInterlocked (lock-free, best for read-heavy)
// ============================================================
public class ChatMessageSubject_LockFree
{
    // Volatile reference â€” replaced atomically, never mutated in place
    private ImmutableList&lt;IChatObserver&gt; _observers = ImmutableList&lt;IChatObserver&gt;.Empty;

    public void Subscribe(IChatObserver observer)
    {
        // Compare-and-swap loop: atomically appends to the immutable list
        ImmutableInterlocked.Update(ref _observers, list =&gt; list.Add(observer));
    }

    public void Unsubscribe(IChatObserver observer)
    {
        ImmutableInterlocked.Update(ref _observers, list =&gt; list.Remove(observer));
    }

    public void NotifyAll(ChatMessage message)
    {
        // Capture the current reference â€” this is an O(1) snapshot
        var snapshot = _observers;   // reading a reference is atomic on 64-bit CLR
        foreach (var observer in snapshot)
            observer.OnMessageReceived(message);
    }
}

// ============================================================
// TEST: Reliably reproduce the race condition
// ============================================================
[Fact]
public async Task Subscribe_DuringNotify_ShouldNotThrow()
{
    var subject = new ChatMessageSubject(); // buggy version
    // Simplified ChatMessage for this test â€” full version has required init properties
    var message = new ChatMessage { RoomId = "#general", Content = "Hello team!" };
    var errors  = new ConcurrentBag&lt;Exception&gt;();

    // Pre-populate so iteration takes non-trivial time
    for (int i = 0; i &lt; 200; i++)
        subject.Subscribe(new NoOpObserver());

    // Run 100 concurrent rounds of notify + subscribe
    var tasks = Enumerable.Range(0, 100).Select(_ =&gt; Task.Run(() =&gt;
    {
        try   { subject.NotifyAll(message); }
        catch (Exception ex) { errors.Add(ex); }

        subject.Subscribe(new NoOpObserver());
    }));

    await Task.WhenAll(tasks);

    // With buggy code: errors.Count &gt; 0 with InvalidOperationException
    // With fixed code:  errors.Count == 0
    Assert.Empty(errors);
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A good engineer grabs a <code>lock</code>. A great engineer knows the snapshot trick: take the lock just long enough to copy the list, then release the lock before actually calling any observers. This matters because observer callbacks can be slow (database calls, network calls, etc.) &#x2014; if you hold the lock the whole time, no one else can subscribe or unsubscribe during that entire wait. The best engineers reach for <code>ImmutableInterlocked.Update</code> because it is lock-free, makes the code self-documenting ("this list is never changed, only replaced"), and performs best for systems that read far more often than they write &#x2014; which is exactly what most event notification systems do.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q12: Observers are being silently skipped during notification. A forward-iterating loop removes failing observers with <code>RemoveAt(i)</code>. What is the exact bug and what are three ways to fix it? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-red">Debugging</span> &nbsp; Follow-up: How would you write a regression test to prove this bug exists before fixing it?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; think through what happens physically when you remove an item from a list while looping forward. Draw it out: [A, B, C, D, E]. Remove B at position 1. The list becomes [A, C, D, E]. The loop counter advances to position 2 &#x2014; which is now D, not C. C was skipped. Step 2 &#x2014; explain why this is particularly bad in Observer: there is no error, no crash, no log. The observer just silently never gets notified. Step 3 &#x2014; present the three fixes.</div>
      <p class="body-text">This is a classic bug when you try to remove items from a list while looping through it at the same time. Here is exactly what happens with list [A, B, C, D, E]: you are at position 1 (that is B), B throws an error, you call <code>RemoveAt(1)</code>. The list physically reshuffles: C slides from position 2 to position 1, D slides from 3 to 2, E slides from 4 to 3. The list is now [A, C, D, E]. Your loop counter increments to 2 &#x2014; but position 2 is now D. <strong>C was completely skipped.</strong> It never received the notification. No crash, no error message, no log entry. The loop just moved on as if nothing happened.</p>
      <p class="body-text">In a chat system, this means a live observer silently stops receiving notifications. This could mean missed @mention alerts for users, inaccurate unread counts, or gaps in the audit trail. These failures might not be discovered until hours or days later when someone notices the data looks wrong.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ChatRoomSubject.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ============================================================
// BUG: Forward iteration + RemoveAt â€” skips observers
// ============================================================
public class ChatRoomSubject_Buggy
{
    private readonly List&lt;IChatObserver&gt; _observers = new() { A, B, C, D, E };
    //                                                Index:   0  1  2  3  4

    public void NotifyAll(ChatMessage message)
    {
        for (int i = 0; i &lt; _observers.Count; i++)
        {
            try
            {
                _observers[i].OnMessageReceived(message);
            }
            catch
            {
                // Developer intent: remove broken observer and continue
                _observers.RemoveAt(i);
                // BUG: list is now [A, C, D, E]
                //                   0  1  2  3
                // i++ makes i=2, which hits D
                // C (now at index 1) is COMPLETELY SKIPPED
            }
        }
    }
}

// ============================================================
// Execution trace with list [A, B, C, D, E]:
//
//  i=0 &#x2192; A.OnMessageReceived() &#x2192; OK
//  i=1 &#x2192; B.OnMessageReceived() &#x2192; throws &#x2192; RemoveAt(1)
//         list is now [A, C, D, E]  (C slid to index 1)
//  i++ &#x2192; i=2
//  i=2 &#x2192; D.OnMessageReceived() &#x2192; OK   (C was SKIPPED)
//  i=3 &#x2192; E.OnMessageReceived() &#x2192; OK
//  loop ends, C never notified
// ============================================================

// ============================================================
// FIX 1: Decrement i after removal (compensating adjustment)
// ============================================================
public void NotifyAll_Fix1(ChatMessage message)
{
    for (int i = 0; i &lt; _observers.Count; i++)
    {
        try
        {
            _observers[i].OnMessageReceived(message);
        }
        catch
        {
            _observers.RemoveAt(i);
            i--;  // counteract the upcoming i++ so we re-examine the shifted element
        }
    }
}

// ============================================================
// FIX 2: Reverse iteration (removals only affect already-visited indices)
// ============================================================
public void NotifyAll_Fix2(ChatMessage message)
{
    // Iterate from end to start â€” removing at index i does not affect indices 0..i-1
    for (int i = _observers.Count - 1; i &gt;= 0; i--)
    {
        try
        {
            _observers[i].OnMessageReceived(message);
        }
        catch
        {
            _observers.RemoveAt(i);  // Safe: only affects already-visited higher indices
        }
    }
}

// ============================================================
// FIX 3: Snapshot + separate dead-observer list (cleanest, also thread-safe)
// ============================================================
public void NotifyAll_Fix3(ChatMessage message)
{
    var snapshot  = _observers.ToList();         // iterate the snapshot
    var toRemove  = new List&lt;IChatObserver&gt;();  // collect failures separately

    foreach (var observer in snapshot)
    {
        try   { observer.OnMessageReceived(message); }
        catch { toRemove.Add(observer); }
    }

    // Apply removals after iteration is complete â€” zero index-shift risk
    foreach (var dead in toRemove)
        _observers.Remove(dead);
}

// ============================================================
// REGRESSION TEST: proves the bug exists (red before fix, green after)
// ============================================================
[Fact]
public void NotifyAll_WhenObserverThrows_ShouldNotSkipSubsequentObserver()
{
    // Arrange
    var subject         = new ChatRoomSubject_Buggy();
    var notifiedRooms = new List&lt;string&gt;();

    var throwingObserver = new LambdaObserver(_ =&gt; throw new Exception("simulated failure"));
    var skippedObserver  = new LambdaObserver(m =&gt; notifiedRooms.Add(m.RoomId));

    subject.Subscribe(throwingObserver);
    subject.Subscribe(skippedObserver);  // sits at index 1, directly after the thrower

    // Act
    subject.NotifyAll(new ChatMessage { RoomId = "#general", Content = "Hello team!" });

    // Assert: with the bug, notifiedRooms is empty â€” skippedObserver was never called
    Assert.Contains("#general", notifiedRooms);
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A good engineer finds the bug when shown the trace. A great engineer immediately recognises it as a member of the "modify collection during iteration" bug family and goes straight to Fix 3 &#x2014; the snapshot approach &#x2014; because it solves two problems at once: the index-shift problem AND the thread-safety problem. The snapshot approach also makes the intent cleaner and more readable: "notification" and "cleanup" are two completely separate things and should not be tangled together in the same loop.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q13: Your async Observer implementation uses <code>Task.WhenAll</code> to fan out notifications. In production you are seeing audit records written out of order â€” update N+1 is committed before update N. How do you diagnose and fix this without sacrificing parallelism? <span class="badge badge-blue">Advanced</span></div><div class="qa-meta"><span class="badge badge-red">Debugging</span> &nbsp; Follow-up: How do you maintain per-observer ordering without sacrificing cross-observer parallelism?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; <code>Task.WhenAll</code> runs multiple tasks in parallel. It does NOT guarantee any ordering. So the ordering problem cannot be caused by parallel execution within a single notification round. Step 2 &#x2014; the problem must be between rounds: the publisher fires update N+1 before update N has fully finished. Now both rounds are running at the same time, and whichever database write finishes first "wins." Step 3 &#x2014; the fix: give each observer its own FIFO (first-in, first-out) queue so it always processes updates in the order they arrived.</div>
      <p class="body-text">The key misconception here is that <code>Task.WhenAll</code> guarantees ordering. It does not &#x2014; it only waits for multiple tasks to complete, in any order. Here is what actually happens: the chat room receives messages at 50 times per second (50 Hz). Each <code>Task.WhenAll</code> round takes about 30ms because the <code>ChatAuditLogger</code> has to write to a database. That means round N is still running when round N+1 starts. Both rounds are now running at the same time. Round N's database write is waiting for a connection. Round N+1's database write grabs a different connection and finishes first. Result: the audit log shows "message at time 2" before "message at time 1" &#x2014; they are out of order. This is not a bug in Observer itself &#x2014; it is the publisher never waiting for the previous round to finish.</p>
      <p class="body-text">The fix: give each observer its own dedicated queue (a <code>Channel&lt;T&gt;</code>). The publisher just drops updates into each observer's queue instantly (no waiting). Each observer has its own background worker that reads from its queue and processes in strict arrival order &#x2014; this is called <strong>FIFO (First-In, First-Out)</strong> ordering. Different observers' workers run independently in parallel &#x2014; so cross-observer parallelism is preserved. The <code>SingleReader = true</code> setting is important: it tells the Channel that only one consumer ever reads from it, which allows faster lock-free reads.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">AsyncChatRoomSubject.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ============================================================
// BUG: Fire-and-forget publish â€” overlapping Task.WhenAll rounds
// ============================================================
public class ChatRoomSubject_Buggy
{
    private readonly List&lt;IAsyncChatObserver&gt; _observers = new();

    // Called at 50 Hz â€” does NOT await completion of previous round
    public async Task PublishAsync(ChatMessage message)
    {
        // BUG: if this takes 30ms and is called every 20ms,
        // round N+1 starts while round N is still running.
        // ChatAuditLogger's DB writes can complete out of sequence.
        var tasks = _observers.Select(o =&gt; o.OnMessageReceivedAsync(message));
        await Task.WhenAll(tasks);  // but nobody awaits THIS before calling again
    }
}

// Usage that triggers the bug:
public async Task StreamMessagesAsync(IEnumerable&lt;ChatMessage&gt; messageStream)
{
    foreach (var message in messageStream)
    {
        // Fire without await â€” each PublishAsync starts before previous finishes
        _ = subject.PublishAsync(message);   // &lt;-- root cause of ordering loss
    }
}

// ============================================================
// FIX: Per-observer Channel&lt;T&gt; â€” FIFO queue per observer
// ============================================================
public class OrderedAsyncObserver : IAsyncDisposable
{
    private readonly Channel&lt;ChatMessage&gt; _channel;
    private readonly IAsyncChatObserver _inner;
    private readonly Task _consumerTask;

    public OrderedAsyncObserver(IAsyncChatObserver inner, int capacity = 1000)
    {
        _inner   = inner;
        _channel = Channel.CreateBounded&lt;ChatMessage&gt;(new BoundedChannelOptions(capacity)
        {
            // SingleReader guarantees strictly sequential processing â€” no parallel
            // consumption within the same observer's queue
            SingleReader = true,
            FullMode     = BoundedChannelFullMode.Wait
        });

        // One consumer loop per observer â€” runs independently of all other observers
        _consumerTask = Task.Run(ConsumeAsync);
    }

    // Publisher enqueues â€” O(1), never blocks (unless queue full)
    public ValueTask EnqueueAsync(ChatMessage message, CancellationToken ct = default)
        =&gt; _channel.Writer.WriteAsync(message, ct);

    private async Task ConsumeAsync()
    {
        // Reads from channel in strict FIFO order â€” guarantees sequential processing
        await foreach (var msg in _channel.Reader.ReadAllAsync())
        {
            try   { await _inner.OnMessageReceivedAsync(msg); }
            catch { /* log, dead-letter, etc. */ }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _channel.Writer.Complete();
        await _consumerTask;  // drain the queue before shutting down
    }
}

// ============================================================
// Publisher: enqueue to all observers' channels simultaneously (parallel)
//            each observer's channel processes them in order (sequential per observer)
// ============================================================
public class ChatRoomSubject_Fixed
{
    private readonly List&lt;OrderedAsyncObserver&gt; _observers = new();

    public async Task PublishAsync(ChatMessage message)
    {
        // Fan-out enqueue â€” still parallel across observers
        // Each enqueue is O(1); observers process at their own pace in FIFO order
        var enqueues = _observers.Select(o =&gt; o.EnqueueAsync(message).AsTask());
        await Task.WhenAll(enqueues);
    }
}

// ============================================================
// ADVANCED: Per-room ordering with cross-room parallelism
// ============================================================
public class RoomOrderedNotifier
{
    // One semaphore per room â€” #general and #engineering process in parallel,
    // but #general messages are serialised relative to each other
    private readonly ConcurrentDictionary&lt;string, SemaphoreSlim&gt; _semaphores = new();

    public async Task NotifyOrderedAsync(ChatMessage message, IAsyncChatObserver observer)
    {
        var sem = _semaphores.GetOrAdd(message.RoomId, _ =&gt; new SemaphoreSlim(1, 1));
        await sem.WaitAsync();
        try   { await observer.OnMessageReceivedAsync(message); }
        finally { sem.Release(); }
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A good engineer adds <code>await</code> to make each notification round wait for the previous one &#x2014; this fixes the ordering but completely kills parallelism (now everything runs one at a time). A great engineer recognises this is a per-observer ordering problem, not a global one. Different observers can still run in parallel with each other &#x2014; you only need ordering within each individual observer's queue. This is exactly how <strong>Apache Kafka</strong> works: messages are ordered within a partition, but different partitions process in parallel. Each observer is essentially its own "partition consumer."</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q14: Everything works in development. In production, after approximately one hour of operation, <code>MentionNotifier</code> and <code>UnreadCountTracker</code> silently stop processing. <code>ChatAuditLogger</code> continues working. No exceptions appear in the logs. How do you diagnose this? <span class="badge badge-blue">Advanced</span></div><div class="qa-meta"><span class="badge badge-red">Debugging</span> &nbsp; Follow-up: How would you add monitoring to prevent this from happening again?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; "no exceptions in logs" is a RED FLAG. It does not mean no exceptions happened &#x2014; it means exceptions are happening but being silently eaten by an empty catch block. Step 2 &#x2014; two observers fail, one succeeds. What do the two failing ones have in common that the passing one does not? They probably share a resource. Step 3 &#x2014; "after ~1 hour" is a major clue: this is a resource that starts failing after about an hour of idling. Database connections time out, network sockets get exhausted &#x2014; both take about that long.</div>
      <p class="body-text">There are two bugs working together. Bug 1: both failing observers have an <strong>empty catch block</strong> &#x2014; code like <code>catch { }</code> with nothing inside. When an exception happens, it is silently swallowed. No log, no crash, no alert. The observer keeps running the next time a message comes in, but it does nothing. This is why "no exceptions in logs" is actually a warning sign, not reassurance &#x2014; it often means errors are being hidden.</p>
      <p class="body-text">Bug 2: the actual error being hidden. The <code>MentionNotifier</code> holds onto a database connection (<code>DbContext</code>) that was created at app startup. After about an hour with no database activity, the database server quietly closes the connection on its end (this is a standard database idle timeout). The next time the observer tries to use it, the connection is dead &#x2014; it throws an error that gets silently swallowed. The <code>UnreadCountTracker</code> has a different problem: it creates a new <code>HttpClient</code> object every time with <code>new HttpClient()</code>. Each new <code>HttpClient</code> opens a new network socket. After an hour of 50 updates per second, the system has thousands of old sockets stuck in a "waiting to close" state &#x2014; the socket pool is exhausted. The fix: use <code>IDbContextFactory&lt;T&gt;</code> (creates a fresh connection per use) and <code>IHttpClientFactory</code> (manages socket reuse properly).</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MentionNotifier.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ============================================================
// BUG 1: Empty catch â€” swallows all exceptions silently
// ============================================================
public class MentionNotifier_Buggy : IChatObserver
{
    private readonly ChatDbContext _dbContext;  // BUG: injected as singleton/scoped from root

    public MentionNotifier_Buggy(ChatDbContext dbContext)
    {
        _dbContext = dbContext;
        // If this observer is registered as Singleton in DI, _dbContext is resolved
        // from the root scope. After ~1 hour the database server closes the idle
        // TCP connection. Next call throws ObjectDisposedException or
        // InvalidOperationException("connection is broken"). Caught silently below.
    }

    public void OnMessageReceived(ChatMessage message)
    {
        try
        {
            var alert = new MentionAlert { RoomId = message.RoomId, Content = message.Content };
            _dbContext.MentionAlerts.Add(alert);
            _dbContext.SaveChanges();
        }
        catch
        {
            // BUG: empty catch â€” ObjectDisposedException/SqlException disappears here.
            // No log. No metric. No re-throw. Observer appears "alive" but does nothing.
        }
    }
}

// ============================================================
// BUG 2: HttpClient socket exhaustion (UnreadCountTracker)
// ============================================================
public class UnreadCountTracker_Buggy : IChatObserver
{
    public void OnMessageReceived(ChatMessage message)
    {
        try
        {
            // new HttpClient() per call = new socket per call
            // Sockets linger in TIME_WAIT for ~4 minutes (OS-level)
            // After ~1 hour of 50 Hz message updates: socket pool exhausted
            using var client   = new HttpClient();
            var result = client.GetAsync($"https://chat-api/unread/{message.RoomId}").Result;
        }
        catch
        {
            // BUG: SocketException swallowed â€” observer silently stops working
        }
    }
}

// ============================================================
// FIX: IDbContextFactory + IHttpClientFactory + structured logging
// ============================================================
public class MentionNotifier_Fixed : IChatObserver
{
    private readonly IDbContextFactory&lt;ChatDbContext&gt; _dbFactory;
    private readonly ILogger&lt;MentionNotifier_Fixed&gt; _logger;

    public MentionNotifier_Fixed(
        IDbContextFactory&lt;ChatDbContext&gt; dbFactory,
        ILogger&lt;MentionNotifier_Fixed&gt; logger)
    {
        _dbFactory = dbFactory;
        _logger    = logger;
    }

    public void OnMessageReceived(ChatMessage message)
    {
        try
        {
            // Fresh DbContext per operation â€” its own connection, its own lifetime
            using var db    = _dbFactory.CreateDbContext();
            var alert = new MentionAlert { RoomId = message.RoomId, Content = message.Content };
            db.MentionAlerts.Add(alert);
            db.SaveChanges();
        }
        catch (Exception ex)
        {
            // RULE: catch without log = code review rejection
            _logger.LogError(ex,
                "MentionNotifier failed for room {RoomId} with content {Content}",
                message.RoomId, message.Content);

            // Decide: swallow (observer failure is non-critical) or re-throw (critical)
            // For audit: re-throw so the subject knows. For non-critical alerts: log + continue.
        }
    }
}

public class UnreadCountTracker_Fixed : IChatObserver
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly ILogger&lt;UnreadCountTracker_Fixed&gt; _logger;

    public UnreadCountTracker_Fixed(
        IHttpClientFactory httpClientFactory,
        ILogger&lt;UnreadCountTracker_Fixed&gt; logger)
    {
        _httpClientFactory = httpClientFactory;
        _logger            = logger;
    }

    public void OnMessageReceived(ChatMessage message)
    {
        try
        {
            // IHttpClientFactory manages connection pool lifetimes â€” no socket exhaustion
            // Connections are rotated every 2 minutes (default) to handle DNS changes
            var client = _httpClientFactory.CreateClient("ChatApi");
            var result = client.GetAsync($"/unread/{message.RoomId}").Result;
            result.EnsureSuccessStatusCode();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,
                "UnreadCountTracker HTTP call failed for {RoomId}", message.RoomId);
        }
    }
}

// ============================================================
// Subject-level defensive wrapper: every observer wrapped in telemetry
// ============================================================
public class ResilientChatRoomSubject
{
    private readonly IReadOnlyList&lt;IChatObserver&gt; _observers;
    private readonly ILogger _logger;
    private readonly Counter&lt;int&gt; _failureCounter;  // OpenTelemetry metric

    public void NotifyAll(ChatMessage message)
    {
        foreach (var observer in _observers)
        {
            try
            {
                observer.OnMessageReceived(message);
            }
            catch (Exception ex)
            {
                // Subject catches + logs + emits metric â€” observer failure never
                // prevents other observers from running
                var observerName = observer.GetType().Name;
                _logger.LogError(ex, "Observer {Observer} threw on {RoomId}", observerName, message.RoomId);
                _failureCounter.Add(1, new("observer", observerName), new("room", message.RoomId));
                // Alert: if same observer fails 3+ times in 60s, page on-call
            }
        }
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A good engineer finds the empty catch block and adds logging. A great engineer hears "no exceptions in logs" and immediately thinks "that is the bug &#x2014; something is swallowing exceptions." They also establish a team rule: any <code>catch</code> block without at least one log statement is automatically rejected in code review. They also recognise the two specific resource lifetime bugs by name: the <strong>captive dependency anti-pattern</strong> (a short-lived resource like a DbContext being held by a long-lived singleton) and <strong>socket exhaustion from <code>new HttpClient()</code></strong>. These bugs are nearly invisible in development because your local database does not idle out and your test traffic is too low to exhaust sockets &#x2014; they only appear in production after the system has been running for a while.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q15: Your chat system has four observers all writing to the same SQL Server database. Under load, using <code>Task.WhenAll</code> for parallel notification, you see frequent deadlock victims in the database error log. How do you diagnose the deadlock and what are three architectural fixes? <span class="badge badge-blue">Expert</span></div><div class="qa-meta"><span class="badge badge-red">Debugging</span> &nbsp; Follow-up: How would you redesign to eliminate deadlocks while maintaining consistency?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; explain what a deadlock is in plain terms: two database transactions each waiting for a lock the other one holds, so both freeze forever. Step 2 &#x2014; identify how this happens with four parallel observers: they all start transactions at the same time and might try to lock the same tables in different orders. Step 3 &#x2014; present three fixes, from simplest (run one at a time) to most elegant (redesign so each observer only touches its own tables).</div>
      <p class="body-text">A <strong>database deadlock</strong> is like this: Observer A locks Table 1 and then needs Table 2. At the exact same time, Observer B locks Table 2 and then needs Table 1. Neither can proceed &#x2014; they are both waiting for each other forever. SQL Server detects this cycle and picks a "loser" (called the <strong>deadlock victim</strong>) &#x2014; it kills that transaction and throws error 1205. With four observers running in parallel via <code>Task.WhenAll</code>, all four start database transactions simultaneously. Observer A locks the Alerts table while Observer B locks the UnreadCounts table. Then A needs UnreadCounts and B needs Alerts &#x2014; classic deadlock.</p>
      <p class="body-text">The problem gets worse at high frequency: at 50 messages per second, new transactions start before old ones finish, so there are always multiple transactions overlapping. The root cause is architectural: parallel writers sharing the same database tables without a consistent <strong>locking order</strong> (meaning: always lock tables in the same sequence â€” if every observer always locks Table 1 before Table 2, no circular wait can form). The solution must make sure each observer only ever touches tables that no other observer touches &#x2014; the <strong>"shared-nothing" principle</strong>.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DeadlockScenario.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// ============================================================
// THE DEADLOCK SCENARIO
// ============================================================
// Task.WhenAll fires all four observers simultaneously:
//
//  MentionNotifier         UnreadCountTracker
//  BEGIN TRANSACTION          BEGIN TRANSACTION
//  LOCK Alerts (row X)        LOCK UnreadCounts (row Y)
//  SELECT Users               UPDATE UnreadCounts (row Y) &#x2192; needs Alerts lock
//  &#x2190; waiting for UnreadCounts &#x2192;   &#x2190; waiting for Alerts &#x2192;
//          DEADLOCK &#x2014; SQL Server kills one as victim (error 1205)
//
// Timeline:
//   t=0ms   Task.WhenAll starts both transactions
//   t=2ms   MentionNotifier:         INSERT INTO Alerts &#x2192; acquires lock on Alerts(#general)
//   t=2ms   UnreadCountTracker: UPDATE UnreadCounts &#x2192; acquires lock on UnreadCounts(#general)
//   t=4ms   MentionNotifier:         SELECT Users WHERE RoomId='#general'
//              &#x2192; needs shared lock on Users &#x2014; blocked by UnreadCountTracker
//   t=4ms   UnreadCountTracker: UPDATE Alerts (cascade) &#x2192; needs lock on Alerts(#general)
//              &#x2192; BLOCKED by MentionNotifier
//   t=5ms   SQL Server detects cycle &#x2192; kills MentionNotifier's transaction
//              &#x2192; SqlException 1205 thrown &#x2192; if no retry, alert is LOST

// ============================================================
// FIX 1: Sequential notification â€” simplest, eliminates all parallelism
// ============================================================
public class ChatRoomSubject_Sequential
{
    private readonly IReadOnlyList&lt;IAsyncChatObserver&gt; _observers;

    public async Task NotifyAllAsync(ChatMessage message)
    {
        // Run observers one at a time â€” no parallel transactions, no deadlock
        // Trade-off: notification latency = sum of all observer latencies
        foreach (var observer in _observers)
            await observer.OnMessageReceivedAsync(message);
    }
}

// ============================================================
// FIX 2: Polly retry on deadlock (error 1205) with exponential backoff + jitter
// ============================================================
public class DeadlockResilientObserver : IAsyncChatObserver
{
    private readonly IAsyncChatObserver _inner;
    private readonly ILogger _logger;

    private static readonly AsyncRetryPolicy _deadlockPolicy =
        Policy
            .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == 1205)  // 1205 = deadlock victim
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: attempt =&gt;
                    TimeSpan.FromMilliseconds(Math.Pow(2, attempt) * 50   // exponential base
                    + Random.Shared.Next(0, 50)),                          // jitter prevents thundering herd
                onRetry: (ex, delay, attempt, _) =&gt;
                    _logger.LogWarning("Deadlock on attempt {Attempt}, retrying in {Delay}ms",
                        attempt, delay.TotalMilliseconds));

    public async Task OnMessageReceivedAsync(ChatMessage message)
    {
        await _deadlockPolicy.ExecuteAsync(() =&gt; _inner.OnMessageReceivedAsync(message));
    }
}

// ============================================================
// FIX 3: Outbox pattern with Channel â€” decouple notification from DB write
// ============================================================
// Principle: observers do NOT write to DB during notification.
// They enqueue a message. A single background writer drains the queue
// sequentially â€” one writer, one transaction scope, zero deadlock risk.

public class OutboxChatRoomSubject
{
    // One bounded channel per observer â€” FIFO, backpressure-aware
    private readonly Channel&lt;ChatMessage&gt; _alertChannel     = Channel.CreateBounded&lt;ChatMessage&gt;(10_000);
    private readonly Channel&lt;ChatMessage&gt; _unreadChannel    = Channel.CreateBounded&lt;ChatMessage&gt;(10_000);
    private readonly Channel&lt;ChatMessage&gt; _auditChannel     = Channel.CreateBounded&lt;ChatMessage&gt;(10_000);
    private readonly Channel&lt;ChatMessage&gt; _moderationChannel = Channel.CreateBounded&lt;ChatMessage&gt;(10_000);

    public async Task NotifyAllAsync(ChatMessage message)
    {
        // Fan-out enqueue: O(1) per observer, no DB transaction, no lock
        await Task.WhenAll(
            _alertChannel.Writer.WriteAsync(message).AsTask(),
            _unreadChannel.Writer.WriteAsync(message).AsTask(),
            _auditChannel.Writer.WriteAsync(message).AsTask(),
            _moderationChannel.Writer.WriteAsync(message).AsTask()
        );
        // Notification is now DONE from publisher's perspective â€” microseconds
    }
}

// Each observer has its own consumer â€” processes its channel sequentially
public class MentionAlertChannelConsumer : BackgroundService
{
    private readonly Channel&lt;ChatMessage&gt; _channel;
    private readonly IDbContextFactory&lt;ChatDbContext&gt; _dbFactory;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        await foreach (var msg in _channel.Reader.ReadAllAsync(ct))
        {
            // Each write is its own short transaction â€” no shared lock contention
            using var db = _dbFactory.CreateDbContext();
            db.MentionAlerts.Add(new MentionAlert { RoomId = msg.RoomId, Content = msg.Content });
            await db.SaveChangesAsync(ct);
            // Transaction committed, lock released IMMEDIATELY â€” no cross-observer overlap
        }
    }
}

// ============================================================
// SHARED-NOTHING PRINCIPLE: observer table ownership map
// ============================================================
// Observer                      Owns Tables           Never touches
// MentionNotifier            Alerts                UnreadCounts, AuditLog, Moderation
// UnreadCountTracker    UnreadCounts          Alerts, AuditLog, Moderation
// ChatAuditLogger            AuditLog              Alerts, UnreadCounts, Moderation
// AutoModerationObserver      ModerationEvents      Alerts, UnreadCounts, AuditLog
//
// Result: zero shared table access = zero possibility of cross-observer deadlock</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A good engineer adds a Polly retry policy (automatically retry when a deadlock occurs) and moves on. A great engineer applies the <strong>"shared-nothing" principle</strong> as the design rule: each observer must exclusively own its own tables. They also explain the Outbox + Channel pattern as the cleanest long-term solution: observers no longer write to the database during notification &#x2014; they just drop items into a queue. A separate single-threaded worker for each observer drains its queue and writes to the database one at a time. One writer, no parallel transactions, zero deadlock risk. They also mention that retries need <strong>exponential backoff with jitter</strong> (adding random delay): without it, all the retrying transactions start again at the same instant and immediately deadlock again.</div>
    </div></div>
  </div>

  <!-- Q16-Q20 Comparison -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q16: Observer vs C# events â€” when to use each? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-purple">Comparison</span> &nbsp; Follow-up: Can you mix both approaches?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Start by explaining that C# events are actually Observer built into the language itself &#x2014; they are not a separate thing. Then compare: where do events win? Where does the interface-based Observer win? The answer: events win for simple, one-off UI wiring. Interface Observer wins everywhere else, especially when you need async code, testing, or dependency injection.</div>
      <p class="body-text">C# events (<code>event EventHandler&lt;T&gt;</code>) are Observer built directly into the C# language. When you write <code>button.Click += handler</code>, the <code>+=</code> is just a shortcut for "add this observer." When you write <code>-=</code>, you unsubscribe. This is completely free &#x2014; no interface to create, no infrastructure to build. For simple, same-layer UI wiring (like a search box notifying a suggestion list when text changes), a C# event is perfect. It is one line and requires nothing extra.</p>
      <p class="body-text">The interface-based Observer (<code>IChatObserver</code>) wins in every other situation. When you use <strong>DI (Dependency Injection)</strong>, the framework can automatically find and wire up all your observer implementations &#x2014; no manual subscribe calls needed anywhere. Async code is clean: <code>Task OnMessageReceivedAsync(...)</code> with full <code>await</code> support (C# events make async very tricky). Testing is easy: you can create a fake observer with a mocking library. Lifetime management is clean: one <code>Dispose()</code> call to unsubscribe, instead of remembering to manually do <code>-=</code> everywhere.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">EventsVsObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// â”€â”€ STYLE 1: C# event â€” great for simple UI notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public class ChatSearchBox
{
    // Language-level Observer; no interface needed for same-layer UI
    public event EventHandler&lt;string&gt;? QueryChanged;

    private string _query = string.Empty;
    public string Query
    {
        get =&gt; _query;
        set
        {
            _query = value;
            QueryChanged?.Invoke(this, value); // raise â€” safe null-conditional
        }
    }
}

// Subscriber wires up with +=
var box = new ChatSearchBox();
box.QueryChanged += (_, q) =&gt; suggestionList.Filter(q);  // simple, fine here

// â”€â”€ STYLE 2: Interface Observer â€” async, DI, testable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public interface IChatObserver
{
    Task OnMessageReceivedAsync(string roomId, string content, CancellationToken ct);
}

public class ChatMessageFeed
{
    private readonly List&lt;IChatObserver&gt; _observers;

    // DI injects ALL registered IChatObserver implementations
    public ChatMessageFeed(IEnumerable&lt;IChatObserver&gt; observers)
        =&gt; _observers = observers.ToList();

    public async Task PublishAsync(string roomId, string content, CancellationToken ct)
    {
        // Async fan-out â€” all observers awaited, exceptions observable
        var tasks = _observers.Select(o =&gt; o.OnMessageReceivedAsync(roomId, content, ct));
        await Task.WhenAll(tasks);
    }
}

// DI registration â€” zero subscribe calls in business code
builder.Services.AddSingleton&lt;IChatObserver, AlertObserver&gt;();
builder.Services.AddSingleton&lt;IChatObserver, AuditObserver&gt;();
builder.Services.AddSingleton&lt;IChatObserver, DashboardObserver&gt;();
builder.Services.AddSingleton&lt;ChatMessageFeed&gt;();

// â”€â”€ BRIDGE: connecting legacy C# event layer â†’ interface Observer layer â”€â”€â”€â”€â”€â”€
public class EventToObserverBridge : IDisposable
{
    private readonly ChatMessageFeed _feed;
    private readonly LegacyWebhookSource _source;

    public EventToObserverBridge(LegacyWebhookSource source, ChatMessageFeed feed)
    {
        _source = source;
        _feed   = feed;
        // Wire legacy event into async pipeline via fire-and-forget helper
        _source.MessageReceived += OnLegacyMessageReceived;
    }

    private void OnLegacyMessageReceived(object? sender, MessageEventArgs e)
        // Use Task.Run to bridge sync event into async pipeline safely
        =&gt; Task.Run(() =&gt; _feed.PublishAsync(e.RoomId, e.Content, CancellationToken.None));

    public void Dispose() =&gt; _source.MessageReceived -= OnLegacyMessageReceived;
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer raises the <code>async void</code> danger without being asked. Here is the trap: C# events return <code>void</code>. If you write an event handler that is <code>async void</code>, it looks like async code but it is actually fire-and-forget &#x2014; meaning if something throws an exception inside that async method, the exception goes straight to the thread pool and either crashes the app or is silently lost forever. There is no way to catch it from outside. The rule of thumb: the moment any subscriber needs to do async work (database calls, network calls), stop using C# events and switch to an interface-based Observer. The bridge pattern shown in the code is the safe way to migrate legacy event code over to the new approach.</div>
    </div></div>
  </div>

  <!-- Q17 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q17: Observer vs Rx.NET â€” when is Rx overkill? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-purple">Comparison</span> &nbsp; Follow-up: What is the learning curve and team impact?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Rx.NET is Observer with a superpowered query engine on top. The question is: when do those extra powers justify the added learning curve and complexity? Answer: when you need to combine, filter, time-window, or debounce streams of events in ways that would take hundreds of lines of manual code to do properly. If you just need basic "notify observers when something changes," Rx is overkill.</div>
      <p class="body-text"><strong>Rx.NET</strong> (Reactive Extensions for .NET) is Observer with a powerful pipeline of stream operators added on top &#x2014; things like <code>Where</code> (filter events), <code>Buffer</code> (group events into time windows), <code>Throttle</code> (ignore rapid repeats, only react after a pause), <code>CombineLatest</code> (combine two separate event streams), and many more. For a simple "notify all subscribers when a message arrives" scenario, pulling in Rx is overkill &#x2014; you are adding a complex library just to not use any of its features. The plain Observer pattern is 10 lines; setting up Rx for the same thing is 10 lines of boilerplate before the actual logic even starts.</p>
      <p class="body-text">Rx earns its complexity when your logic involves <strong>temporal conditions</strong> (things that happen over time). For example: "fire an alert when the 5-minute moving average crosses the 20-minute moving average, but only during market hours (9:30am-4pm), and suppress rapid re-fires within 500ms." With plain Observer, this would be hundreds of lines of timers, state machines, and thread management. With Rx, it is about 15 lines. The practical decision rule: zero operators needed &#x2014; use plain Observer; one or two simple filters &#x2014; use Observer plus an <code>if</code> guard; three or more operators, especially time-based ones &#x2014; consider Rx.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RxOverkillVsJustified.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// â”€â”€ CASE 1: Rx is OVERKILL â€” plain Observer is better â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Requirement: notify dashboard when any new chat message arrives.
// No filtering, no buffering, no combining â€” just fan-out.

// With plain Observer â€” clear and direct
public class ChatMessageFeed
{
    private readonly List&lt;IChatObserver&gt; _observers = new();
    public void Subscribe(IChatObserver o) =&gt; _observers.Add(o);
    public async Task PublishAsync(string roomId, string content, CancellationToken ct)
    {
        foreach (var o in _observers)
            await o.OnMessageReceivedAsync(roomId, content, ct);
    }
}

// With Rx for the SAME requirement â€” unnecessary ceremony
Subject&lt;(string RoomId, string Content)&gt; _subject = new();
IDisposable _sub = _subject
    .ObserveOn(TaskPoolScheduler.Default)  // adds nothing useful here
    .Subscribe(x =&gt; observer.OnMessageReceived(x.RoomId, x.Content));
// Zero operators used â€” Rx added zero value, just complexity.

// â”€â”€ CASE 2: Rx is JUSTIFIED â€” complex multi-signal condition â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Requirement: alert when 5-min MA crosses 20-min MA, only during market hours
//              (09:30â€“16:00 EST), debounced 500ms to suppress rapid re-fires.
// Without Rx: ~200+ lines of timers, ConcurrentQueues, state machines, locks.
// With Rx: ~15 lines.

IObservable&lt;decimal&gt; priceStream = _marketFeed.PriceStream; // source

IDisposable alert = priceStream
    // Only process ticks during market hours
    .Where(_ =&gt; IsMarketOpen())

    // Compute rolling 5-min moving average (buffer last 300 one-second ticks)
    .Buffer(TimeSpan.FromMinutes(5), TimeSpan.FromSeconds(1))
    .Select(window =&gt; window.Count &gt; 0 ? window.Average() : 0m)
    .Do(ma5 =&gt; _latestMA5 = ma5)

    // Combine with independently computed 20-min MA
    .CombineLatest(_ma20Stream, (ma5, ma20) =&gt; new { ma5, ma20 })

    // Detect crossover: sign of (ma5 - ma20) changed
    .Buffer(2, 1)
    .Where(w =&gt; w.Count == 2 &amp;&amp; Math.Sign(w[0].ma5 - w[0].ma20)
                                != Math.Sign(w[1].ma5 - w[1].ma20))

    // Debounce: suppress re-fires within 500ms
    .Throttle(TimeSpan.FromMilliseconds(500))

    .Subscribe(w =&gt; _alertService.FireCrossoverAlert(w[1].ma5, w[1].ma20));

// Decision table:
// Operators needed | Verdict
// 0                | Plain Observer
// 1-2 (simple)     | Observer + manual if-guard
// 3+ or temporal   | Use Rx â€” the operators pay for themselves</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer mentions that in .NET 8+, the use case for Rx has actually gotten smaller. Modern C# has <code>IAsyncEnumerable&lt;T&gt;</code> (async streams you can loop over with <code>await foreach</code>), which covers many of the same scenarios without requiring the team to learn Rx's own special mental model. Rx has a steep learning curve &#x2014; concepts like "hot vs cold observables," <code>ConnectableObservable</code>, schedulers, and backpressure are all new ideas a team needs to deeply understand to avoid subtle bugs. The team impact is real: Rx is a completely different programming model, not just a library. Only reach for Rx when you genuinely need operators like <code>CombineLatest</code>, <code>Merge</code>, or <code>Switch</code> &#x2014; the multi-stream combinators that have no clean equivalent in plain async/await.</div>
    </div></div>
  </div>

  <!-- Q18 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q18: Observer vs MediatR â€” what is the relationship? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-purple">Comparison</span> &nbsp; Follow-up: What happens when MediatR becomes a bottleneck?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> The key insight is that MediatR's notification system IS Observer &#x2014; it is not a separate pattern. It is just a pre-built version with extra features. So the real question is: when is it worth using MediatR's pre-built version versus rolling your own? MediatR trades raw performance and explicitness for zero boilerplate and built-in cross-cutting concerns.</div>
      <p class="body-text"><strong>MediatR</strong> is a library that implements the Observer pattern for you. When you call <code>await _mediator.Publish(new MessageReceivedEvent(...))</code>, MediatR automatically finds every class that implements <code>INotificationHandler&lt;MessageReceivedEvent&gt;</code> and calls them. You never need to manually subscribe or unsubscribe. You add a new observer by just creating a new handler class &#x2014; MediatR discovers it automatically through DI. Zero plumbing code per handler. This is Observer with all the wiring handled for you.</p>
      <p class="body-text">The trade-offs are real though. MediatR uses <strong>reflection</strong> internally (reflection means inspecting code at runtime to find types and call methods &#x2014; it is slower than direct calls). For very high-frequency events above 10,000 per second, this overhead becomes noticeable. There is also a <strong>discoverability problem</strong>: if you click "Go to Definition" on a notification event, your IDE takes you to the event definition, not to the handlers. A new team member reading the code cannot easily see what happens when this event is published &#x2014; they have to search for all handlers manually. MediatR's big advantage is its <strong>pipeline middleware</strong> feature (<code>IPipelineBehavior</code>) &#x2014; it gives you a clean way to add logging, validation, or retry logic that runs around every handler, without touching the handler code itself.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">MediatRVsCustomObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// â”€â”€ APPROACH 1: MediatR â€” zero plumbing, DI auto-discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Notification record (the "event")
public record MessageReceivedNotification(string RoomId, string Content)
    : INotification;

// Handler 1 â€” auto-discovered and invoked by MediatR
public class MentionHandler : INotificationHandler&lt;MessageReceivedNotification&gt;
{
    public Task Handle(MessageReceivedNotification n, CancellationToken ct)
        =&gt; _mentionService.EvaluateAsync(n.RoomId, n.Content, ct);
}

// Handler 2 â€” another auto-discovered handler
public class AuditHandler : INotificationHandler&lt;MessageReceivedNotification&gt;
{
    public Task Handle(MessageReceivedNotification n, CancellationToken ct)
        =&gt; _auditLog.RecordAsync(n.RoomId, n.Content, ct);
}

// Publish â€” MediatR resolves and fans out to all handlers
await _mediator.Publish(new MessageReceivedNotification(roomId, content), ct);

// DI registration (MediatR scans assembly â€” zero per-handler lines)
builder.Services.AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));

// â”€â”€ APPROACH 2: Custom Observer â€” explicit, fast, navigable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

public interface IChatObserver
{
    Task OnMessageReceivedAsync(string roomId, string content, CancellationToken ct);
}

public class ChatMessageFeed
{
    private readonly IReadOnlyList&lt;IChatObserver&gt; _observers;

    // DI injects all registered implementations â€” explicit, navigable
    public ChatMessageFeed(IEnumerable&lt;IChatObserver&gt; observers)
        =&gt; _observers = observers.ToList();

    public async Task PublishAsync(string roomId, string content, CancellationToken ct)
    {
        var tasks = _observers.Select(o =&gt; o.OnMessageReceivedAsync(roomId, content, ct));
        await Task.WhenAll(tasks);    // true parallel fan-out
    }
}

// DI registration â€” every observer is explicitly visible here
builder.Services.AddSingleton&lt;IChatObserver, AlertObserver&gt;();
builder.Services.AddSingleton&lt;IChatObserver, AuditObserver&gt;();
builder.Services.AddSingleton&lt;ChatMessageFeed&gt;();

// â”€â”€ DECISION TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Scenario                            | Winner
// Greenfield app-layer CQRS events    | MediatR â€” velocity matters
// Domain events &gt;10K/sec              | Custom Observer â€” reflection too slow
// Need pipeline middleware (logging)  | MediatR â€” IPipelineBehavior built-in
// Need AOT / NativeAOT compilation    | MediatR v12+ (source generators) or Custom
// Want "Go to Implementation" to work | Custom Observer â€” explicit DI list</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer warns about a common trap: teams that discover MediatR sometimes start routing everything through it &#x2014; even simple queries where there is no benefit. Now every method call has an extra layer of indirection and the code is harder to follow, with no gain. The guidance: use MediatR for application-layer events (CQRS commands, queries, and domain events at the boundary of your application), and use a custom interface Observer for high-frequency domain events deep inside the core logic where performance matters. Also worth mentioning: MediatR v12+ added source generators, which reduce the reflection overhead significantly for apps compiled with AOT (Ahead-Of-Time compilation).</div>
    </div></div>
  </div>

  <!-- Q19 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q19: Observer vs message queue â€” when do you cross the process boundary? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-purple">Comparison</span> &nbsp; Follow-up: What if we need a 6th service in a different data center?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Observer is an in-memory, in-process tool &#x2014; it is incredibly fast but limited to the same program. A message queue (Kafka, RabbitMQ, Azure Service Bus) crosses a network boundary to reach other programs, possibly in other locations. The one hard reason to switch: you need to reach a consumer that lives in a different process. Everything else is trade-offs. Then show the bridge pattern that lets you have both.</div>
      <p class="body-text">In-process Observer is incredibly fast &#x2014; we are talking under a microsecond to notify an observer, because it is just a direct method call in the same program's memory. There is no network involved, no data serialisation (converting objects to bytes), no infrastructure to set up or pay for. When all your consumers live in the same running program, Observer is the clear winner on every metric. The only hard reason to switch to a message queue: a consumer is in a different process, VM, or data center &#x2014; Observer simply cannot reach across process boundaries.</p>
      <p class="body-text">Message queues like Kafka or RabbitMQ add powerful capabilities: <strong>durability</strong> (if the app crashes, the messages are not lost &#x2014; they are stored on disk), <strong>replay</strong> (Kafka lets you re-read old messages from any point in time), <strong>horizontal scaling</strong> (add more consumer instances to handle more load), and <strong>cross-datacenter replication</strong>. The cost: milliseconds of network latency, data serialisation for every message, and operational complexity (you now have infrastructure to monitor and maintain). The best pattern is a hybrid: keep using Observer in-process for fast local consumers, and add one special observer &#x2014; a <code>KafkaBridgeObserver</code> &#x2014; that forwards events to Kafka for remote consumers. Adding it is literally one line in DI.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ObserverVsQueue_Hybrid.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// â”€â”€ DECISION FRAMEWORK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Q1: Are all consumers in the same process?
//     YES â†’ Observer (microseconds, zero cost)
// Q2: Same cluster, different processes, need durability?
//     YES â†’ Kafka / RabbitMQ within data centre
// Q3: Cross-datacenter, geo-replication, disaster recovery?
//     YES â†’ Kafka with cross-cluster replication or Azure Service Bus Premium

// â”€â”€ IN-PROCESS Observer (5 local consumers, ~100ns per publish) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public class ChatMessageFeed
{
    private readonly IReadOnlyList&lt;IChatObserver&gt; _observers;
    public ChatMessageFeed(IEnumerable&lt;IChatObserver&gt; observers)
        =&gt; _observers = observers.ToList();

    public async Task PublishAsync(string roomId, string content, CancellationToken ct)
    {
        await Task.WhenAll(
            _observers.Select(o =&gt; o.OnMessageReceivedAsync(roomId, content, ct)));
    }
}

// â”€â”€ HYBRID BRIDGE: Observer + Kafka for remote consumers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// One additional IChatObserver that forwards to Kafka.
// Publishers are completely unaware of the cross-process boundary.
public class KafkaBridgeObserver : IChatObserver
{
    private readonly IProducer&lt;string, ChatMessageEnvelope&gt; _producer;
    private const string Topic = "chat-messages-v1";

    public KafkaBridgeObserver(IProducer&lt;string, ChatMessageEnvelope&gt; producer)
        =&gt; _producer = producer;

    public async Task OnMessageReceivedAsync(string roomId, string content, CancellationToken ct)
    {
        var msg = new Message&lt;string, ChatMessageEnvelope&gt;
        {
            Key   = roomId,
            Value = new ChatMessageEnvelope(roomId, content, DateTimeOffset.UtcNow)
        };
        // Delivery confirmation â€” not fire-and-forget
        var result = await _producer.ProduceAsync(Topic, msg, ct);
        _logger.LogDebug("Delivered to Kafka offset {Offset}", result.Offset);
    }
}

// DI wiring â€” adding Kafka is a SINGLE line change
builder.Services.AddSingleton&lt;IChatObserver, AlertObserver&gt;();       // in-process
builder.Services.AddSingleton&lt;IChatObserver, DashboardObserver&gt;();   // in-process
builder.Services.AddSingleton&lt;IChatObserver, KafkaBridgeObserver&gt;(); // â† one line for cross-process

// Remote service (different DC) subscribes via Kafka consumer group
// and gets durability + replay for free â€” Observer topology unchanged

// â”€â”€ COMPARISON TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Dimension        | Observer          | Kafka / MQ
// Latency          | ~100ns            | 1â€“50ms
// Durability       | None (in-memory)  | Full (disk-persisted)
// Replay           | Impossible        | Any offset (Kafka)
// Horizontal scale | Vertical only     | Add consumer instances
// Ordering         | Trivial           | Partition-keyed (Kafka)
// Operational cost | Zero              | Cluster + monitoring
// Cross-process    | No                | Yes â€” that is the point</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer directly addresses the follow-up (a 6th service in a different data center) and calls it by name: this is when you need Kafka with <strong>cross-cluster replication</strong> (a Kafka feature called MirrorMaker 2) or Azure Service Bus Premium's geo-redundancy. They also explain why Kafka is usually preferred over RabbitMQ for ordered event streams: Kafka's log is like a permanent record &#x2014; consumed messages are not deleted, you can replay from any point. RabbitMQ's queue is destructive &#x2014; once a message is consumed, it is gone forever. They also emphasise: design for the hybrid bridge from day one. Adding <code>KafkaBridgeObserver</code> is one line. Trying to add message queue support to a system that was never designed for it is a full architectural rewrite.</div>
    </div></div>
  </div>

  <!-- Q20 -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q20: When is polling actually better than Observer? <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-purple">Comparison</span> &nbsp; Follow-up: How would you implement adaptive polling that adjusts based on activity?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; acknowledge that polling is a legitimate, production-proven tool â€” not a "beginner mistake." Step 2 &#x2014; list the specific situations where polling wins over Observer. Step 3 &#x2014; propose adaptive polling as the best-of-both-worlds middle ground. Polling is simple, reliable, and works in many situations where Observer cannot. Push back with specific cases where polling wins: low change frequency, no push API available, firewalls blocking inbound connections, or rate-limited APIs. Then propose a middle ground: adaptive polling that speeds up when activity is detected.</div>
      <p class="body-text">Observer requires the source to actively "push" notifications to you &#x2014; the source must be able to reach out and call your code. This works great when you own the source and it changes frequently. But polling &#x2014; checking for changes on a schedule &#x2014; is actually the better choice in several real-world situations: (1) the source is a third-party API that does not offer any push/webhook support; (2) your consumers are behind a firewall that blocks inbound connections; (3) the thing you are watching barely changes (imagine polling for "is the NYSE open?" &#x2014; it only changes twice per day). Fun fact: even Microsoft uses polling internally in ASP.NET Core's <code>IOptionsMonitor&lt;T&gt;</code> to detect configuration file changes, because file-system event APIs are unreliable on Linux containers.</p>
      <p class="body-text">The practical decision guide: if something changes more than once per second, use Observer &#x2014; polling that fast would burn CPU constantly. If something changes less than once per minute, use polling &#x2014; keeping an Observer connection alive for thousands of idle seconds just to catch one event is wasteful. In the middle range, it depends on your requirements. <strong>Adaptive polling</strong> is the elegant middle ground: start at a moderate polling interval, cut it in half every time you detect a change (so you react faster during active periods), and double it every time nothing changes (so you save resources during quiet periods). Best of both worlds.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">PollingVsObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// â”€â”€ POLLING WINS: MarketStatus changes twice per day â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// "Is the NYSE open?" changes at 09:30 and 16:00 EST â€” two events per day.
// Observer for this would maintain a subscriber list that fires twice a day.
// Polling every 30 seconds is cheaper and simpler.
public class MarketStatusPoller : BackgroundService
{
    private MarketStatus _current = MarketStatus.Unknown;
    private readonly TimeSpan _interval = TimeSpan.FromSeconds(30);

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var latest = await _marketApi.GetStatusAsync(ct);
            if (latest != _current)
            {
                _current = latest;
                _logger.LogInformation("Market status changed to {Status}", latest);
                // Act on change â€” no Observer infrastructure needed
                await _cache.SetAsync("market:status", latest, ct);
            }
            await Task.Delay(_interval, ct);   // 30s between polls â€” trivial CPU
        }
    }
}

// â”€â”€ OBSERVER WINS: Chat messages arrive thousands of times per second â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Polling at 1ms would burn CPU; polling at 100ms misses 99% of ticks.
// Observer delivers every tick with sub-millisecond latency.
public class MentionNotifier : IChatObserver
{
    public async Task OnMessageReceivedAsync(string roomId, string content, CancellationToken ct)
    {
        if (await _alertRules.IsTriggeredAsync(roomId, content, ct))
            await _notificationService.SendAlertAsync(roomId, content, ct);
    }
}

// â”€â”€ ADAPTIVE POLLING: adjusts interval based on observed activity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public class AdaptivePoller : BackgroundService
{
    // Interval contracts: min 100ms (active), max 60s (idle)
    private static readonly TimeSpan MinInterval = TimeSpan.FromMilliseconds(100);
    private static readonly TimeSpan MaxInterval = TimeSpan.FromSeconds(60);
    private TimeSpan _current = TimeSpan.FromSeconds(5); // start at moderate rate

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            var changed = await CheckForChangesAsync(ct);

            if (changed)
            {
                // Activity detected: halve the interval (poll more aggressively)
                _current = TimeSpan.FromTicks(Math.Max(_current.Ticks / 2, MinInterval.Ticks));
                _logger.LogDebug("Activity detected â€” polling at {Interval}ms", _current.TotalMilliseconds);
            }
            else
            {
                // Silence: double the interval (back off exponentially)
                _current = TimeSpan.FromTicks(Math.Min(_current.Ticks * 2, MaxInterval.Ticks));
                _logger.LogDebug("Idle â€” polling at {Interval}s", _current.TotalSeconds);
            }

            await Task.Delay(_current, ct);
        }
    }
}

// â”€â”€ DECISION HEURISTIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Change frequency  | Best approach
// &gt; 1 per second    | Observer (polling too slow / too expensive)
// 1/sec â€“ 1/min     | Context-dependent (latency need? push API available?)
// &lt; 1 per minute    | Polling (Observer overhead exceeds benefit)
// No push API       | Polling always (regardless of frequency)
// Behind firewall   | Polling always (can't accept inbound push)
// Rate-limited API  | Polling with adaptive backoff</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer kills the "polling is amateur" bias by citing a real example: Microsoft's own ASP.NET Core framework uses polling (not file-system events) to detect config file changes, because file-system event notifications are unreliable on Linux containers and network-mounted drives. If Microsoft chose polling for a production framework, polling is clearly not a naive or unsophisticated choice &#x2014; it is the pragmatic one when conditions call for it. The adaptive poller is the answer to the follow-up question: you get Observer-like fast response during active periods, and polling-like efficiency during quiet periods, without building an entire subscriber infrastructure.</div>
    </div></div>
  </div>

  <!-- Q21-Q25 Production -->
  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q21: System handles 10x load spike &#x2014; observers timing out <span class="badge badge-blue">Advanced</span></div><div class="qa-meta"><span class="badge badge-yellow">Production</span> &nbsp; Follow-up: How would you design the system upfront to handle these load spikes gracefully?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Imagine a real scenario: a viral event causes message volume to spike 10x normal. The system is buckling. You cannot restart it. What do you do right now? Step 1: decide which observers are absolutely critical vs nice-to-have. Step 2: shed (temporarily disable) the non-critical ones under high load. Step 3: shrink timeouts so slow observers cannot hold up the critical ones.</div>
      <p class="body-text">The first step is <strong>triage</strong> &#x2014; classify every observer by how critical it is. <code>MentionNotifier</code> and <code>RiskLimitObserver</code> are <strong>Critical</strong>: they must always run because traders depend on them. <code>AnalyticsObserver</code> and <code>DashboardObserver</code> are <strong>Normal</strong>: useful but not essential in a crisis &#x2014; a slightly stale dashboard is acceptable. <strong>Load shedding</strong> means: when the system is under high stress, only run critical observers and skip the normal ones. The subject checks the current load level before each notification round and gates which observers run. Skipped updates can be caught up later once the spike passes.</p>
      <p class="body-text"><strong>Adaptive timeouts</strong> work alongside load shedding. Under normal load, each observer gets a generous 5-second window to finish. Under high load, this shrinks to 500ms. In a critical spike, it drops to 100ms &#x2014; if an observer cannot finish in 100ms, it is cancelled and the system moves on. This prevents one slow observer from blocking the entire notification pipeline and delaying the critical observers that need to run. The combination of load shedding + adaptive timeouts creates a system that <strong>degrades gracefully</strong> rather than falling over completely.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">LoadAwareChatRoom.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Runtime load shedding &#x2014; disable non-critical observers without restart
public sealed class LoadAwareChatRoom : IChatMessageFeed
{
    private readonly IReadOnlyList&lt;IPrioritizedObserver&gt; _observers;
    private readonly ISystemHealthMonitor _health;
    private readonly ILogger&lt;LoadAwareChatRoom&gt; _logger;

    public async Task PublishAsync(ChatMessage update, CancellationToken ct)
    {
        var loadLevel = _health.CurrentLoadLevel; // Normal, High, Critical

        foreach (var observer in _observers)
        {
            // Load shedding: only run observers whose priority allows it
            if (observer.MinimumLoadLevel &lt;= loadLevel)
            {
                await observer.OnMessageReceivedAsync(update, ct);
            }
            else
            {
                _logger.LogWarning("Shedding {Observer} at load level {Load}",
                    observer.GetType().Name, loadLevel);
            }
        }
    }
}

public interface IPrioritizedObserver : IChatObserver
{
    LoadLevel MinimumLoadLevel { get; } // Critical = always runs, Normal = shed under high load
}

public enum LoadLevel { Critical = 0, High = 1, Normal = 2 }

// MentionNotifier: always runs â€” must never be load-shed
public sealed class MentionNotifier : IPrioritizedObserver
{
    public LoadLevel MinimumLoadLevel =&gt; LoadLevel.Critical; // Never shed
}

// Analytics observer: shed under high load (can catch up later)
public sealed class AnalyticsObserver : IPrioritizedObserver
{
    public LoadLevel MinimumLoadLevel =&gt; LoadLevel.Normal; // First to be shed
}

// Dynamic timeout adjustment based on load
public sealed class AdaptiveTimeoutNotifier
{
    private readonly ISystemHealthMonitor _health;

    public async Task NotifyWithAdaptiveTimeout(
        IChatObserver observer, ChatMessage update, CancellationToken ct)
    {
        var timeout = _health.CurrentLoadLevel switch
        {
            LoadLevel.Critical =&gt; TimeSpan.FromMilliseconds(100),
            LoadLevel.High     =&gt; TimeSpan.FromMilliseconds(500),
            _                  =&gt; TimeSpan.FromSeconds(5)
        };

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        try { await observer.OnMessageReceivedAsync(update, cts.Token); }
        catch (OperationCanceledException)
        {
            _logger.LogWarning("Observer timed out at {Load} load", _health.CurrentLoadLevel);
        }
    }
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great engineer builds the load shedding system BEFORE the crisis &#x2014; not at 3 AM during a market crash. Observer priorities are defined during design reviews when there is time to think carefully. They also add a <strong>degradation dashboard</strong>: a live display that shows "alerts: 100% processed, analytics: 30% processed (load shedding active)" &#x2014; so the operations team knows the system is under stress but still functioning correctly for the critical parts. They run quarterly load tests that simulate a 10x spike for 2 hours, and they design the shed observers to automatically catch up once load returns to normal (using Kafka replay or a bounded channel with backfill).</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q22: A new compliance requirement says every observer must complete within 50ms. How do you enforce this? <span class="badge badge-blue">Advanced</span></div><div class="qa-meta"><span class="badge badge-yellow">Production</span> &nbsp; Follow-up: How do you prove compliance to the regulator? What monitoring do you need?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; clarify the requirement before designing anything. "50ms" is ambiguous. Does it mean every single notification must be under 50ms? Or just most of them? The answer affects the entire design. Step 2 &#x2014; the 50ms budget is for the TOTAL round trip through all observers, not 50ms each. If you have 5 observers each taking 20ms, you are way over budget. Step 3 &#x2014; split observers into two tiers: fast ones that must stay within the budget, and slow ones that can work asynchronously after the fact.</div>
      <p class="body-text">Before you write any code, clarify with the regulator what "50ms" means. Does it mean <strong>P99</strong> (99% of notifications must be under 50ms)? Or <strong>P99.9</strong> (99.9%)? Or every single one? This matters enormously &#x2014; P99.9 is much harder to achieve than P50. Once clarified, split observers into two tiers. The <strong>fast-path</strong> observers (mention checking, moderation validation) must complete within the 50ms budget &#x2014; they each get a 10ms sub-budget with automatic cancellation if they exceed it. The <strong>slow-path</strong> observers (analytics models, ML pipelines, external API calls) receive updates via a <code>Channel&lt;T&gt;</code> queue. The enqueue takes under 1ms &#x2014; well within the compliance window. The actual processing happens asynchronously in the background, outside the 50ms window.</p>
      <p class="body-text">To prove compliance, you need to measure and record every notification's duration. <strong>HdrHistogram</strong> is a tool designed for this &#x2014; it records latencies with very low overhead and can generate reports showing P50, P95, P99, and P99.9 latencies. You expose these as monitoring metrics so the regulator can see them. There is one sneaky trap: <strong>cold-start effects</strong>. The very first message after the app starts will be slow because the .NET runtime is still warming up (JIT compilation), database connections are not yet established, and caches are empty. This first notification could violate the 50ms SLA. Fix it with pre-warming: fire synthetic fake messages at startup to get everything warm before real traffic arrives.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">RegulatedChatRoom.cs</span></div><div class="macos-body"><pre><code class="language-csharp">public sealed class RegulatedChatRoom : IChatMessageFeed
{
    private readonly IReadOnlyList&lt;IChatObserver&gt; _fastObservers;  // &lt; 10ms each
    private readonly Channel&lt;ChatMessage&gt; _slowChannel;             // Async queue
    private readonly Stopwatch _stopwatch = new();

    public async Task PublishAsync(ChatMessage update, CancellationToken ct)
    {
        _stopwatch.Restart();

        // FAST PATH: Synchronous observers that MUST complete in budget
        foreach (var observer in _fastObservers)
        {
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            cts.CancelAfter(TimeSpan.FromMilliseconds(10)); // Per-observer budget

            try { await observer.OnMessageReceivedAsync(update, cts.Token); }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Fast observer {Type} exceeded 10ms budget",
                    observer.GetType().Name);
            }
        }

        // SLOW PATH: Enqueue for async processing (non-blocking, &lt; 1ms)
        _slowChannel.Writer.TryWrite(update);

        _stopwatch.Stop();

        // Record for compliance reporting
        _complianceMetrics.RecordLatency(_stopwatch.Elapsed.TotalMicroseconds);
        if (_stopwatch.ElapsedMilliseconds &gt; 50)
        {
            _logger.LogError("COMPLIANCE VIOLATION: Processing took {Ms}ms (limit: 50ms)",
                _stopwatch.ElapsedMilliseconds);
        }
    }
}

// Compliance monitoring with percentile tracking
public sealed class ComplianceMetrics
{
    public ComplianceReport GenerateReport() =&gt; new ComplianceReport
    {
        P50  = _histogram.GetValueAtPercentile(50)   / 1000.0, // ms
        P95  = _histogram.GetValueAtPercentile(95)   / 1000.0,
        P99  = _histogram.GetValueAtPercentile(99)   / 1000.0,
        P999 = _histogram.GetValueAtPercentile(99.9) / 1000.0,
        MaxObserved    = _histogram.GetMaxValue() / 1000.0,
        TotalSamples   = _histogram.TotalCount,
        ViolationCount = _violationCount,
        ViolationRate  = (double)_violationCount / _histogram.TotalCount
    };
}

// Expose as Prometheus metrics:
// chat_message_processing_duration_milliseconds{quantile="0.99"} 42.3
// chat_message_compliance_violations_total 17</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great engineer clarifies the "50ms" requirement upfront (P50? P99? P99.9?) instead of assuming. They also name the key architectural insight: the slow-path Channel approach moves non-critical work <em>outside</em> the compliance window without losing it. You are not dropping the data &#x2014; you are just doing it later. This is fundamentally different from simply increasing a timeout. They also mention pre-warming as a production-readiness detail that shows real-world experience: cold-start violations are a well-known footgun in latency-sensitive systems.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q23: A new team wants to add an observer, but they are in a different deployment unit <span class="badge badge-blue">Intermediate</span></div><div class="qa-meta"><span class="badge badge-yellow">Production</span> &nbsp; Follow-up: How do you version the event contract between the two teams?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> "Different deployment unit" means Team B's code runs in a completely separate program on a different server &#x2014; in-process Observer cannot cross that boundary. Step 1: Team A adds a bridge observer that forwards events to a shared messaging system (Kafka). Step 2: Team B subscribes to that messaging system independently. Step 3: the hard part is agreeing on the data format and making sure changes do not break each other &#x2014; this is event contract versioning.</div>
      <p class="body-text">When two teams have separate deployments, they cannot share in-memory objects. This is the transition from in-process Observer to <strong>Pub/Sub</strong> (Publish-Subscribe) &#x2014; a messaging pattern where a publisher puts events into a shared message broker, and any number of subscribers read from it independently. Team A's service keeps its internal Observer system exactly as-is. They just add one new observer &#x2014; a <code>KafkaBridgeObserver</code> &#x2014; that forwards every chat message to a Kafka topic. Team B's service, deployed separately on its own servers, subscribes to that Kafka topic via a consumer group and processes the events. Zero changes to Team A's subject or any existing observers. It is one line added to Team A's DI registration.</p>
      <p class="body-text">The hard challenge is <strong>event contract versioning</strong>: how do both teams agree on what the data looks like, and how do you change it without breaking each other? The answer: include a <code>schema-version</code> header in every Kafka message. Team B's consumer reads this header and handles each version appropriately. The rules for safe evolution: you CAN add new optional (nullable) fields to the event &#x2014; Team B will just see <code>null</code> for that field until they update their code. You CAN add entirely new event types on new topics. You CANNOT remove fields, rename fields, or change field types &#x2014; Team B's code will break. A <strong>schema registry</strong> (a central place that stores and validates event schemas) enforces these rules automatically in your CI/CD pipeline.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">CrossDeploymentBridge.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Team A's service: KafkaBridgeObserver forwards events to Kafka
public sealed class KafkaBridgeObserver : IChatObserver
{
    private readonly IProducer&lt;string, byte[]&gt; _producer;

    public async Task OnMessageReceivedAsync(ChatMessage update, CancellationToken ct)
    {
        var envelope = new ChatMessageEvent
        {
            Version = 1,                    // Schema version
            RoomId  = update.RoomId,
            SenderId = update.SenderId,
            Content = update.Content,
            Timestamp = update.Timestamp,
            CorrelationId = Activity.Current?.Id ?? Guid.NewGuid().ToString()
        };

        var kafkaMsg = new Message&lt;string, byte[]&gt;
        {
            Key   = update.RoomId,            // Partition by room for ordering
            Value = JsonSerializer.SerializeToUtf8Bytes(envelope),
            Headers = new Headers
            {
                { "content-type", Encoding.UTF8.GetBytes("application/json") },
                { "schema-version", Encoding.UTF8.GetBytes("1") }
            }
        };
        await _producer.ProduceAsync("chat.messages.v1", kafkaMsg, ct);
    }
}

// Team B's service: consumes from Kafka &#x2014; deployed independently
public sealed class ChatMessageConsumer : BackgroundService
{
    private readonly IConsumer&lt;string, byte[]&gt; _consumer;
    private readonly IEnumerable&lt;IChatObserver&gt; _localObservers;

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        _consumer.Subscribe("chat.messages.v1");
        while (!ct.IsCancellationRequested)
        {
            var result = _consumer.Consume(ct);
            var version = Encoding.UTF8.GetString(
                result.Message.Headers.GetLastBytes("schema-version"));

            var update = version switch
            {
                "1" =&gt; DeserializeV1(result.Message.Value),
                "2" =&gt; DeserializeV2(result.Message.Value),
                _ =&gt; throw new NotSupportedException($"Unknown version: {version}")
            };

            // Team B's own internal observers process the event
            foreach (var obs in _localObservers)
                await obs.OnMessageReceivedAsync(update, ct);
        }
    }
}

// Backward-compatible evolution rules:
// &#x2713; Add new OPTIONAL fields (nullable)      &#x2014; old consumers ignore them
// &#x2713; Add new event types on new topics        &#x2014; existing consumers unaffected
// &#x2717; Remove existing fields                   &#x2014; breaks old consumers
// &#x2717; Change field types (decimal &#x2192; double)   &#x2014; breaks deserialization
// &#x2717; Rename fields                             &#x2014; breaks JSON deserialization</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great answer sets up <strong>consumer lag monitoring</strong>: if Team B's consumer falls behind by more than N messages in Kafka, an alert fires. This is the distributed equivalent of detecting a slow observer in the in-process world. They also mention Kafka producer settings for financial systems: <code>acks=all</code> (every message must be acknowledged by all Kafka replicas before considered delivered) and <code>enable.idempotence=true</code> (ensures the same message is never written twice even if retried). They also frame the bridge observer as an architectural migration tool &#x2014; this is how you safely break apart a monolith into microservices one piece at a time, without rewriting everything at once.</div>
    </div></div>
  </div>

  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q24: The system needs to support replay &#x2014; reprocess yesterday's messages through a new observer <span class="badge badge-blue">Advanced</span></div><div class="qa-meta"><span class="badge badge-yellow">Production</span> &nbsp; Follow-up: How do you ensure the replay does not interfere with live processing?</div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Standard Observer is fire-and-forget &#x2014; it sends the notification and forgets it ever happened. There is no history, so there is no replay. Step 1: add an Event Store (a database or log that permanently records every event). Step 2: the Subject writes to both the store AND the live observers. Step 3: for replay, read from the store and feed events through the specific observer that needs backfilling. Step 4: make sure replay does not interfere with live processing.</div>
      <p class="body-text">Standard Observer has no memory &#x2014; it fires and forgets. To support replay, you need to store every event somewhere. This storage is called an <strong>Event Store</strong> &#x2014; think of it as a permanent, ordered log of everything that ever happened. The subject now does two things on every message: (1) save the event to the Event Store for future use, (2) notify live observers as usual. When a new observer joins and needs to process yesterday's data, a <code>ReplayService</code> reads from the Event Store and feeds historical events through that specific observer &#x2014; one at a time, in order, with progress tracking.</p>
      <p class="body-text">Isolation from live processing is critical. Replay should use its own separate database connections (via <code>IDbContextFactory</code>) so it does not compete with live writes for connection slots. Every record written during replay should be tagged with <code>Source = "Replay"</code> so auditors can distinguish replayed data from real-time data. <strong>Idempotency</strong> is also important &#x2014; this means: if the replay crashes midway and you restart it, it should not create duplicate records. Use a deduplication key (like RoomId + Timestamp) so the same event written twice just updates the existing record. In production, Kafka is the ideal Event Store because it already keeps messages for a configurable duration &#x2014; replay becomes simply "reset the consumer's reading position to yesterday midnight."</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ReplayArchitecture.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Event store: records all chat messages for replay
public interface IChatEventStore
{
    Task AppendAsync(ChatMessage update, CancellationToken ct);
    IAsyncEnumerable&lt;ChatMessage&gt; ReplayAsync(
        DateTime from, DateTime to, CancellationToken ct);
}

// The Subject writes to event store AND notifies live observers
public sealed class PersistentChatRoom : IChatMessageFeed
{
    private readonly IChatEventStore _eventStore;
    private readonly List&lt;IChatObserver&gt; _liveObservers = new();

    public async Task PublishAsync(ChatMessage update, CancellationToken ct)
    {
        // 1. Persist event (for future replay)
        await _eventStore.AppendAsync(update, ct);

        // 2. Notify live observers
        foreach (var obs in _liveObservers.ToList())
            await obs.OnMessageReceivedAsync(update, ct);
    }
}

// Replay service: feeds historical events through specific observers
public sealed class ReplayService
{
    private readonly IChatEventStore _eventStore;

    public async Task ReplayAsync(
        IChatObserver observer, DateTime from, DateTime to,
        CancellationToken ct, IProgress&lt;ReplayProgress&gt;? progress = null)
    {
        long processed = 0;
        var sw = Stopwatch.StartNew();

        await foreach (var update in _eventStore.ReplayAsync(from, to, ct))
        {
            await observer.OnMessageReceivedAsync(update, ct);
            processed++;

            if (processed % 10_000 == 0)
                progress?.Report(new ReplayProgress(processed, sw.Elapsed,
                    processed / sw.Elapsed.TotalSeconds));
        }
        _logger.LogInformation("Replay complete: {Count} events in {Duration}",
            processed, sw.Elapsed);
    }
}

// Replay observer: separate DbContext, tagged as replay
public sealed class ReplayModerationObserver : IChatObserver
{
    private readonly IDbContextFactory&lt;ChatDbContext&gt; _dbFactory;

    public async Task OnMessageReceivedAsync(ChatMessage update, CancellationToken ct)
    {
        await using var db = await _dbFactory.CreateDbContextAsync(ct);
        db.ModerationScores.Add(new ModerationScore
        {
            RoomId       = update.RoomId,
            Score        = CalculateScore(update),
            Timestamp    = update.Timestamp,       // ORIGINAL timestamp, not now
            CalculatedAt = DateTime.UtcNow,
            Source       = "Replay"                 // Tag for auditing
        });
        await db.SaveChangesAsync(ct);
    }
}

// Usage: backfill moderation scores for yesterday
var moderationObserver = serviceProvider.GetRequiredService&lt;ReplayModerationObserver&gt;();
await replayService.ReplayAsync(moderationObserver,
    from: DateTime.UtcNow.Date.AddDays(-1),
    to:   DateTime.UtcNow.Date, ct);</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> A great engineer highlights one specific detail that shows deep experience: replay must preserve the <strong>original timestamps</strong>. When you replay yesterday's messages today, the records you write should say "calculated at 10:34am yesterday" &#x2014; not "calculated at 2:15pm today." Using today's timestamp would corrupt the temporal context of your data, making historical analysis meaningless. They also mention running replay on a separate database replica to completely avoid impacting live traffic. And they note that with Kafka as the event store, replay is essentially free &#x2014; you just move a pointer back in time and let the consumer re-read from that point.</div>
    </div></div>
  </div>


  <div class="qa-item">
    <div class="qa-header"><div><div class="qa-question">Q25: Feature flags to enable/disable observers without redeployment</div><div class="qa-meta"><span class="badge badge-yellow">Production</span></div></div><i class="fa-solid fa-chevron-down qa-chevron"></i></div>
    <div class="qa-body"><div class="qa-content">
      <div class="qa-think"><strong>Think:</strong> Step 1 &#x2014; explain what a feature flag is in plain terms. Step 2 &#x2014; show how to check a flag before subscribing at startup. Step 3 &#x2014; show how to toggle at runtime without a restart. Step 4 &#x2014; explain why this is safer than a full deployment.</div>
      <p class="body-text">A <strong>feature flag</strong> is a configuration switch that lets you turn a piece of functionality on or off without deploying new code. Think of it like a light switch in a control panel. The solution: wrap observer registration with feature flag checks. When the app starts, check whether a flag is enabled before subscribing an observer. For runtime toggling (changing the flag while the app is running), add a background job that periodically checks the flags and subscribes or unsubscribes observers accordingly.</p>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FeatureFlaggedObserver.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Conditional registration
if (_featureFlags.IsEnabled("observer.compliance-check"))
    _subscriptions.Add(_feed.Subscribe(_complianceObserver));

// Runtime toggle via background check
if (_featureFlags.IsEnabled("observer.ml-analysis") &amp;&amp; !_mlSubscribed) {
    _subscriptions["ml"] = _feed.Subscribe(_mlObserver);
    _mlSubscribed = true;
} else if (!_featureFlags.IsEnabled("observer.ml-analysis") &amp;&amp; _mlSubscribed) {
    _subscriptions["ml"].Dispose();
    _mlSubscribed = false;
}</code></pre></div></div>
      <div class="qa-great"><strong>What separates good from great:</strong> Feature-flagged observers are essential for <strong>safe gradual rollouts</strong>. The workflow: deploy the new observer code to all servers (it is off by default). Enable the flag for 1% of traffic. Watch metrics &#x2014; error rates, latency, data correctness. If everything looks good, ramp up to 10%, 50%, 100%. If something goes wrong at any point, flip the flag off. The new observer is disabled instantly &#x2014; no redeployment, no rollback, no downtime. This is much safer than the old approach of doing a full redeployment every time you want to enable or disable a feature.</div>
    </div></div>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 15: WHEN TO USE / WHEN NOT TO USE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s15" class="section">
  <div class="section-header">
    <div class="section-icon blue"><i class="fa-solid fa-compass"></i></div>
    <div><div class="section-num">Section 15</div><h2 class="section-title">When to Use / When NOT to Use</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-check-circle"></i> Valid Use Cases</div>
    <div class="table-wrapper"><table>
      <thead><tr><th>#</th><th>Use Case</th><th>WHY Observer Is the Right Choice</th></tr></thead>
      <tbody>
        <tr><td>1</td><td><strong>Real-time message feed notifying multiple consumers</strong> (mention alerts, unread counters, audit loggers, moderation)</td><td>The Subject (message feed) has a single source of truth. Multiple independent consumers need the same data. Observer decouples the feed from its consumers â€” adding a new consumer never changes the feed.</td></tr>
        <tr><td>2</td><td><strong>UI data binding</strong> (Blazor components reacting to model changes, WPF INotifyPropertyChanged)</td><td>The view must update when the model changes. Observer provides automatic, declarative binding. Without it, the view would poll the model â€” wasteful and latent.</td></tr>
        <tr><td>3</td><td><strong>Configuration change propagation</strong> (IOptionsMonitor, feature flag updates across components)</td><td>Configuration is read by many components. When it changes, all must react. Observer ensures zero-delay propagation without components polling the config store.</td></tr>
        <tr><td>4</td><td><strong>Event-driven plugin architectures</strong> (VS Code extensions, game engines, CI/CD pipeline hooks)</td><td>Plugins cannot be known at compile time. Observer allows dynamic registration of behavior. The host application is closed for modification (OCP) â€” plugins extend it via subscription.</td></tr>
        <tr><td>5</td><td><strong>Audit logging of domain events</strong> (every business action must be recorded for compliance)</td><td>Audit is a cross-cutting concern. Using Observer, the audit observer is just another subscriber â€” it does not pollute business logic. Adding/removing audit observers does not change business code.</td></tr>
        <tr><td>6</td><td><strong>Cache invalidation</strong> (when underlying data changes, dependent caches must be busted)</td><td>Caches must invalidate when source data changes. Observer ensures immediate invalidation without the cache knowing about the data source's internals. Multiple caches (Redis, in-memory, CDN) can all observe the same change event.</td></tr>
        <tr><td>7</td><td><strong>Distributed system integration via bridge observer</strong> (in-process Observer fans out to Kafka/RabbitMQ)</td><td>The bridge observer pattern lets you keep simple in-process Observer for local consumers while transparently forwarding events to distributed consumers. Best of both worlds.</td></tr>
        <tr><td>8</td><td><strong>Monitoring and metrics collection</strong> (observer that records latency, throughput, error rates)</td><td>Metrics observers subscribe to the same events as business observers. They collect telemetry without any instrumentation code in the Subject or business observers. SRP enforced.</td></tr>
        <tr><td>9</td><td><strong>Multi-step workflow triggers</strong> (message â†’ moderation â†’ notification â†’ archiving)</td><td>Each step in the workflow is an observer. The workflow is defined by subscription order, not hardcoded in a monolithic method. Steps can be added, removed, or reordered without modifying existing steps.</td></tr>
      </tbody>
    </table></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-xmark-circle"></i> Anti-Patterns and YAGNI Cases â€” When NOT to Use Observer</div>
    <div class="table-wrapper"><table>
      <thead><tr><th>#</th><th>Scenario</th><th>WHY NOT â€” Use This Instead</th></tr></thead>
      <tbody>
        <tr><td>1</td><td><strong>Single known consumer that will never change</strong></td><td>Direct method call. Observer adds indirection for zero benefit. If you can count consumers on one finger, YAGNI. <strong>Use: direct method call.</strong></td></tr>
        <tr><td>2</td><td><strong>Two consumers that are stable and well-known</strong></td><td>Direct method calls or a simple facade. The "2-algorithm rule": if <code>if/else</code> or two method calls solves the problem clearly, Observer is over-engineering. <strong>Use: facade or direct calls.</strong></td></tr>
        <tr><td>3</td><td><strong>Synchronous request-response</strong> (caller needs a return value)</td><td>Observer is fire-and-forget â€” it does not return results. If the Subject needs to know whether the observer succeeded, Observer is the wrong pattern. <strong>Use: Strategy, CoR, or direct call.</strong></td></tr>
        <tr><td>4</td><td><strong>Strict ordering with veto power</strong> (compliance must BLOCK trade)</td><td>Observer broadcasts to all observers equally â€” no observer can prevent another from executing. <strong>Use: Chain of Responsibility or middleware pipeline.</strong></td></tr>
        <tr><td>5</td><td><strong>Cross-process communication as primary use case</strong></td><td>Observer is in-process by design. Using it cross-process means reinventing a message broker. <strong>Use: RabbitMQ, Kafka, gRPC streaming.</strong></td></tr>
        <tr><td>6</td><td><strong>Performance-critical hot path</strong> (HFT, 1M+ orders/sec)</td><td>Observer adds virtual dispatch overhead (~2ns), list iteration, and potential allocation. In nanosecond-sensitive paths, direct method calls are faster. <strong>Use: direct inlined calls.</strong></td></tr>
        <tr><td>7</td><td><strong>Temporary one-time notification</strong></td><td>Observer is designed for ongoing subscriptions. For one-time notifications, it adds subscribe/unsubscribe lifecycle overhead. <strong>Use: TaskCompletionSource&lt;T&gt; or async/await.</strong></td></tr>
        <tr><td>8</td><td><strong>Observer needs to query subject's full state</strong> (pull-heavy)</td><td>If the observer always needs to fetch the Subject's entire state after notification, the push model is wasteful. <strong>Use: polling with caching, or CQRS read model.</strong></td></tr>
        <tr><td>9</td><td><strong>Team of 1-2 developers on a small project</strong></td><td>Observer adds architectural complexity. In a small team, the indirection slows development more than it helps. <strong>Use: direct calls. Refactor to Observer when the third consumer appears.</strong></td></tr>
      </tbody>
    </table></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-scale-balanced"></i> The 2-Algorithm Rule</div>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">decision-thresholds.txt</span></div><div class="macos-body"><pre><code class="language-plaintext">Consumers = 0  â†’ You don't need anything (YAGNI)
Consumers = 1  â†’ Direct method call
Consumers = 2  â†’ Direct method calls or simple facade (evaluate case by case)
Consumers = 3+ â†’ Observer pattern (the complexity is now justified)
Consumers = 3+ AND growing â†’ Observer pattern (definitely justified)
Consumers = 3+ AND cross-process â†’ Pub/Sub with message broker</code></pre></div></div>
    <p class="body-text"><strong>The inflection point is 3 consumers.</strong> At 2, the overhead of Observer (interface definition, subscription management, error handling per observer, invisible control flow) often exceeds the coupling cost of two direct method calls. At 3+, the coupling cost grows faster than the Observer overhead.</p>
    <div class="callout callout-tip"><strong>Exception to the rule:</strong> Even with 1-2 consumers, use Observer if: the consumer changes frequently (weekly deploys), the consumer is owned by a different team (organizational decoupling), or testability requires mocking (Observer interface makes it trivial).</div>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 16: PITFALLS AND ANTI-PATTERNS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s16" class="section">
  <div class="section-header">
    <div class="section-icon yellow"><i class="fa-solid fa-triangle-exclamation"></i></div>
    <div><div class="section-num">Section 16</div><h2 class="section-title">Pitfalls and Anti-Patterns</h2></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-virus"></i> Pitfall 1: The God Observer â€” One Observer That Does Everything</div>
    <p class="body-text"><strong>The Mistake:</strong> A single observer class handles mentions, unread counts, audit logging, and analytics in one <code>OnMessageReceivedAsync</code> method.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">GodObserver.cs â€” BAD</span></div><div class="macos-body"><pre><code class="language-csharp">// âŒ God Observer: does everything, violates SRP
public sealed class MasterChatObserver : IChatObserver
{
    private readonly IPushNotificationService _push;
    private readonly IUnreadCountService _unreadService;
    private readonly IAuditRepository _auditRepo;
    private readonly IAnalyticsEngine _analytics;
    private readonly ISpamDetectionEngine _spamEngine;
    private readonly IModerationService _moderation;
    private readonly IComplianceService _compliance;

    public async Task OnMessageReceivedAsync(ChatMessage update,
        CancellationToken ct)
    {
        // 200 lines of mixed concerns...
        await CheckMentions(update, ct);
        await UpdateUnreadCounts(update, ct);
        await WriteAuditLog(update, ct);
        await RunSpamDetection(update, ct);
        await RunModeration(update, ct);
        await RunComplianceChecks(update, ct);
        await PublishToAnalytics(update, ct);
    }
}</code></pre></div></div>
    <p class="body-text"><strong>WHY it is a mistake:</strong></p>
    <ul class="body-text">
      <li><strong>SRP violation:</strong> Seven reasons to change in one class. A bug in analytics blocks deployment of a critical alert fix.</li>
      <li><strong>Testing:</strong> Unit testing requires mocking 7 dependencies, and tests are brittle.</li>
      <li><strong>Team velocity:</strong> Three teams cannot work on their concerns simultaneously without merge conflicts.</li>
      <li><strong>Deployment risk:</strong> Any change requires retesting ALL seven concerns.</li>
      <li><strong>Scalability ceiling:</strong> The slowest concern (analytics at 200ms) becomes the bottleneck for the fastest (alerts at 5ms).</li>
    </ul>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FixedObservers.cs â€” GOOD</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… One observer per concern â€” independently deployable, testable, monitorable
public sealed class MentionNotifier : IChatObserver { /* alerts only */ }
public sealed class UnreadCountTracker : IChatObserver { /* unread counts only */ }
public sealed class ChatAuditLogger : IChatObserver { /* audit only */ }
public sealed class AutoModerationObserver : IChatObserver { /* moderation only */ }
public sealed class SpamDetectionObserver : IChatObserver { /* spam detection only */ }
public sealed class ComplianceObserver : IChatObserver { /* compliance only */ }
public sealed class AnalyticsObserver : IChatObserver { /* analytics only */ }

// DI registration â€” each is independently configurable
services.AddSingleton&lt;IChatObserver, MentionNotifier&gt;();
services.AddSingleton&lt;IChatObserver, UnreadCountTracker&gt;();
services.AddSingleton&lt;IChatObserver, ChatAuditLogger&gt;();
// ... each can be feature-flagged, load-shed, or disabled independently</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-lock"></i> Pitfall 2: Notifying Inside a Lock â€” The Deadlock Factory</div>
    <p class="body-text"><strong>The Mistake:</strong> The Subject holds a lock while iterating and notifying observers. If any observer tries to call <code>Subscribe</code>, <code>Unsubscribe</code>, or trigger another notification that acquires the same lock, the system deadlocks.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">DeadlockChatRoom.cs â€” BAD</span></div><div class="macos-body"><pre><code class="language-csharp">// âŒ Notifying inside a lock
public sealed class DeadlockChatRoom : IChatMessageFeed
{
    private readonly List&lt;IChatObserver&gt; _observers = new();
    private readonly object _lock = new();

    public void Subscribe(IChatObserver observer)
    {
        lock (_lock) { _observers.Add(observer); } // Acquires _lock
    }

    public async Task PublishAsync(ChatMessage update, CancellationToken ct)
    {
        lock (_lock) // Acquires _lock
        {
            foreach (var obs in _observers)
            {
                // If THIS observer calls Subscribe or Unsubscribe
                // on this same feed â†’ tries to acquire _lock â†’ DEADLOCK
                obs.OnMessageReceivedAsync(update, ct).GetAwaiter().GetResult();
            }
        }
    }
}</code></pre></div></div>
    <p class="body-text"><strong>WHY it is a mistake:</strong> Deadlock is the most immediate consequence. Even without deadlock, holding a lock during I/O means Subscribe/Unsubscribe calls block for the entire notification duration. Deadlocks are non-deterministic â€” they may work for months then fail when a new observer re-enters.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SafeChatRoom.cs â€” GOOD</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… Snapshot under lock, notify outside lock
public sealed class SafeChatRoom : IChatMessageFeed
{
    private ImmutableList&lt;IChatObserver&gt; _observers =
        ImmutableList&lt;IChatObserver&gt;.Empty;

    public void Subscribe(IChatObserver observer)
    {
        ImmutableInterlocked.Update(ref _observers, list =&gt; list.Add(observer));
    }

    public async Task PublishAsync(ChatMessage update, CancellationToken ct)
    {
        var snapshot = _observers; // Single atomic read, no lock

        // Notify OUTSIDE any lock â€” observers can freely Subscribe/Unsubscribe
        foreach (var obs in snapshot)
        {
            try { await obs.OnMessageReceivedAsync(update, ct); }
            catch (Exception ex) { /* Log but don't stop loop */ }
        }
    }
}</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-volume-xmark"></i> Pitfall 3: Swallowing Exceptions Without Logging</div>
    <p class="body-text"><strong>The Mistake:</strong> The Subject catches observer exceptions with an empty catch block. Observer failures are invisible in production.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">SilentFailure.cs â€” BAD</span></div><div class="macos-body"><pre><code class="language-csharp">// âŒ Silent failure â€” observer errors vanish into the void
foreach (var obs in _observers.ToList())
{
    try { await obs.OnMessageReceivedAsync(update, ct); }
    catch (Exception)
    {
        // Swallowed. No logging. No metrics. No alerts.
        // The audit observer could fail for weeks unnoticed.
    }
}</code></pre></div></div>
    <p class="body-text"><strong>WHY it is a mistake:</strong> Compliance risk (audit trail gaps), monitoring blind spots, debugging cost (no logs weeks later), and cascading failures masked.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">ObservableLogging.cs â€” GOOD</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… Log with full context + metrics + health check
catch (OperationCanceledException) when (ct.IsCancellationRequested)
{
    _logger.LogInformation("Observer {Type} cancelled for {RoomId}",
        observerType, message.RoomId);
    throw; // Propagate cancellation
}
catch (Exception ex)
{
    _logger.LogError(ex,
        "Observer {Type} failed for {RoomId} after {Ms}ms. " +
        "SenderId={SenderId}, Content={Content}",
        observerType, message.RoomId, sw.ElapsedMilliseconds,
        message.SenderId, message.Content);
    _metrics.IncrementObserverFailure(observerType);
    _healthTracker.RecordFailure(observerType);
}</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-arrows-spin"></i> Pitfall 4: Circular Notification Loop</div>
    <p class="body-text"><strong>The Mistake:</strong> Observer A, when notified by Subject S, modifies data that causes Subject S to publish another notification â€” creating an infinite loop.</p>
    <p class="body-text"><strong>WHY it is a mistake:</strong> Stack overflow (not catchable, kills process instantly), infinite resource consumption, data corruption, and difficult to detect in code review.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">CircularLoop-Fixes.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… Fix 1: Re-entrancy guard
if (Interlocked.CompareExchange(ref _isProcessing, 1, 0) != 0)
{
    _logger.LogWarning("Skipping re-entrant notification for {RoomId}",
        message.RoomId);
    return;
}

// âœ… Fix 2 (better): Deferred publishing via Channel&lt;T&gt;
_publishQueue.Writer.TryWrite(new ChatMessage(...));
// Background worker publishes AFTER current notification cycle completes

// âœ… Fix 3 (best): Subject-level depth tracking
_notificationDepth.Value++;
if (_notificationDepth.Value &gt; MaxDepth)
{
    _logger.LogError("Circular notification detected! Depth={Depth}",
        _notificationDepth.Value);
    return; // Break the cycle
}</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-link-slash"></i> Pitfall 5: Observer Order Dependency â€” Hidden Coupling</div>
    <p class="body-text"><strong>The Mistake:</strong> Observers appear independent but actually depend on execution order. Observer B reads data that Observer A writes to a shared cache.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">OrderDependency.cs â€” BAD</span></div><div class="macos-body"><pre><code class="language-csharp">// âŒ Hidden order dependency through shared state
// Observer A: writes sentiment score to shared cache
await _cache.SetAsync($"sentiment:{message.RoomId}", sentimentScore);

// Observer B: READS from the same cache â€” stale if A hasn't run yet!
var sentimentScore = await _cache.GetAsync&lt;decimal&gt;(
    $"sentiment:{message.RoomId}");</code></pre></div></div>
    <p class="body-text"><strong>WHY it is a mistake:</strong> Observers are supposed to be independent. Hidden data flow through shared state couples them without the coupling being visible. Fragile ordering, testing difficulty, and violation of SRP.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">FixedDependency.cs â€” GOOD</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… Fix 1: Make the dependency explicit via composition
public sealed class SentimentAwareObserver : IChatObserver
{
    private readonly ISentimentAnalyzer _analyzer; // Explicit dependency

    public async Task OnMessageReceivedAsync(ChatMessage update, CancellationToken ct)
    {
        var score = _analyzer.Analyze(update.RoomId, update.Content);
        await UpdateModerationRules(update.RoomId, score, ct);
    }
}

// âœ… Fix 2: Use Mediator for ordered workflows
public sealed class MessageProcessingPipeline
{
    public async Task ProcessAsync(ChatMessage update, CancellationToken ct)
    {
        var sentiment = await _analyzer.AnalyzeAsync(update, ct);
        await _moderationService.EvaluateAsync(sentiment, ct);
        await _auditService.LogAsync(update, ct);
    }
}</code></pre></div></div>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-eye-slash"></i> Pitfall 6: Exposing the Observer List</div>
    <p class="body-text"><strong>The Mistake:</strong> The Subject exposes its observer list publicly via <code>public List&lt;IChatObserver&gt; Observers { get; }</code>. External code can <code>.Clear()</code>, <code>.Insert()</code>, or <code>.RemoveAt()</code> bypassing all thread safety, logging, and subscription logic.</p>
    <p class="body-text"><strong>The Fix:</strong> Use private <code>ImmutableList&lt;T&gt;</code> with <code>Subscribe()</code>/<code>Unsubscribe()</code> as the only access points. Return <code>IDisposable</code> tokens from Subscribe â€” this prevents "unsubscribe someone else's observer" bugs. Expose only <code>ObserverCount</code> for monitoring.</p>
  </div>

  <div class="card">
    <div class="card-title"><i class="fa-solid fa-stop-circle"></i> Pitfall 7: Not Handling CancellationToken</div>
    <p class="body-text"><strong>The Mistake:</strong> Observers ignore the <code>CancellationToken</code>, making graceful shutdown impossible. During deployment, the app hangs for 30+ seconds waiting for observers to finish.</p>
    <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">GracefulShutdown.cs â€” GOOD</span></div><div class="macos-body"><pre><code class="language-csharp">// âœ… Full CancellationToken respect
public async Task OnMessageReceivedAsync(ChatMessage update, CancellationToken ct)
{
    ct.ThrowIfCancellationRequested(); // Check BEFORE expensive work

    await client.PostAsJsonAsync("https://analytics.api/ingest", update, ct);
    await _db.SaveChangesAsync(ct); // Pass ct to EVERY async operation
}

// Subject: enforce shutdown timeout
public async ValueTask DisposeAsync()
{
    using var shutdownCts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
    try { await _currentNotificationTask.WaitAsync(shutdownCts.Token); }
    catch (OperationCanceledException)
    { _logger.LogWarning("Shutdown timeout â€” some observers may not have completed"); }
}</code></pre></div></div>
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 18: CHEAT SHEET â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<section id="s18" class="section">
  <div class="section-header">
    <div class="section-icon green"><i class="fa-solid fa-rectangle-list"></i></div>
    <div><div class="section-num">Section 18</div><h2 class="section-title">Cheat Sheet â€” Observer Pattern</h2></div>
  </div>

  <div class="grid-3">
    <div class="card">
      <div class="card-title">Intent</div>
      <p class="body-text">Define a one-to-many dependency between objects so that when one object (the Subject) changes state, all its dependents (Observers) are notified and updated automatically â€” <strong>WITHOUT</strong> the Subject knowing who or how many are listening.</p>
      <p class="body-text"><em>"Let multiple objects react to a single event without coupling the event producer to the event consumers."</em></p>
    </div>

    <div class="card">
      <div class="card-title">Structure</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">structure.txt</span></div><div class="macos-body"><pre><code class="language-plaintext">ISubject               IObserver
â”œâ”€ Subscribe(obs)      â”œâ”€ Update(data)
â”œâ”€ Unsubscribe(obs)    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”œâ”€ Notify()                 â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    ConcreteObserverA
     â”‚              ConcreteObserverB
ConcreteSubject     ConcreteObserverC
â”œâ”€ state
â””â”€ observers: List</code></pre></div></div>
    </div>

    <div class="card">
      <div class="card-title">Key Mechanism</div>
      <p class="body-text"><strong>1. SUBSCRIBE</strong> â€” Observer registers with Subject</p>
      <p class="body-text"><strong>2. STATE CHANGE</strong> â€” Something happens in the Subject</p>
      <p class="body-text"><strong>3. NOTIFY</strong> â€” Subject iterates and calls each Observer</p>
      <p class="body-text"><strong>4. UNSUBSCRIBE</strong> â€” Observer removes itself (optional)</p>
      <p class="body-text"><strong>Key property:</strong> Subject depends on <strong>abstraction</strong> (IObserver), not on concrete observers. Adding a new observer requires ZERO changes to the Subject.</p>
    </div>

    <div class="card">
      <div class="card-title">C# Idiomatic Pattern</div>
      <div class="macos-window"><div class="macos-titlebar"><span class="dot dot-red"></span><span class="dot dot-yellow"></span><span class="dot dot-green"></span><span class="macos-filename">options.cs</span></div><div class="macos-body"><pre><code class="language-csharp">// Option A: Interface-based (DI-heavy apps)
public interface IObserver&lt;T&gt; {
    Task OnUpdateAsync(T data, CancellationToken ct);
}
// DI: services.AddSingleton&lt;IObserver&lt;T&gt;, MyObs&gt;();

// Option B: C# events (simple, in-process)
public event EventHandler&lt;MessageArgs&gt;? Changed;
Changed?.Invoke(this, args);

// Option C: IObservable&lt;T&gt; / Rx.NET (streams)
messageStream.Where(m =&gt; m.RoomId == "#general")
             .Subscribe(m =&gt; Console.WriteLine(m.Content));</code></pre></div></div>
    </div>

    <div class="card">
      <div class="card-title">SOLID Impact</div>
      <div class="table-wrapper"><table>
        <tbody>
          <tr><td><strong>S</strong></td><td>Subject: manage + notify. Each observer: ONE concern.</td></tr>
          <tr><td><strong>O</strong></td><td>Add new observers WITHOUT modifying Subject. #1 contribution.</td></tr>
          <tr><td><strong>L</strong></td><td>All IObserver impls must be substitutable.</td></tr>
          <tr><td><strong>I</strong></td><td>IObserver has a single method. No bloat.</td></tr>
          <tr><td><strong>D</strong></td><td>Subject depends on IObserver abstraction, not concrete impls.</td></tr>
        </tbody>
      </table></div>
    </div>

    <div class="card">
      <div class="card-title">Thread Safety</div>
      <p class="body-text"><strong>1.</strong> Modifying list during iteration â†’ <code>ImmutableList&lt;T&gt;</code> / snapshot copy</p>
      <p class="body-text"><strong>2.</strong> Concurrent subscribe/unsubscribe â†’ <code>ConcurrentDictionary</code> or lock + copy-on-write</p>
      <p class="body-text"><strong>3.</strong> Observer called after unsubscribe â†’ check disposed flag</p>
      <p class="body-text"><strong>4.</strong> Async ordering â†’ sequential await or parallel <code>Task.WhenAll</code></p>
      <p class="body-text"><strong>Golden rule:</strong> Immutable event data + immutable observer list = thread safety without locks.</p>
    </div>

    <div class="card">
      <div class="card-title">Testing Approach</div>
      <p class="body-text"><strong>1.</strong> Mock observers to test the Subject (<code>Times.Once</code>)</p>
      <p class="body-text"><strong>2.</strong> Verify notification delivery â€” correct data, correct observers only</p>
      <p class="body-text"><strong>3.</strong> Test error isolation â€” one throws, others still called</p>
      <p class="body-text"><strong>4.</strong> Test filtering â€” wrong category â†’ <code>Times.Never</code></p>
      <p class="body-text"><strong>5.</strong> Edge cases: zero observers, all disabled, cancellation, null event</p>
    </div>

    <div class="card">
      <div class="card-title">When to Use</div>
      <p class="body-text"><strong>USE:</strong> One event â†’ multiple independent reactions; set of reactions changes over time; producer must not know consumers; plugin/extension architecture.</p>
      <p class="body-text"><strong>DO NOT USE:</strong> Single consumer (direct call); ordering/transactions required (Saga); consumers reply to producer (Request/Reply); extreme event rate with slow observers (message queue).</p>
    </div>

    <div class="card">
      <div class="card-title">.NET Frameworks Using It</div>
      <p class="body-text">C# events/delegates, INotifyPropertyChanged (WPF/MAUI), IObservable&lt;T&gt;/Rx.NET, ASP.NET Middleware, EF Core ChangeTracker, MediatR INotification, SignalR Hubs, .NET EventCounters, IHostedService, IChangeToken, System.Threading.Channels, Blazor StateHasChanged.</p>
      <p class="body-text"><strong>Observer is everywhere in .NET</strong> â€” from UI to infrastructure.</p>
    </div>
  </div>

  <div class="callout callout-info" style="margin-top: 1.5rem; text-align: center; font-size: 1.1rem;">
    <strong>One-Liner:</strong> Observer lets a Subject broadcast state changes to many Observers without knowing who they are, what they do, or how many exist â€” achieving ultimate decoupling between event producers and event consumers.
  </div>
</section>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FOOTER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="footer">
  <p>&copy; 2026 Rafikul Alam &mdash; Pattern Playbook</p>
  <p style="font-size:0.75rem;margin-top:0.5rem;">Observer Design Pattern &mdash; Complete Wiki Reference</p>
</div>

</div><!-- /.wiki-container -->

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• JAVASCRIPT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Wrap card content into collapsible card-body divs
  document.querySelectorAll('.card').forEach(function(card) {
    var title = card.querySelector('.card-title');
    if (!title) return;
    var body = document.createElement('div');
    body.className = 'card-body';
    while (title.nextSibling) {
      body.appendChild(title.nextSibling);
    }
    card.appendChild(body);
    title.addEventListener('click', function() {
      card.classList.toggle('open');
    });
  });

  // Jr â†’ Sr toggle: close others, toggle current
  window.toggleSrSolution = function(btn) {
    var item = btn.closest('.jr-sr-item');
    var wrap = item.querySelector('.sr-solution-wrap');
    var isOpen = wrap.classList.contains('show');
    // Close all open solutions
    document.querySelectorAll('.sr-solution-wrap.show').forEach(function(w) {
      w.classList.remove('show');
    });
    // Toggle current (if it was closed, open it)
    if (!isOpen) {
      wrap.classList.add('show');
    }
  };

  // Make mermaid diagrams collapsible (start collapsed)
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var label = 'Show Diagram';
    var prev = container.previousElementSibling;
    if (prev && prev.tagName === 'H3') {
      label = prev.textContent.trim();
      prev.style.display = 'none';
    }
    var toggle = document.createElement('div');
    toggle.className = 'diagram-toggle';
    toggle.innerHTML = '<i class="fa-solid fa-diagram-project"></i> ' + label + ' <i class="fa-solid fa-chevron-down chevron"></i>';
    container.parentNode.insertBefore(toggle, container);
    container.classList.add('collapsed');
    toggle.addEventListener('click', function() {
      toggle.classList.toggle('open');
      container.classList.toggle('collapsed');
    });
  });

  // Pinch-to-zoom + zoom buttons for mermaid diagrams
  document.querySelectorAll('.mermaid-container').forEach(function(container) {
    var mermaidEl = container.querySelector('.mermaid');
    if (!mermaidEl) return;
    var scale = 1;
    var minScale = 0.5;
    var maxScale = 3;

    // Add zoom buttons
    var zoomDiv = document.createElement('div');
    zoomDiv.className = 'diagram-zoom-controls';
    zoomDiv.innerHTML = '<button class="diagram-zoom-btn" data-action="out" title="Zoom out"><i class="fa-solid fa-minus"></i></button><button class="diagram-zoom-btn" data-action="reset" title="Reset zoom"><i class="fa-solid fa-rotate-left"></i></button><button class="diagram-zoom-btn" data-action="in" title="Zoom in"><i class="fa-solid fa-plus"></i></button>';
    container.appendChild(zoomDiv);

    function applyZoom() {
      mermaidEl.style.transform = 'scale(' + scale + ')';
      mermaidEl.style.transformOrigin = 'top left';
    }

    zoomDiv.addEventListener('click', function(e) {
      var btn = e.target.closest('[data-action]');
      if (!btn) return;
      var action = btn.getAttribute('data-action');
      if (action === 'in') scale = Math.min(maxScale, scale + 0.25);
      else if (action === 'out') scale = Math.max(minScale, scale - 0.25);
      else { scale = 1; }
      applyZoom();
    });

    // Touch pinch-to-zoom
    var lastDist = 0;
    var startScale = 1;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        startScale = scale;
      }
    }, { passive: false });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
        e.preventDefault();
        var dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        scale = Math.min(maxScale, Math.max(minScale, startScale * (dist / lastDist)));
        applyZoom();
      }
    }, { passive: false });

    // Single-finger pan when zoomed
    var panStartX, panStartY, scrollStartX, scrollStartY;
    container.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        panStartX = e.touches[0].clientX;
        panStartY = e.touches[0].clientY;
        scrollStartX = container.scrollLeft;
        scrollStartY = container.scrollTop;
      }
    });
    container.addEventListener('touchmove', function(e) {
      if (e.touches.length === 1 && scale > 1) {
        e.preventDefault();
        container.scrollLeft = scrollStartX - (e.touches[0].clientX - panStartX);
        container.scrollTop = scrollStartY - (e.touches[0].clientY - panStartY);
      }
    }, { passive: false });
  });


  // Initialize Highlight.js
  document.querySelectorAll('pre code').forEach(function(block) {
    hljs.highlightElement(block);
  });

  // Q&A toggle
  document.querySelectorAll('.qa-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Generic collapsible sections
  document.querySelectorAll('.collapsible-header').forEach(function(header) {
    header.addEventListener('click', function() {
      this.parentElement.classList.toggle('active');
    });
  });

  // Tab system
  document.querySelectorAll('.tab-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var container = this.closest('.tab-container');
      var target = this.getAttribute('data-tab');

      container.querySelectorAll('.tab-btn').forEach(function(b) {
        b.classList.remove('active');
      });
      container.querySelectorAll('.tab-panel').forEach(function(p) {
        p.classList.remove('active');
      });

      this.classList.add('active');
      var panel = container.querySelector('[data-panel="' + target + '"]');
      if (panel) panel.classList.add('active');
    });
  });

  // Nav toggle
  var navFab = document.getElementById('navFab');
  var navPanel = document.getElementById('navPanel');
  navFab.addEventListener('click', function() {
    navPanel.classList.toggle('open');
    navFab.classList.toggle('active');
  });

  // Smooth scroll helper with easing
  function smoothScrollTo(targetY, duration) {
    if (window.matchMedia('(prefers-reduced-motion:reduce)').matches) {
      window.scrollTo(0, targetY);
      return;
    }
    var startY = window.scrollY;
    var diff = targetY - startY;
    var startTime = null;
    function step(timestamp) {
      if (!startTime) startTime = timestamp;
      var progress = Math.min((timestamp - startTime) / duration, 1);
      var ease = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      window.scrollTo(0, startY + diff * ease);
      if (progress < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // Nav panel links â€” smooth scroll + auto-close
  document.querySelectorAll('.nav-panel a').forEach(function(link) {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      var target = document.querySelector(this.getAttribute('href'));
      if (target) {
        var offset = target.getBoundingClientRect().top + window.scrollY - ((document.querySelector('.top-toolbar')||{}).offsetHeight||56) - 8;
        smoothScrollTo(offset, 800);
      }
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    });
  });

  // Click outside to close nav panel and open diagrams (merged handler)
  document.addEventListener('click', function(e) {
    if (navPanel.classList.contains('open') && !navPanel.contains(e.target) && !navFab.contains(e.target)) {
      navPanel.classList.remove('open');
      navFab.classList.remove('active');
    }
    document.querySelectorAll('.diagram-toggle.open').forEach(function(toggle) {
      var container = toggle.nextElementSibling;
      if (!toggle.contains(e.target) && !container.contains(e.target)) {
        toggle.classList.remove('open');
        container.classList.add('collapsed');
      }
    });
  });

  // Scroll up/down buttons
  var reducedMotion = window.matchMedia('(prefers-reduced-motion:reduce)');
  document.getElementById('scrollUp').addEventListener('click', function() {
    var scrollAmount = Math.round(window.innerHeight * 0.35);
    window.scrollBy({ top: -scrollAmount, behavior: reducedMotion.matches ? 'auto' : 'smooth' });
  });
  document.getElementById('scrollDown').addEventListener('click', function() {
    var scrollAmount = Math.round(window.innerHeight * 0.35);
    window.scrollBy({ top: scrollAmount, behavior: reducedMotion.matches ? 'auto' : 'smooth' });
  });

  // Scroll percentage tracker
  var percentText = document.getElementById('percentText');
  window.addEventListener('scroll', function() {
    var docHeight = document.documentElement.scrollHeight - window.innerHeight;
    var percent = docHeight > 0 ? Math.round((window.scrollY / docHeight) * 100) : 0;
    percentText.textContent = percent + '%';
  });

  // Fullscreen toggle
  var fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', function() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });
  document.addEventListener('fullscreenchange', function() {
    var icon = fsBtn.querySelector('i');
    if (document.fullscreenElement) {
      icon.className = 'fa-solid fa-compress';
    } else {
      icon.className = 'fa-solid fa-expand';
    }
  });

  // Expand/Collapse all cards toggle
  var expandBtn = document.getElementById('expandAllBtn');
  var allExpanded = false;
  expandBtn.addEventListener('click', function() {
    allExpanded = !allExpanded;
    var cards = document.querySelectorAll('.card');
    cards.forEach(function(card) {
      if (allExpanded) {
        card.classList.add('open');
      } else {
        card.classList.remove('open');
      }
    });
    var icon = expandBtn.querySelector('i');
    icon.className = allExpanded ? 'fa-solid fa-angles-up' : 'fa-solid fa-angles-down';
    expandBtn.title = allExpanded ? 'Collapse all cards' : 'Expand all cards';
  });
});
</script>
</body>
</html>